\section{Hardware description language}

We motivated graph rewriting for digital circuits as an avenue for
\emph{automating} their reasoning.
To this end, the operational semantics for sequential circuits from
\cref{sec:operational} has been implemented into a
\emph{hardware description language} in Cangjie, a new programming
language developed by Huawei.

\subsection{Design}

Much like the theoretical background, circuits created using the tool are
parameterised over a particular signature of components.
Rather than designing circuits using the categorical style of juxtaposing
tiles in sequence and parallel, the tool uses a more conventional approach
where the user manipulates wires and provides them as arguments to other
components.

\begin{example}
    We will first demonstrate how to define the combinational half adder circuit
    from \cref{ex:half-adder}.
    For pedagogical purposes, we begin by defining an \(\xorgate\) gate.
    \begin{lstlisting}
      let xorA = sig.UseWire(1)
      let xorB = sig.UseWire(1)
      let xorOr = UseOr(xorA, xorB)
      let xorNand = UseNot(UseAnd(xorA, xorB))
      let xorAnd = UseAnd(xorOr, xorNand)
      let xor = MakeSubcircuit(
        [InterfaceWire(xorA, "A"), InterfaceWire(xorB, "B")],
        [InterfaceWire(xorAnd, "Z")],
        "XOR"
      )
    \end{lstlisting}

    Once a subcircuit has been defined, a specification in Dot can be generated
    and rendered using Graphviz.

    \begin{center}
        \includesvg[scale=0.3]{figures/circuits/hdl/xor}
    \end{center}

    Using the \(\xorgate\) as a subcomponent, we can define the half adder.

    \begin{lstlisting}
    let addA = sig.UseWire(1)
    let addB = sig.UseWire(1)
    let sum = UseSubcircuit(xor, [addA, addB])[0]
    let carry = UseAnd(addA, addB)
    let halfAdder = MakeSubcircuit(
      [InterfaceWire(addA, "A"), InterfaceWire(addB, "B")],
      [InterfaceWire(sum, "S"), InterfaceWire(carry, "C")],
      "half adder"
    )
    \end{lstlisting}

    The generated graphs have a hierarchical structure: because we defined the
    \(\xorgate\) gate as a subcircuit, we can view it as a black box or
    expand it.

    \begin{center}
        \includesvg[scale=0.3]{figures/circuits/hdl/add-0}

        \vspace{1em}

        \includesvg[scale=0.3]{figures/circuits/hdl/add-1}
    \end{center}
\end{example}

As usual, it is the \emph{sequential} circuits which are the most interesting.
The tool can be used to insert delays and feedback loops to circuits.

\begin{example}\label{ex:sr-latch-hdl}
    The SR NOR latch from \cref{ex:sr-latch} can be created
    \begin{lstlisting}
      let r = sig.UseWire(1)
      let s = sig.UseWire(1)
      let fb = sig.UseWire(1)
      let or1 = UseOr(r, fb)
      let not1 = UseNot(or1, delay: 1)
      let or2 = UseOr(not1, s)
      let not2 = UseNot(or2)
      Feedback(not2, fb)
      let latch = MakeSubcircuit(
        [InterfaceWire(r, "R"), InterfaceWire(s, "S")],
        [InterfaceWire(not1, "Q"), InterfaceWire(not2, "Q'")],
        "SR NOR Latch"
      )
    \end{lstlisting}
    \begin{center}
        \scalebox{0.3}{\includesvg{figures/circuits/hdl/latch}}
    \end{center}
\end{example}

\subsection{Evaluation}

The real power of the tool comes from how it can automatically \emph{evaluate}
circuits using a reduction procedure based on the operational semantics.
As with the theory, it does this by first assembling circuits into Mealy form
and eliminating non-delay-guarded feedback.

\begin{example}
    Before evaluation can be performed, the SR NOR latch defined in
    \cref{ex:sr-latch} is automatically translated into Mealy form.
    \begin{lstlisting}
      let eval = Evaluator(latch)
    \end{lstlisting}
    \begin{center}
        \scalebox{0.25}{\includesvg{figures/circuits/hdl/latch-mealy}}
    \end{center}
    Note that this is a simpler circuit than the corresponding string diagram
    version in \cref{ex:sr-latch-unrolled} because the tool automatically
    applies combinational reductions (in particular, the elimination rule) to
    tidy up the resulting circuit.
\end{example}

Once the circuit is translated into the correct form, inputs can be provided
and the circuit evaluated step-by-step.

\begin{example}
    We now provide inputs to the evaluator created in
    \cref{ex:sr-latch-evaluator}.
    \begin{lstlisting}
      let eval = Evaluator(latch)
      eval.PerformCycle([FALSE, TRUE])
      eval.PerformCycle([FALSE, FALSE])
      eval.PerformCycle([FALSE, FALSE])
      eval.PerformCycle([TRUE, FALSE])
    \end{lstlisting}
    This automatically applies the streaming and value rules in order to
    determine the output values over time.
    The inputs detailed above produce the output stream \(
    \bot\mathsf{f} \streamcons \mathsf{t}\mathsf{f} \streamcons
    \mathsf{t}\mathsf{f} \streamcons \mathsf{f}\mathsf{t}
    \), as expected.
    \begin{center}
        \scalebox{0.225}{\includesvg{figures/circuits/hdl/latch-outputs}}
    \end{center}
\end{example}
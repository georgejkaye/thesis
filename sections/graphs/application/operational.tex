\section{Sequential circuits}

Much of the nuance that arises when using the operational semantics of
sequential circuits is the treatment of feedback.
In hypergraphs there is no distinguishing between a wire going
`backwards' or a regular wire, so we must explicitly keep track of traces if we
need to rewrite them later.
To represent this in our diagrams, we will colour any trace source tentacle red.

\begin{example}\label{ex:sr-latch-interpretation}
    Recall the SR NOR latch circuit from \cref{ex:sr-latch}.
    This is interpreted as a partial left-monogamous cospan of hypergraphs as
    follows, where the \(\wedge\), \(\neg\) and \(\delta\) edges respectively
    represent the \(\orgate\) gate, \(\notgate\) gate, and delay.
    \begin{center}
        \begin{tikzcd}[bezier bounding box=true,column sep=tiny]
            \iltikzfig{graphs/circuits/sr-latch/inputs}
            \arrow{r}
            &
            \iltikzfig{graphs/circuits/sr-latch/latch}
            &
            \arrow{l}
            \iltikzfig{graphs/circuits/sr-latch/outputs}
        \end{tikzcd}
    \end{center}
\end{example}

Since the transformation into global trace-delay form is through axioms
of STMCs, as hypergraphs a circuit and its trace-delay form are isomorphic.
Rather than having to manipulate a term, we keep track of `trace' and `delay'
tentacles.

\begin{example}\label{ex:sr-latch-global-delay}
    To identify a `trace-delay form' for the graph in
    \cref{ex:sr-latch-interpretation}, we must keep track of the
    non-delay-guarded feedback (the red tentacle) and the source tentacle of the
    delay edge.
\end{example}

The first rewrite that needs to be applied is the global Mealy reduction
\((\mealyeqn)\).
As this is a reduction parameterised over an arbitrary core \(
\iltikzfig{strings/category/f-3-3}[box=f]
\), it actually specifies a \emph{family} of rewrites, one for each possible
core.

\begin{example}\label{ex:sr-latch-mealy-graph}
    Applying the Mealy rewrite to \cref{ex:sr-latch-interpretation} produces:
    \vspace{-1em}
    \begin{center}
        \begin{tikzcd}[bezier bounding box=true,column sep=tiny]
            \iltikzfig{graphs/circuits/sr-latch/inputs}
            \arrow{r}
            &
            \iltikzfig{graphs/circuits/sr-latch/mealy}
            &
            \arrow{l}
            \iltikzfig{graphs/circuits/sr-latch/outputs}
        \end{tikzcd}
    \end{center}
\end{example}

The instant feedback reduction can produce a complicated term with many forks;
in the hypergraph representation, these forks are all absorbed into one.

\begin{example}\label{ex:instant-feedback-rewrite}
    Below is an example showing how the instant feedback rewrite is applied to
    a circuit in Mealy form containing one generator \(e\).
    \begin{center}
        \includestandalone{figures/graphs/circuits/unroll/rewrite}
    \end{center}
\end{example}

As the instant feedback rule eliminates non-delay-guarded feedback loops, there
are no red tentacles in the right hand side of the rule or the rewritten graph.

\begin{example}\label{ex:sr-latch-instant-feedback-graph}
    The interpretation of the SR latch from \cref{ex:sr-latch-mealy-graph}
    after being rewritten by the instant feedback rewrite is shown below.
    \vspace{-1em}
    \begin{center}
        \begin{tikzcd}[bezier bounding box=true, column sep=tiny]
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/inputs}}
            \arrow{r}
            &
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/instant-feedback}}
            &
            \arrow{l}
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/outputs}}
        \end{tikzcd}
    \end{center}
\end{example}

After performing the instant feedback rewrite, the graph is ready to receive
inputs.
As with the string diagrammatic procedure, we precompose the graph with some
inputs and perform the streaming rewrite.

\begin{example}\label{ex:sr-latch-streaming-graph}
    We apply the inputs \(\belnaptrue\belnapfalse\) to the prepared SR latch
    hypergraph from \cref{ex:sr-latch-instant-feedback-graph} by precomposing
    some value registers.
    \vspace{-1em}
    \begin{center}
        \begin{tikzcd}[bezier bounding box=true, column sep=tiny]
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/inputs}}
            \arrow{r}
            &
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/applied}}
            &
            \arrow{l}
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/outputs}}
        \end{tikzcd}
    \end{center}
    This graph is then rewritten by the streaming rule.
    \vspace{-1em}
    \begin{center}
        \begin{tikzcd}[bezier bounding box=true, column sep=tiny]
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/inputs}}
            \arrow{r}
            &
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/streamed}}
            &
            \arrow{l}
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/outputs}}
        \end{tikzcd}
    \end{center}
\end{example}

The final step is to propagate the values across the `top' subcircuit using the
value rules, which have straightforward hypergraph interpretations illustrated
in \cref{fig:graph-values}.

\begin{figure}
    \centering
    \scalebox{0.8}{\includestandalone{figures/graphs/circuits/gate/rule}}
    \quad
    \raisebox{0.5em}{\scalebox{0.8}{\includestandalone{figures/graphs/circuits/fork-rewrite/rule}}}
    \\
    \scalebox{0.8}{\includestandalone{figures/graphs/circuits/join/rule}}
    \quad
    \raisebox{1em}{\scalebox{0.8}{\includestandalone{figures/graphs/circuits/stub/rule}}}
    \caption{Hypergraph interpretations of the value rules}
    \label{fig:graph-values}
\end{figure}

\begin{example}
    When applying the value rules to the streamed circuit from
    \cref{ex:sr-latch-streaming-graph}, we apply the fork rules as much as
    possible to propagate the values:
    \begin{center}
        \begin{tikzcd}[bezier bounding box=true, column sep=tiny]
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/inputs}}
            \arrow{r}
            &
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/values-1}}
            &
            \arrow{l}
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/outputs}}
        \end{tikzcd}
    \end{center}
    We can then repeatedly apply the gate and eliminate rule to obtain
    the outputs and next state, which can be seen below.
    \begin{center}
        \begin{tikzcd}[bezier bounding box=true, column sep=tiny]
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/inputs}}
            \arrow{r}
            &
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/values-2}}
            &
            \arrow{l}
            \scalebox{0.7}{\iltikzfig{graphs/circuits/sr-latch/outputs}}
        \end{tikzcd}
    \end{center}
    To identify the outputs, one simply needs to traverse from the outputs of
    the graph; if productivity is applied multiple times then there will be a
    sequence of values to iterate through.
\end{example}

\begin{remark}
    Note that the fork rule is not left-linear as it uses the comonoid
    structure; this can lead to a small issue when performing the operational
    semantics.
    Consider the term \(
    \iltikzfig{graphs/circuits/fork-rewrite/term-g}
    \); in the hypergraph interpretation it is possible to apply the fork rule
    to this term.
    \begin{gather*}
        \includestandalone{figures/graphs/circuits/fork-rewrite/fork-rewrite}
    \end{gather*}
    This reduction has arisen due to the counitality of the comonoid.
    \begin{gather*}
        \iltikzfig{graphs/circuits/fork-rewrite/term-g}
        =
        \iltikzfig{graphs/circuits/fork-rewrite/term-g-1}
        \reduction
        \iltikzfig{graphs/circuits/fork-rewrite/term-h}
    \end{gather*}
    This means that care must be taken when performing the reduction procedure;
    a fork rewrite is only productive if the vertex in the image of \(f\) has
    out-degree strictly greater than \(1\).
    If we arbitrarily any rewrite we find, we may end up stuck in a loop of
    forking and stubbing the same subcircuit.
\end{remark}

\begin{remark}
    Another scenario that looks like it might cause issues is when considering
    a value connected to the outputs of a term.
    \begin{gather*}
        \iltikzfig{circuits/components/values/vs}
        \qquad
        \iltikzfig{graphs/circuits/stub/g}
    \end{gather*}
    It might seem like the elimination rule can be applied here and delete the
    value connected to the interface.
    However, this is forbidden by DPO rewriting \emph{with interfaces}; there
    are no maps from the interface to the context or the rewritten graph so this
    cannot be a valid rewrite.
    \begin{center}
        \includestandalone{figures/graphs/circuits/stub/rewrite}
    \end{center}
\end{remark}
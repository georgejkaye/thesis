\chapter{Graphs}

String diagrams are an appealing way of reasoning with pen and paper: they bring
intuition to confusing one-dimensional text strings, can often shed light on the
next step of a proof, and most importantly, they look very pretty.
Unfortunately, they do have drawbacks: they take up a lot of time and space, and
if one is not careful the scribbles on a whiteboard might all start to merge
into one, resulting in a mess worse than the original term representation.

Instead it is desirable to perform reasoning with string diagrams
\emph{computationally}.
Although computers do not deal well with topological objects like string
diagrams `as is', they are very well acquainted with combinatorial objects: for
a computer to reason effectively with string diagrams, they must first be
interpreted as \emph{graphs}.

\section{String diagram rewriting}

String diagram graph rewriting is a relatively new field, first appearing at the
turn of the 2010s with \emph{string graphs}~\cite{%
    dixon2010open,dixon2013opengraphs,kissinger2012pictures%
}.
In string graphs, string diagrams are represented as graphs with two classes of
nodes for \emph{boxes} and \emph{wires}; it should be obvious which nodes
correspond to which element of string diagram design.
Crucially, one wire in a string diagram could be represented by arbitrarily
many wire nodes connected together; all of these different depictions are
identified by a notion of \emph{wire homeomorphism}, in which adjacent wire
nodes can be collapsed into one.

\todo[inline]{String graph example?}

String graphs modulo wire homeomorphism is a suitable setting for modelling
traced or compact closed categories.
More recently, there has been a flurry of work on string diagram rewriting
modulo \emph{Frobenius structure} using \emph{hypergraphs}~\cite{%
    bonchi2016rewriting,zanasi2017rewriting,bonchi2017confluence,%
    bonchi2018rewriting,bonchi2022string,bonchi2022stringa,bonchi2022stringb%
}.
Hypergraphs are a generalisation of graphs in which edges can have arbitrarily
many sources and targets, rather than just one each.
With hypergraphs, generators are represented as hyperedges, and connections
between generators indicated by if their sources and targets overlap.
The beauty of the hypergraph formalism is that there is no restriction for
nodes to only be incident on a single source and target, so one can easily
model structures such as monoids or comonoids.
It turns out when modelling string diagrams as hypergraphs, the equations of
a \emph{special commutative Frobenius algebra} are `absorbed': string diagrams
equal by Frobenius are interpreted as isomorphic hypergraphs.
This means that, in some sense, rewriting using hypergraphs can be even more
advantageous than using string diagrams!

\todo[inline]{Hypergraph example?}

Naturally, there have also been variations on this work where the complete
Frobenius structure is not present.
Suitable restrictions on hypergraphs and the graph rewriting process are also
identified in~\cite{bonchi2016rewriting} for rewriting
\emph{symmetric monoidal structure}.
Research followed on rewriting modulo
\emph{(co)monoid structure}~\cite{milosavljevic2023string} (`half a Frobenius')
and our work~\cite{ghica2023rewriting} on rewriting modulo
\emph{traced comonoid structure}.
The latter is the basis for this part of the thesis.

\section{Hypergraphs}

Hypergraphs are formally defined as a functor category.

\todo[inline]{Blackboard 1}

\begin{definition}[Hypergraph~\cite{bonchi2016rewriting}]
    Let \(\mathbf{X}\) be the category with objects
    \((\nat \times \nat) + 1\) and morphisms
    \(\morph{\sources{i}}{(k,l)}{\star}\) for each \(i < k\) and
    \(\morph{\targets{j}}{(k,l)}{\star}\) for each \(j < l\).
    The category of hypergraphs \(\hyp\) is the functor category
    \([\mathbf{X}, \set]\).
\end{definition}

One can think of the category \(\mathbf{X}\) as a `template' for the structure
of a hypergraph: the object \(\star\) represents the nodes and each object
\((k, l)\) represents hyperedges with \(k\) sources and \(l\) targets; each such
edge must pick \(k\) sources and \(l\) targets from \(\star\).

Objects in \(\hyp\) are functors that instantiates each object in \(\mathbf{X}\)
to a concrete set.
Subsequently, for a hypergraph \(F \in \hyp\) we write \(\vertices{F}\) for its
set of nodes and \(\edges{F}{k}{l}\) for the set of edges with \(k\) sources and
\(l\) targets.
Morphisms in \(\hyp\) are morphisms between hypergraphs which preserve their
structure.

\begin{definition}[Hypergraph homomorphism]
    Given two hypergraphs \(F, G \in \hyp\), \emph{hypergraph homomorphism}
    \(F \to G\) consists of functions
    \(\morph{\vertices{f}}{\vertices{F}}{\vertices{G}}\) and
    \(\morph{\edges{f}{k}{l}}{\edges{F}{k}{l}}{\edges{G}{k}{l}}\) such that the
    following diagrams commute:
    \input{floats/hypergraph-homs}
\end{definition}

Much like with regular graphs, it is much more intuitive to draw out hypergraphs
rather than look at their combinatorial representation.
We draw nodes as black dots, and hyperedges as `bubbles' with ordered tentacles
on the left and right that connect to source and target nodes respectively.

\begin{example}
    \todo[inline]{Do hypergraph example}
\end{example}

\subsection{Labelled hypergraphs}

From the example drawn above, it should be clear to see how hypergraphs are a
suitable representation of string diagrams: generators correspond to hyperedges
and wires to the nodes between them.
However, the hyperedges are currently not \emph{labelled} with symbols from the
signature.
To do this, we must first translate the notion of signature to hypergraphs.

\begin{definition}[Hypergraph signature~\cite{bonchi2016rewriting}]
    For a set of generators \(\signature\) as defined in \cref{def:generators},
    the \emph{hypergraph signature} \(\hypsignature{\Sigma} \in \hyp\) is
    defined as follows:
    \begin{gather*}
        \vertices{\hypsignature{\Sigma}} := \{ v_n \,|\, n \in \natplus\}
        \quad
        \edges{\hypsignature{\Sigma}} := \{ e_g \,|\, g \in \signature\}
        \\
        \sources{i}(e_g) := v_{\dom[e_g](i)}
        \quad
        \targets{j}(e_g) := v_{\cod[e_g]{j}}
    \end{gather*}
\end{definition}

\begin{example}
    \todo[inline]{Do hypergraph signature example}
\end{example}

Labels can then be assigned to the edges of a hypergraph \(F\) using a
homomorphism \(F \to \hypsignature{\Sigma}\).
To do this to \emph{all} the hypergraphs in \(\hyp\), we utilise some
categorical machinery.

\begin{definition}[Slice category~\cite{lawvere1963functorial}]
    For a category \(\mathbf{C}\) and an object \(C \in \mathbf{C}\), the
    \emph{slice category} \(\mathbf{C} / C\) has objects the morphisms of
    \(\mathbf{C}\) with target \(C\) and morphisms
    \((\morph{f}{X}{C}) \to (\morph{g}{X^\prime}{C})\) the morphisms
    \(\morph{g}{X}{X^\prime} \in \mathbf{C}\) such that \(f^\prime\circ g = f\).
\end{definition}

\begin{definition}[Labelled hypergraphs~\cite{bonchi2016rewriting}]
    Let \(\hypsigma\) be the category of hypergraphs labelled over a set of
    generators \(\Sigma\), defined as the slice category
    \(\hyp / \hypsignature{\Sigma}\).
\end{definition}

\subsection{Cospans of hypergraphs}

String diagrams also \emph{input} and \emph{output} interfaces.
Labelled hypergraphs may have suggestively dangling nodes in the pictures,
but and are not ordered, and moreover we may wish to set a non-dangling node
as an interface.
To set the interfaces of a hypergraph, we will use more hypergraph homomorphisms
to `pick' the appropriate nodes.


\todo[inline]{Adapt from FSCD paper section 2}

\chapter{Graphs}

String diagrams are an appealing way of reasoning with pen and paper: they bring
intuition to confusing one-dimensional text strings, can often shed light on the
next step of a proof, and most importantly, they look very pretty.
Unfortunately, they do have drawbacks: they take up a lot of time and space, and
if one is not careful the scribbles on a whiteboard might all start to merge
into one, resulting in a mess worse than the original term representation.

Instead it is desirable to perform reasoning with string diagrams
\emph{computationally}.
Although computers do not deal well with topological objects like string
diagrams `as is', they are very well acquainted with combinatorial objects: for
a computer to reason effectively with string diagrams, they must first be
interpreted as \emph{graphs}.

\section{String diagram rewriting}

String diagram graph rewriting is a relatively new field, first appearing at the
turn of the 2010s with \emph{string graphs}~\cite{%
    dixon2010open,dixon2013opengraphs,kissinger2012pictures%
}.
In string graphs, string diagrams are represented as graphs with two classes of
nodes for \emph{boxes} and \emph{wires}; it should be obvious which nodes
correspond to which element of string diagram design.
Crucially, one wire in a string diagram could be represented by arbitrarily
many wire nodes connected together; all of these different depictions are
identified by a notion of \emph{wire homeomorphism}, in which adjacent wire
nodes can be collapsed into one.

\todo[inline]{String graph example?}

String graphs modulo wire homeomorphism is a suitable setting for modelling
traced or compact closed categories.
More recently, there has been a flurry of work on string diagram rewriting
modulo \emph{Frobenius structure} using \emph{hypergraphs}~\cite{%
    bonchi2016rewriting,zanasi2017rewriting,bonchi2017confluence,%
    bonchi2018rewriting,bonchi2022string,bonchi2022stringa,bonchi2022stringb%
}.
Hypergraphs are a generalisation of graphs in which edges can have arbitrarily
many sources and targets, rather than just one each.
With hypergraphs, generators are represented as hyperedges, and connections
between generators indicated by if their sources and targets overlap.
The beauty of the hypergraph formalism is that there is no restriction for
nodes to only be incident on a single source and target, so one can easily
model structures such as monoids or comonoids.
It turns out when modelling string diagrams as hypergraphs, the equations of
a \emph{special commutative Frobenius algebra} are `absorbed': string diagrams
equal by Frobenius are interpreted as isomorphic hypergraphs.
This means that, in some sense, rewriting using hypergraphs can be even more
advantageous than using string diagrams!

\todo[inline]{Hypergraph example?}

Naturally, there have also been variations on this work where the complete
Frobenius structure is not present.
Suitable restrictions on hypergraphs and the graph rewriting process are also
identified in~\cite{bonchi2016rewriting} for rewriting
\emph{symmetric monoidal structure}.
Research followed on rewriting modulo
\emph{(co)monoid structure}~\cite{milosavljevic2023string} (`half a Frobenius')
and our work~\cite{ghica2023rewriting} on rewriting modulo
\emph{traced comonoid structure}.
The latter is the basis for this part of the thesis.

\section{Hypergraphs}

We will begin by defining the categories of hypergraphs required, following the
pattern detailed in \cite{bonchi2022string}.
Hypergraphs are formally defined as a functor category.

\begin{definition}[Hypergraph~\cite{bonchi2016rewriting}]
    Let \(\mathbf{X}\) be the category with object set
    \((\nat \times \nat) + \star\) and morphisms
    \(\morph{\sources{i}}{(k,l)}{\star}\) for each \(i < k\)
    and \(\morph{\targets{j}}{(k,l)}{\star}\) for each \(j < l\).
    The category of hypergraphs \(\hyp\) is the functor category
    \([\mathbf{X}, \set]\).
\end{definition}

One can think of the category \(\mathbf{X}\) as a `template' for the structure
of a hypergraph: the object \(\star\) represents the nodes and each object
\((k, l)\) represents hyperedges with \(k\) sources and \(l\) targets; each such
edge must pick \(k\) sources and \(l\) targets from \(\star\).

Objects in \(\hyp\) are functors that instantiates each object in \(\mathbf{X}\)
to a concrete set.
Subsequently, for a hypergraph \(F \in \hyp\) we write \(\vertices{F}\) for its
set of nodes and \(\edges{F}{k}{l}\) for the set of edges with \(k\) sources and
\(l\) targets.
Since it is a functor category, the morphisms in \(\hyp\) are natural
transformations: structure-preserving maps between hypergraphs.

\begin{definition}[Hypergraph homomorphism]
    Given two hypergraphs \(F, G \in \hyp\), \emph{hypergraph homomorphism}
    \(F \to G\) consists of functions
    \(\morph{\vertices{f}}{\vertices{F}}{\vertices{G}}\) and
    \(\morph{\edges{f}{k}{l}}{\edges{F}{k}{l}}{\edges{G}{k}{l}}\) such that the
    following diagrams commute:
    \input{floats/hypergraph-homs}
\end{definition}

Much like with regular graphs, it is much more intuitive to draw out hypergraphs
rather than look at their combinatorial representation.
We draw nodes as black dots, and hyperedges as `bubbles' with ordered tentacles
on the left and right that connect to source and target nodes respectively.

\begin{example}
    \todo[inline]{Do hypergraph example}
\end{example}

\subsection{Labelled hypergraphs}

From the example drawn above, it should be clear to see how hypergraphs are a
suitable representation of string diagrams: generators correspond to hyperedges
and wires to the nodes between them.
However, the hyperedges are currently not \emph{labelled} with generator
symbols.
To do this, we must first translate the notion of signature to hypergraphs.

\begin{definition}[Hypergraph signature~\cite{bonchi2016rewriting}]
    For a set of generators \(\signature\) and sorts \(\mcs\) as defined
    in \cref{def:generators}, the \emph{hypergraph signature}
    \(\hypsignature{(\Sigma, S)} \in \hyp\) is defined as follows:
    \begin{gather*}
        \vertices{\hypsignature{\Sigma}} := \{ v_n \,|\, s \in \mcs\}
        \quad
        \edges{\hypsignature{\Sigma}}{k}{l} := \{ e_g \,|\, g \in \signature\}
        \\
        \sources{i}(e_g) := v_{\dom[e_g](i)}
        \quad
        \targets{j}(e_g) := v_{\cod[e_g](j)}
    \end{gather*}
\end{definition}

\begin{example}
    \todo[inline]{Do hypergraph signature example}
\end{example}

The vertices and edges of a hypergraph \(F\) can then be assigned sorts from
\(\mcs\) and symbols from \(\Sigma\) using a homomorphism
\(F \to \hypsignature{\Sigma,\mcs}\).
To do this to \emph{all} the hypergraphs in \(\hyp\) and create a category of
\emph{labelled} hypergraphs, we make use of some more categorical machinery.

\begin{definition}[Slice category~\cite{lawvere1963functorial}]
    For a category \(\mathbf{C}\) and an object \(C \in \mathbf{C}\), the
    \emph{slice category} \(\mathbf{C} \slice C\) has objects the morphisms of
    \(\mathbf{C}\) with target \(C\) and morphisms
    \((\morph{f}{X}{C}) \to (\morph{g}{X^\prime}{C})\) the morphisms
    \(\morph{g}{X}{X^\prime} \in \mathbf{C}\) such that \(f^\prime\circ g = f\).
\end{definition}

\begin{definition}[Labelled hypergraphs~\cite{bonchi2016rewriting}]
    Let \(\hypsigmas\) be the category of hypergraphs labelled over a set of
    generators \(\Sigma\) and sorts \(\mcs\), defined as the slice category
    \(\hyp \slice \hypsignature{(\Sigma, \mcs)}\).
\end{definition}

\begin{example}
    \todo[inline]{Do labelled hypergraph example}
\end{example}

\subsection{Cospans of hypergraphs}

String diagrams also have \emph{input} and \emph{output} interfaces.
(Labelled) hypergraphs may have suggestively dangling nodes in the pictures,
but and are not ordered, and moreover we may wish to set a non-dangling node
as an interface.
To set the interfaces of a hypergraph, hypergraph homomorphisms are used
to `pick' the appropriate nodes.

\begin{definition}[Cospan]
    A \emph{cospan} in a category \(\mcc\) is a pair of morphisms \(X \to A\)
    and \(X \to B\) in \(\mcc\), usually written \(\cospan{X}{A}{Y}\).

    A \emph{cospan morphism} \(
        (\cospan{X}[f]{A}[g]{Y}) \to (\cospan{X}[h]{B}[k]{Y})
    \) is a morphism \(\morph{\alpha}{A}{B}\) in \(\mathbf{C}\)
    such that the following diagram commutes:
    %
    \begin{center}
        \includestandalone{figures/category/diagrams/cospan-morphism}
    \end{center}
%
    Two cospans \(\cospan{X}{A}{Y}\) and \(\cospan{X}{B}{Y}\) are
    \emph{isomorphic} if there exists a morphism of cospans as above where
    \(\alpha\) is an isomorphism.
\end{definition}


As with all the constructions so far, cospans must be assembled into a category
to be useful for our purpose.
This means a notion of \emph{composition} of cospans is required.

\begin{definition}[Composition of cospans]
    \label{def:cospan-composition}
    In a category \(\mcc\) with pushouts, the composition of cospans
    \(\cospan{X}[f]{A}[g]{Y}\) and \(\cospan{Y}[h]{B}[k]{Z}\) is by pushout:
    \begin{center}
        \includestandalone{figures/category/diagrams/cospan-composition}
    \end{center}
\end{definition}

\begin{definition}[Categories of cospans]
    Let \(\mcc\) be a category with pushouts and an initial object.
    The category of cospans over \(\mathbf{C}\), denoted \(\csp{\mathbf{C}}\),
    has as objects the objects of \(\mathbf{C}\) and as morphisms \(A \to B\)
    the isomorphism classes of cospans \(\cospan{A}{X}{B}\) for some
    \(X \in \mcc\).
    Composition is by pushout as detailed in \cref{def:cospan-composition} and
    the identity is \(X \xrightarrow{\id[X]} X \xleftarrow{\id[X]} X\).

    This category is symmetric monoidal with tensor given by the coproduct in
    \(\mathbf{C}\), unit the initial object \(0 \in \mathbf{C}\), and symmetry
    by \(\cospan{A+B}{A+B}{B+A}\).
\end{definition}

Interfaces are assigned to a hypergraph \(F\) by having it occupy the `apex' of
a cospan and having the `legs' on either side pick inputs and outputs
respectively.

\begin{definition}[Discrete hypergraph]
    A \emph{discrete hypergraph} is a hypergraph in which each edge set is
    empty.
\end{definition}

A discrete hypergraph with \(n\) nodes all of a sort \(s\) is written as \(s^n\)
when clear from context.
Discrete hypergraphs can represent the \emph{number} of interface nodes; all
that remains is the \emph{order}.

\begin{theorem}[\cite{bonchi2022string}, Thm. 3.6]
    Let \(\mathbb{X}\) be a PROP whose monoidal product is a coproduct,
    \(\mathbf{C}\) a category with pushouts and an initial object, and \(
        \morph{F}{\mathbb{X}}{\mathbf{C}}
    \) a coproduct-preserving functor.
    Then there exists a multi-sorted PROP \(\csp[F]{\mathbf{C}}\) whose arrows
    \(\listvar{m} \to \listvar{n}\) are isomorphism classes of \(\mathbf{C}\)
    cospans \(\cospan{F\listvar{n}}{C}{Fn}\).
\end{theorem}



\begin{theorem}[\cite{bonchi2022string}, Thm. 3.8]
    \label{thm:cospan-homomorphism}
    Let \(\mathbb{X}\) be a PROP whose monoidal product is a coproduct,
    \(\mathbf{C}\) a category with a pushout and an initial object, and
    \(\morph{F}{\mathbb{X}}{\mathbf{C}}\) a coproduct-preserving functor.
    Then there is a homomorphism of PROPs \(
        \morph{\tilde{F}}{\csp{\mathbb{X}}}{\csp[F]{\mathbf{C}}}
    \) that sends \(\cospan{\listvar{m}}[f]{X}[g]{\listvar{{n}}}\) to
    \(\cospan{F\listvar{m}}[Ff]{FX}[Fg]{F\listvar{n}}\).
    If \(F\) is full and faithful, then \(\tilde{F}\) is faithful.
\end{theorem}

All that remains is to identify the exact functor to be used for
interpreting string diagrams as cospans of hypergraphs.

\begin{definition}
    Let \(\finsetprop\) be the PROP with morphisms \(m \to n\) the functions
    between finite sets \([m] \to [n]\).
\end{definition}

\begin{proposition}[\cite{lack2004composing}, Ex. 5.4]
    \label{prop:frob-finset}
    There is an isomorphism of PROPs \(\frob \cong \csp{\finsetprop}\).
\end{proposition}

We omit the formal proof and sketch the correspondence between the two
categories.
Terms in \(\frob\) are formed of all the ways of combining \(
    \iltikzfig{strings/structure/monoid/merge}[colour=white],
    \iltikzfig{strings/structure/monoid/init}[colour=white],
    \iltikzfig{strings/structure/comonoid/copy}[colour=white],
    \iltikzfig{strings/structure/comonoid/discard}[colour=white],
    \iltikzfig{strings/category/identity}[colour=white],
\) and \(
    \iltikzfig{strings/symmetric/symmetry}[colour=white]
\) in sequence and parallel, so a string diagram for a term \(\morph{f}{m}{n}\)
is depicted as \(x\) connected components drawing paths from \(m\) inputs to
\(n\) outputs, as illustrated with the example below.

\begin{center}
    \iltikzfig{strings/structure/frobenius/example}
\end{center}

Note there is no requirement for each component to connect to one or both
interfaces as the \(
    \iltikzfig{strings/structure/monoid/init}[colour=white]
\) and \(
    \iltikzfig{strings/structure/comonoid/discard}[colour=white]
\) generators can introduce and stub wires.
A term \(\morph{f}{m}{n}\) with \(x\) connected components corresponds to
a cospan of finite sets \(\cospan{[m]}[i]{[x]}[j]{[n]}\), where the functions
\(i\) and \(j\) map the inputs and outputs to the components they connect to.

\begin{example}
    Consider the term \(\morph{f}{5}{4}\) drawn on the left below.
    This corresponds to a cospan \(\cospan{[5]}{[3]}{[4]}\) as shown on the
    right below.
    \begin{center}
        \iltikzfig{strings/structure/frobenius/example}
        \(\Leftrightarrow\)
        \scalebox{0.75}{\tikzfig{strings/structure/frobenius/example-cospan}}
    \end{center}
\end{example}

The cospan representation shows how all connected Frobenius structures can be
`squished' into a single blob.

However, we are operating in a \emph{multi-sorted} setting, in which wires may
be different \emph{colours}.
This is easily remedied by having a copy of \(\frob\) for each colour.

\begin{theorem}[\cite{baez2018props}, Corollary 5.3]
    \(\prop\) has coproducts.
\end{theorem}

This easily generalises to \(\cprop\) by replacing natural numbers with words.
This means that given coloured PROPs \(\mcc\) and \(\mcd\) with objects the
words in \(\freemon{C}\) and \(\freemon{D}\) respectively, there is also a
coloured PROP \(\mcc + \mcd\) with objects the words in \(\freemon{(C + D)}\)
and morphisms defined in the obvious way.
We can use this to define a multi-coloured version of \(\frob\) as
a coproduct of copies of \(\frob\) each representing a separate colour.

\begin{definition}[\cite{bonchi2022string}]
    \label{def:coloured-frob}
    For a countable set of colours \(C\), let \(\cfrob{C} \in \cprop\) be
    defined as \(\cfrob{C} := \sum_{c \in C}\frob\).
\end{definition}

As shown by \cref{prop:frob-finset}, to model terms in \(\frob\) combinatorially
we use the cospan category \(\csp{\finsetprop}\).
In \cite{bonchi2022string} this is extended for a finite set of colours \(C\) by
working in the slice category \(\finsetprop \slice C\).
Objects of this category are pairs \(([m], \morph{w}{[m]}{C})\); this pair can
be viewed as a word in \(\freemon{C}\) of length \(m\), with the \(i\)th letter
as \(w(i)\).

\begin{theorem}[\cite{bonchi2022string}, Theorem 2.24]
    For a finite set of colours \(C \in \finsetprop\), there is an isomorphism
    of coloured PROPs \(\cfrob{C} \cong \csp{\finsetprop \slice C}\).
\end{theorem}
\begin{proof}
    The proof is very similar to \cref{thm:cfrobc-iso-hatfinsetprop-slice-c}
    below, so we omit it.
\end{proof}

We need to show a version of this for the case where \(C\) may be
\emph{countably infinite}.

\begin{notation}
    We say that a set \(C\) is \emph{countable} if it is finite or countably
    infinite, i.e.\ there is a bijection \(C \cong \nat\).
\end{notation}

\begin{definition}
    Let \(\hat{\finsetprop}\) be the category \(\finsetprop\) augmented with the
    set of natural numbers and the functions \([m] \to \nat\) for each finite
    set \([m]\).
\end{definition}

Note that we do not include the morphisms \(\nat \to [m]\) in the category
\(\hat{\finsetprop}\).
This is because when we view objects of \(\hat{\finsetprop} \slice C\) as words
in \(\freemon{C}\), we still only want to consider finite words despite there
being potentially countably infinite colours.

It is first necessary to show that \(\hat{\finset} \slice C\) is a coloured
PROP.
We recall a lemma of slice categories.

\begin{lemma}
    \label{lem:slice-coproducts}
    For a category \(\mcc\) with coproducts, \(\mcc \slice X\) has coproducts.
\end{lemma}
\begin{proof}
    Let \(A,B,X\) be objects in \(\mcc\); as \(\mcc\) has coproducts \(A + B\)
    is also an object in \(\mcc\).
    Then the coproduct of \((A, A \to X)\) and \((B, B \to X)\) in
    \(\mcc \slice X\) is \(A + B \to X\); the universal morphism is \([f, g]\).
\end{proof}

\begin{proposition}
    \label{prop:hatfinsetprop-slice-is-coloured-prop}
    For a countable set \(C\), \(\hat{\finsetprop} \slice C\) is a
    coloured PROP.
\end{proposition}
\begin{proof}
    This follows the same strategy as \cite[Prop. 2.23]{bonchi2022string}.
    As established, the objects of \(\hat{\finsetprop} \slice C\) can be viewed
    as words in \(\freemon{C}\).
    As slice categories preserve coproducts by \cref{lem:slice-coproducts},
    \(\hat{\finsetprop} \slice C\) is strict symmetric monoidal, and the
    coproduct acts as concatenation of words.
\end{proof}

We can now move towards showing an isomorphism \(
    \cfrob{C} \cong \csp{\hat{\finsetprop} \slice C}
\) for countable \(C\).

\begin{lemma}
    \label{lem:slice-iso-terminal}
    In a category \(\mcc\) with a terminal object \(1\),
    \(\mcc \cong \mcc \slice 1\).
\end{lemma}
\begin{proof}
    Since \(1\) is terminal, there is a unique morphism \(A \to 1\) for each
    object \(A\) in \(\mcc\), so there is an object \((A, A \to 1)\) in
    \(\mcc \slice 1\) for each object in \(\mcc\).
    There is a morphism \((A, \morph{!_A}{A}{1}) \to (B, \morph{!_B}{B}{1})\) in
    \(\mcc \slice 1\) for every morphism \(\morph{f}{A}{B}\) in \(\mcc\) such
    that \(f \seq !_B = !_A\); since both \(f \seq !_B\) and \(!_A\) are
    morphisms \(A \to 1\) this condition holds for any morphism \(f\) in
    \(\mcc\).
    Therefore \(\mcc \cong \mcc \slice 1\).
\end{proof}

The strategy for this proof is much the same as that used in
\cite{bonchi2022string} for the finite case, but relies on one small
observation.

\begin{lemma}
    \label{lem:finsetprop-finite}
    Let \(C \in \finsetprop\) be a finite cardinal.
    Then \(\hat{\finsetprop} \slice C \cong \finsetprop \slice C\).
\end{lemma}
\begin{proof}
    The morphisms in \(\hat{\finsetprop} \slice C\) are the morphisms
    \([m] \to C\) for finite \(C\), which are precisely the morphisms of
    \(\finsetprop \slice C\).
\end{proof}

\begin{theorem}
    \label{thm:cfrobc-iso-hatfinsetprop-slice-c}
    For a countable set of sorts \(C\), there is an isomorphism of coloured
    PROPs \(\cfrob{C} \cong \csp{\hat{\finsetprop} \slice C}\).
\end{theorem}
\begin{proof}
    The proof is similar to \cite[Thm. 2.24]{bonchi2022string}.
    By definition of \(\cfrob{C}\),
    \cref{def:coloured-frob,prop:frob-finset,lem:slice-iso-terminal,lem:finsetprop-finite}
    we have that \[
        \cfrob{C}
        :=
        \sum_{c \in C}\frob
        \cong
        \sum_{c \in C}\csp{\finsetprop}
        \cong
        \sum_{c \in C}\csp{\finsetprop \slice 1}
        \cong
        \sum_{c \in C}\csp{\hat{\finsetprop} \slice 1}.
    \]
    In the other direction we have that \(
        \csp{\hat{\finsetprop} \slice C}
        \cong
        \csp{\hat{\finsetprop} \slice \sum_{c \in C} 1}
    \) as \(C\) is countable.
    So we need to show that \(
        \sum_{c \in C}\csp{\hat{\finsetprop} \slice 1}
        \cong
        \csp{\hat{\finsetprop} \slice \sum_{c \in C} 1}
    \).
    The objects of the former are coproducts of objects in
    \(\hat{\finsetprop} \slice C\); as this is a coloured prop the coproduct is
    concatenation and subsequently the objects can be viewed as words in
    \(\freemon{C}\).
    Similarly, the objects of the latter are objects of
    \(\hat{\finsetprop} \slice \sum_{c \in C} 1\), which can clearly also be
    seen as words in \(\freemon{C}\).

    The morphisms of the former are coproducts of cospans, which can
    equivalently be viewed as a single cospan with coproducts in the legs and
    apex; using the reasoning above this means it is a cospan of words in
    \(\freemon{C}\); it is easy to see that this is also the case for morphisms
    in the latter.
\end{proof}


\begin{corollary}[\cite{bonchi2022string}, Cor. 3.9]
    There is a faithful PROP homomorphism
    \(\morph{\tilde{D_\mcs}}{\csp{\finsetprop}}{\cspdhyp}\)
\end{corollary}

\begin{definition}[\cite{bonchi2022string}]
    Let \(\mcs\) be a set of sorts, and let
    \(\morph{D}{\hat{\finsetprop} \slice \mcs}{\hypsigma}\) be the faithful,
    coproduct-preserving functor that sends each word
    \(\listvar{x} \in \hat{\finsetprop}\) to the discrete hypergraph
    \(m \in \hypsigma\) and each morphism to the induced homomorphism of
    discrete hypergraphs.
\end{definition}

\todo[inline]{Adapt from FSCD paper section 2}

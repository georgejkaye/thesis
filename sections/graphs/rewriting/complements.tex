\section{Pushout complements}

With any luck, the reader should now have a good grasp on how DPO rewriting
works; find a matching, compute the pushout complement, and perform one more
pushout to complete the rewrite.
While the final step is a deterministic procedure, finding the pushout
complement is a little more hazy.
Since the pushout complement uniquely defines the final rewrite, one might be
cautious about how we choose it.

First of all, a pushout complement may not even exist for arbitrary morphisms
\(i+j \to L \to G\).

\begin{definition}
    A morphism \(i+j \to L \to G\) is called a \emph{matching} if it
    has at least one pushout complement.
\end{definition}

If there is no pushout complement, there is no possible rewrite, so it is fairly
essential to know when one exists!
Fortunately, these conditions are well-known.

\begin{definition}[No-dangling-hyperedges condition~\cite{corradini1997algebraic}, Prop. 3.3.4]
    Given morphisms \(i+j \xrightarrow{a} L \xrightarrow{f} G\) in
    \(\hypsigma\), they satisfy the \emph{no-dangling} condition if, for every
    hyperedge not in
    the image of \(f\), each of its source and target vertices is either not in
    the image of \(f\) or are in the image of \(f \circ a\).
\end{definition}

\begin{example}
    The following pair of morphisms does not satisfy the no-dangling-hyperedges
    condition.
    \[
        \iltikzfig{graphs/dpo/no-dangling/k}
        \xrightarrow{a}
        \iltikzfig{graphs/dpo/no-dangling/l}
        \xrightarrow{f}
        \iltikzfig{graphs/dpo/no-dangling/g}
    \]
    To obtain the pushout complement we `cut out' any vertices in the
    rightmost graph which are in the image of \(f\) but not the image of
    \(f \circ a\), as the latter are the interfaces of the rule.
    However, if we cut out the vertices labelled \(2\) and \(3\), the edge
    \(e_2\) will be left with `dangling' tentacles connected to no vertices, a
    malformed hypergraph.
    \begin{center}
        \begin{tikzcd}
            \iltikzfig{graphs/dpo/no-dangling/l}
            \arrow{d}{f}
            &
            \iltikzfig{graphs/dpo/no-dangling/k}
            \arrow{l}{a}
            \arrow{d}
            \\
            \iltikzfig{graphs/dpo/no-dangling/g}
            &
            \iltikzfig{graphs/dpo/no-dangling/c}
            \arrow{l}
        \end{tikzcd}
    \end{center}
\end{example}

\begin{definition}[No-identification condition~\cite{corradini1997algebraic}, Prop. 3.3.4]
    Given morphisms \(i+j \xrightarrow{a} L \xrightarrow{f} G\) in
    \(\hypsigma\), they satisfy the \emph{no-identification} condition if any
    two distinct elements merged by \(f\) are also in the image of \(f \circ a\).
\end{definition}

\begin{example}
    The following pair of morphisms does not satisfy the no-identification
    condition.
    \[
        \iltikzfig{graphs/dpo/no-identification/k}
        \xrightarrow{a}
        \iltikzfig{graphs/dpo/no-identification/l}
        \xrightarrow{f}
        \iltikzfig{graphs/dpo/no-identification/g}
    \]
    When trying to construct a pushout complement, the edge \(e_2\) will be
    removed.
    However, since vertices \(2\) and \(3\) are not mapped from the rule
    interfaces, there is no reason that a pushout would glue them together so
    that they are merged in the final graph.
    Therefore no pushout complement can exist.
    \begin{center}
        \begin{tikzcd}
            \iltikzfig{graphs/dpo/no-identification/l}
            \arrow{d}{f}
            &
            \iltikzfig{graphs/dpo/no-identification/k}
            \arrow{l}{a}
            \arrow{d}
            \\
            \iltikzfig{graphs/dpo/no-identification/g}
            &
            \iltikzfig{graphs/dpo/no-identification/c}
            \arrow{l}
        \end{tikzcd}
    \end{center}
\end{example}

With these two conditions, we can establish when pushout complements exist at
all and subsequently when there is an opportunity for a rewrite.

\begin{proposition}[\cite{corradini1997algebraic}, Prop. 3.3.4]
    \label{prop:pushout-complement}
    The morphisms \(i+j \to L \to G\) have at least one pushout
    complement if and only if they satisfy the no-dangling and no-identification
    conditions.
\end{proposition}

It is all very well knowing if there is at least one pushout complement, but
what about when there is \emph{exactly one} pushout complement?
When this is the case, the rewrite is uniquely specified for a given rule and
matching.

To answer this question, we must examine a class of categories to which
\(\hypsigmac\) belongs to, known as \emph{adhesive} categories.
One can think of these as categories in which graph rewriting `plays nicely'.

\begin{definition}[van Kampen square~(\cite{lack2005adhesive}, Def. 2.1)]
    Let there be a commutative cube as drawn below.
    \begin{center}
        \begin{tikzcd}
            G \arrow{rrr} \arrow{ddd} &
            &
            &
            H \arrow{ddd} \\
            &
            E \arrow{ul} \arrow{r} \arrow{d} &
            F \arrow{ur} \arrow{d} &
            \\
            &
            A \arrow{dl} \arrow{r} &
            B \arrow{dr} &
            \\
            C \arrow{rrr} &
            &
            &
            D
        \end{tikzcd}
    \end{center}
    The bottom face of the cube (\(ABCD\)) is called a
    \emph{van Kampen (VK) square} if it is a pushout and, when the back and
    left faces (\(EFAB\) and \(GECA\)) are pullbacks, the front and right faces
    (\(GHCD\) and \(FHBD\)) are pullbacks if and only if the top face (\(GHEF\))
    is a pushout.
\end{definition}

\begin{definition}
    Given a span \(\spann{A}[f]{B}[g]{C}\) with a pushout \(\cospan{B}{D}{C}\),
    the pushout is called a \emph{pushout along a monomorphism} if \(f\) or
    \(g\) is a monomorphism.
\end{definition}

\begin{definition}[Adhesive category~(\cite{lack2005adhesive}, Def. 3.1)]
    A category \(\mcc\) is \emph{adhesive} if
    \begin{itemize}
        \item \(\mcc\) has pushouts along monomorphisms;
        \item \(\mcc\) has pullbacks; and
        \item pushouts along monomorphisms are VK squares.
    \end{itemize}
\end{definition}

The definition of van Kampen square and subsequently adhesive categories may
look a bit confusing to the uninitiated; indeed, there are arrows flying about
all over the place!
At a high level, an adhesive category is one in which one in which objects can
be `split apart' and `glued together' by using pushouts and pullbacks.

\begin{example}
    A natural example of an adhesive category is \(\set\), which has pushouts
    and pullbacks.
    To get some idea how the van Kampen condition also holds, consider the
    following commutative cube in \(\set\), adapted from
    \cite[Sec. 4.3]{kissinger2012pictures}.
    \begin{center}
        \begin{tikzcd}
            A^\prime
            \arrow{rrr}
            \arrow{ddd}{f_A}
            &
            &
            &
            X
            \arrow{ddd}{f}
            \\
            &
            A^\prime \cap B^\prime
            \arrow{r}
            \arrow{d}
            \arrow{ul}
            &
            B^\prime
            \arrow{ur}
            \arrow{d}{f_B}
            &
            \\
            &
            A \cap B
            \arrow{r}
            \arrow{dl}
            &
            B
            \arrow{dr}
            &
            \\
            A
            \arrow{rrr}
            &
            &
            &
            A \cup B
        \end{tikzcd}
    \end{center}
    The bottom face is clearly a pushout, and since \(A \cup B \to A\) and
    \(A \cup B \to B\) are monomorphisms, this is a pushout along a
    monomorphism.
    Furthermore, the left and back faces are pullbacks because \(f_A\) and
    \(f_B\) agree on the intersection of \(A^\prime\) and \(B^\prime\).

    Now we must show that the front and right faces are pullbacks if and only if
    the top face is a pushout.
    For the front and right faces to be pullbacks, \(f\) must restrict to
    \(f_A\) and \(f_B\) along \(A\) and \(B\).
    This can only be the case if and only if \(X = A^\prime \cap B^\prime\), in
    which case the top square must be a pushout.
\end{example}

Regardless of intuition, proving the necessary van Kampen condition might be
tricky.
Fortunately, adhesivity is preserved by several categorical constructions, so
by using \(\set\) as a base it is straightforward to show that more complicated
categories are also adhesive.

\begin{proposition}[\cite{lack2005adhesive}, Prop. 3.5]
    For an adhesive category \(\mcc\) and object \(C\) of \(\mcc\),
    \(\mcc \slice C\) is adhesive.
    For another category \(\mcx\), \([\mcx, \mcc]\) is also adhesive.
\end{proposition}

\begin{corollary}
    \(\hypsigma\) and \(\hypsigmac\) are adhesive.
\end{corollary}
\begin{proof}
    \(\hypsigma\) and \(\hypsigmac\) are defined as the slice of a functor
    category over \(\set\), so they are adhesive.
\end{proof}

The notion of splitting and gluing is very useful when it comes to graph
rewriting, as it corresponds to how we extract and insert various subgraphs
during the rewriting process.
In particular, for certain DPO rules in an adhesive category a pushout
complement is \emph{uniquely} defined for a given matching.

\begin{definition}[Left-linear rules]
    A DPO rule \(\spann{L}[f]{i+j}{R}\) is called \emph{left-linear} if \(f\)
    is mono.
\end{definition}

\begin{theorem}[\cite{lack2005adhesive}, Lem. 4.5]
    In an adhesive category, if a pushout complement exists for morphisms
    \(I \xrightarrow{m} L \to G\) and \(m\) is a monomorphism, then it is unique
    up to isomorphism.
\end{theorem}
\begin{proof}
    The proof relies on several non-trivial lemmas that hold in adhesive
    categories in addition to some other results about pushouts.
    We refer the interested reader to
    \cite[Lems. 4.3.6 - 4.3.9]{kissinger2012pictures} for the grisly details.
\end{proof}

This means that, for a large class of rewrite rules, if we find a matching we
can be sure that rewriting is defined uniquely.
However, there may be useful rewrite rules which are \emph{not} left-linear.

\begin{example}
    \todo[inline]{Do classic non left-linear example}
\end{example}

One might think this is undesirable, as surely for a rule and matching we would
want a unique rewrite?
However, we must not forget that hypergraphs model terms
\emph{modulo Frobenius structure}.
The multiple rewrites are not coming from nowhere, but arise because there are
`hidden' rewriting opportunities thanks to the Frobenius algebras!

\begin{example}
    \todo[inline]{Show how the above contexts correspond to term rewrite}
\end{example}

Even if every rewrite is `correct' in some way, there is still the question of
how to find the `desired' rewrite.
Fortunately, for hypergraphs this problem has already been
tackled~\cite{heumuller2011construction}; the pushout complements can be
enumerated as quotients of an `exploded' context.

\begin{definition}[Exploded context~(\cite{heumuller2011construction}, Const. 1)]
    Let \(i+j \to L \xrightarrow{f} G\) be a pair of morphisms in
    \(\hypsigma\).
    Then the \emph{exploded context} for these morphisms is a graph
    \(\listvar{ij} + \tilde{G}\) where \(\tilde{G}\) is constructed as follows:
    \begin{enumerate}
        \item for each vertex \(v \in G\) not in the image of \(f\), add one
              vertex to \(\tilde{G}\);
        \item for each hyperedge \(e \in G\) not in the image of \(f\), add one
              hyperedge to \(\tilde{G}\);
        \item for each hyperedge \(e \in \tilde{G}\), let the \(i\)-th source
              \(\tilde{s_i}(e)\) be defined as \(s_i(h)\) if
              \(s_i(h) \in \tilde{G}\) or a new, fresh vertex otherwise;
        \item repeat the above for the targets.
    \end{enumerate}
\end{definition}

Pushout complements can then be computed as quotients of this exploded
context.

\begin{proposition}[\cite{heumuller2011construction} (Props. 3-4), \cite{bonchi2022string}]
    For morphisms \(i+j \to L \to G\) in \(\hypsigma\), let
    \(i + j + \tilde{G}\) be its `exploded' context, and define a map
    \(\morph{q}{i + j + \tilde{G}}{G}\) sending elements in \(\tilde{G}\)
    that came from \(G\) to themselves, and sending vertices from
    \(i + j\) to their image under \(i + j \to L \to G\).
    A pushout complement \(i + j \to C \to G\) is valid if and only
    \(C\) is obtained as a quotient on the exploded context
    that only identifies vertices in the image of \(q^{-1}(v)\) for each vertex
    \(v \in G\).
\end{proposition}

So this means that given a DPO rule and an incidence of this rule inside a
larger graph such that the no-dangling and no-identification conditions are
satisfied, we can enumerate all the possible pushout complements.
It can be shown that each of these pushout complements correspond to a valid
rewrite in a Frobenius setting!

\begin{notation}
    Given a rewrite rule \(
    \rrule{
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    }{
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    }
    \), its interpretation as a DPO rule is written as \(
    \termandfrobtohypsigma[
        \rrule{
            \iltikzfig{strings/category/f}[box=l,colour=white]
        }{
            \iltikzfig{strings/category/f}[box=r,colour=white]
        }
    ]
    \coloneqq
    \spann{
        \termandfrobtohypsigma[
            \foldinterfaces[
                \iltikzfig{strings/category/f}[box=l,colour=white]
            ]
        ]
    }{\listvar{ij}}{
        \termandfrobtohypsigma[
            \foldinterfaces[
                \iltikzfig{strings/category/f}[box=r,colour=white]
            ]
        ]
    }
    \).
\end{notation}

\begin{theorem}[\cite{bonchi2022string}, Thm. 4.9]
    For a rewrite rule \(\rrule{
        \iltikzfig{strings/category/f}[box=l,colour=white]
    }{
        \iltikzfig{strings/category/f}[box=r,colour=white]
    }\) in \(
    \smcsigma + \frob
    \), \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    \rewrite[\rrule{
            \iltikzfig{strings/category/f}[box=l,colour=white]
        }{
            \iltikzfig{strings/category/f}[box=r,colour=white]
        }]
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \) if and only if \(
    \termandfrobtohypsigma[
        \foldinterfaces[
            \iltikzfig{strings/category/f}[box=g,colour=white]
        ]
    ]
    \grewrite[
        \termandfrobtohypsigma[
            \rrule{
                \iltikzfig{strings/category/f}[box=l,colour=white]
            }{
                \iltikzfig{strings/category/f}[box=r,colour=white]
            }
        ]
    ]
    \termandfrobtohypsigma[
        \foldinterfaces[
            \iltikzfig{strings/category/f}[box=g,colour=white]
        ]
    ]\).
\end{theorem}

\subsection{Multicoloured rewriting}

The results generalise in the obvious way to the coloured setting.

\begin{notation}
    Given a rewrite rule \(
    \rrule{
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=\listvar{i},cod=\listvar{j}]
    }{
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=\listvar{i},cod=\listvar{j}]
    }
    \) in \(\smcsigmac + \frobc\), its interpretation as a DPO rule is written
    as \(
    \termandfrobtohypsigmac[
        \rrule{
            \iltikzfig{strings/category/f}[box=l,colour=white]
        }{
            \iltikzfig{strings/category/f}[box=r,colour=white]
        }
    ]
    \coloneqq
    \spann{
        \termandfrobtohypsigmac[
            \foldinterfacesc[
                \iltikzfig{strings/category/f}[box=l,colour=white]
            ]
        ]
    }{\listvar{ij}}{
        \termandfrobtohypsigmac[
            \foldinterfacesc[
                \iltikzfig{strings/category/f}[box=r,colour=white]
            ]
        ]
    }
    \).
\end{notation}

\begin{definition}[\cite{bonchi2022string}]
    Let \(\morph{\foldinterfacesc}{\smcsigmac + \frobc}{\smcsigmac + \frobc}\)
    be defined as having action \(
    \iltikzfig{strings/category/f}[box=f,colour=white,dom=\listvar{m},cod=\listvar{n}]
    \mapsto
    \iltikzfig{strings/rewriting/folding}[box=f,colour=white,dom=\listvar{m},cod=\listvar{n}]
    \).
\end{definition}

\begin{theorem}[\cite{bonchi2022string}, Prop. 4.10]
    For a rule \(\rrule{
        \iltikzfig{strings/category/f}[box=l,colour=white]
    }{
        \iltikzfig{strings/category/f}[box=r,colour=white]
    }\) in \(
    \smcsigmac + \frobc
    \), \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    \rewrite[\rrule{
            \iltikzfig{strings/category/f}[box=l,colour=white]
        }{
            \iltikzfig{strings/category/f}[box=r,colour=white]
        }]
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \) if and only if \(
    \termandfrobtohypsigmac[
        \foldinterfacesc[
            \iltikzfig{strings/category/f}[box=g,colour=white]
        ]
    ]
    \grewrite[
        \termandfrobtohypsigmac[
            \rrule{
                \iltikzfig{strings/category/f}[box=l,colour=white]
            }{
                \iltikzfig{strings/category/f}[box=r,colour=white]
            }
        ]
    ]
    \termandfrobtohypsigmac[
        \foldinterfacesc[
            \iltikzfig{strings/category/f}[box=g,colour=white]
        ]
    ]\).
\end{theorem}
\section{Double pushout rewriting}

As a backdrop, let us first consider how equations in a monoidal theory are
applied to terms without any sort of special graph interpretation.

\begin{definition}[Rewriting system]\label{def:term-rewriting}
    A \emph{rewriting system} \(\mcr\) for a traced PROP \(\mathbb{A}\)
    consists of a set of \emph{rewrite rules} \(
    \rrule{
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    }{
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    }
    \).
    Given terms \(
    \iltikzfig{strings/category/f}[box=g,colour=white,dom=m,cod=n]
    \) and \(
    \iltikzfig{strings/category/f}[box=h,colour=white,dom=m,cod=n]
    \) in \(\stmcsigma\) we write \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    \rewrite[\mcr]
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \) if there exists rewrite rule \(\rrule{
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    }{
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    }\) in \(\mcr\) and \(
    \iltikzfig{strings/category/f-2-2}[box=c,colour=white,dom1=j,dom2=m,cod1=i,cod2=n]
    \) in \(\stmcsigma\) such that \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    =
    \iltikzfig{strings/rewriting/rewrite-l}
    \) and \(
    \iltikzfig{strings/category/f}[box=h,colour=white]
    =
    \iltikzfig{strings/rewriting/rewrite-r}
    \) by axioms of STMCs.
\end{definition}

The difference between a rewriting system and an equational theory is that in
the former the rules are \emph{directed} whereas equations are not.
Of course, it is straightforward to derive a rewriting system from an equational
theory by adding the reductions for `both ways' of each equation.

\begin{definition}[\cite{bonchi2022stringa}, Sec. 2.4]
    Given a monoidal theory \((\generators,\equations)\), let
    \(\mcr_{\equations}\) be the rewriting theory defined as \(\{
    \rrule{
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    }{
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    }
    \,|\,
    \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    =
    \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    \in
    \mce
    \} \cup \{
    \rrule{
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    }{
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    }
    \,|\,
    \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    =
    \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    \in
    \mce
    \}\).
\end{definition}

\begin{proposition}[\cite{bonchi2022stringa}, Prop. 2.18]
    Given two terms \(
    \iltikzfig{strings/category/f}[box=g,colour=white],
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \in \stmc{\generators,\equations}
    \), \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    =
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \) if and only if \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    \rewrites[\mcr_{\equations}]
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \).
\end{proposition}

The equivalent for graphs is, unsurprisingly, \emph{graph rewriting}.
There has been a wealth of research into various graph rewriting techniques;
we use one known as \emph{double pushout (DPO)} rewriting.
DPO was introduced in the early 70s by Ehrig, Pfender, and
Schneider~\cite{ehrig1973graphgrammars} as one of the first \emph{algebraic}
approaches to graph rewriting.
Although first defined in the category of graphs, it has since been generalised
to encompass a variety of combinatorial structures; later on we will see the
precise categorical properties required for DPO rewriting to be well-defined.
Since we are working with hypergraphs we will present the definitions in terms
of hypergraphs, but one can see how they could be adapted in terms of other
structures.

The core element of a DPO rewriting system is a \emph{DPO rule}, which specifies
a possible rewrite as a span of hypergraphs.

\begin{definition}[DPO rule]\label{def:dpo-rule}
    Given interfaced hypergraphs \(
    \cospan{i}[a_1]{L}[a_2]{j}
    \) and \(
    \cospan{i}[b_1]{R}[b_2]{j}
    \) in \(\cspdhyp\), their \emph{DPO rule} is a span in \(\hypsigma\)
    defined as \(
    \spann{L}[[a_1,a_2]]{i + j}[[b_1,b_2]]{R}
    \).
\end{definition}

Note that the DPO rule is a span in the category of hypergraphs \(\hypsigma\),
\emph{not} the category of interfaced hypergraphs \(\cspdhyp\)!
This is because identifying the occurrence of a DPO rule in some larger
hypergraph will be performed using a \emph{hypergraph homomorphism}.

Although we could press on now and define `normal' DPO rewriting, we will
actually use an extension, known as
\emph{double pushout rewriting with interfaces}
(DPOI rewriting)~\cite{bonchi2017confluence}.
This framework enjoys the \emph{Knuth-Bendix property}~\cite{knuth1970simple};
graph rewriting is confluent when all \emph{critical pairs are joinable}.
Put more simply, this means that a rewriting system is confluent if, whenever
there is an overlap of rules such that \(G \grewrite H\) and
\(G \grewrite H^\prime\), then there exists another graph \(K\) such that
\(H \grewrites K\) and \(H^\prime \grewrites K\).

\begin{definition}[DPOI rewriting]\label{def:dpo-rewriting}
    Let \(\mcr\) be a set of DPO rules.
    Then, for morphisms \(G \leftarrow m + n\) and
    \(H \leftarrow m + n\) in
    \(\hypsigmac\), there is a rewrite \(G \trgrewrite[\mcr] H\) if there
    exist a rule \(
    \spann{L}{i + j}{R} \in \mcr
    \) and cospan \(
    \cospan{i + j}{C}{m + n} \in \hypsigma
    \) such that the following diagram commutes.
    \begin{center}
        \begin{tikzcd}[row sep = small, column sep = small]
            L \arrow{d}
            & i + j \arrow{l}\arrow{r}\arrow{d}
            & R \arrow{d} \\
            G \arrow["\urcorner"{anchor=center, pos=0.125}, draw=none]{ur}
            & C \arrow{l}\arrow{r}
            & H \arrow["\ulcorner"{anchor=center, pos=0.125}, draw=none]{ul} \\
            & m + n \arrow{ul}\arrow{u}\arrow{ur}
        \end{tikzcd}
    \end{center}
\end{definition}

The DPO diagram above may look a little intimidating a first glance, so we will
break it down and describe what happens during a typical graph rewrite.
The first thing to note is that the graphs all have a \emph{single} interface
\(G \leftarrow m + n\) rather than the cospans
\(\cospan{m}{G}{n}\) we are used to.
This means that to perform graph rewriting on graphs in \(\hypsigma\),
interfaces of terms in \(\smcsigma + \frob\) must be `folded' into one using
the compact closed structure.

\begin{definition}[\cite{bonchi2022stringa}]\label{def:fold-interfaces}
    Let \(\morph{\foldinterfaces}{\smcsigma + \frob}{\smcsigma + \frob}\)
    be defined as having action \(
    \iltikzfig{strings/category/f}[box=f,colour=white,dom=m,cod=n]
    \mapsto
    \iltikzfig{strings/rewriting/folding}[box=f,colour=white,dom=m,cod=n]
    \).
\end{definition}

The image of \(\foldinterfaces\) is not in the image of
\(\tracedtosymandfrobsigma\) or \(\tracedandcomonoidtofrobsigma\) any more,
as inputs of generators may now connect to outputs of the term.
Fortunately this is not an issue, as long as we `unfold' the interfaces once
rewriting is completed.

\begin{proposition}[\cite{bonchi2022string}, Prop. 4.8]
    If \(
    \termandfrobtohypsigma[\iltikzfig{strings/category/f}[box=f,colour=white,dom=m,cod=n]]
    =
    \cospan{m}[i]{F}[o]{n}
    \) then \(
    \termandfrobtohypsigma[
        \foldinterfaces[
            \iltikzfig{strings/category/f}[box=f,colour=white]
        ]
    ]
    \) is isomorphic to \(
    \cospan{0}[]{F}[i+o]{m + n}
    \).
\end{proposition}
\begin{proof}
    Straightforward by definition of the cup using the Frobenius structure.
\end{proof}

We are now ready to begin rewriting.
Say we have a DPO rule \(\spann{L}{i + j}{R}\) and a larger cospan of
hypergraphs \(\cospan{m}{G}{n}\).
We suggestively assemble them as follows:

\begin{center}
    \begin{tikzcd}[row sep = small, column sep = small]
        L
        & i+j \arrow{l}\arrow{r}
        & R \\
        G
        &
        & \\
        & m+n \arrow{ul}
    \end{tikzcd}
\end{center}

As mentioned above, to identify an occurrence of \(L\) in \(G\), we use a
hypergraph homomorphism \(L \to G\) to identify the components that will be
rewritten.

\begin{center}
    \begin{tikzcd}[row sep = small, column sep = small]
        L \arrow{d}
        & \listvar{ij} \arrow{l}\arrow{r}
        & R \\
        G
        &
        & \\
        & m+n \arrow{ul}
    \end{tikzcd}
\end{center}

We now need to identify the \emph{context} in which the rewrite will occur in.
Essentially, the context is the `graph \(G\) with \(L\) cut out', which can be
formally defined with what is known as a \emph{pushout complement}, a sort of
`reverse pushout'.

\begin{definition}[Pushout complement]\label{def:pushout-complement}
    Let \(i+j \to L \to G \leftarrow m+n\) be morphisms in
    \(\hypsigmac\); their \emph{pushout complement} is an object \(C\)
    with morphisms \(i+j \to C \to G\) such that \(\cospan{L}{G}{C}\) is a
    pushout and the diagram below commutes.
    \begin{center}
        \begin{tikzcd}[column sep=large]
            L \arrow[swap]{d}{f}
            &
            ij
            \arrow[swap]{l}{a \coloneqq [a_1, a_2]}
            \arrow{d}{c \coloneqq [c_1, c_2]}
            \\
            G
            \arrow["\urcorner"{anchor=center, pos=0.125}, draw=none]{ur}
            &
            C
            \arrow{l}{g}
            \\
            &
            m+n
            \arrow{ul}{[b_1,b_2]}
            \arrow[swap]{u}{d \coloneqq [d_1,d_2]}
        \end{tikzcd}
    \end{center}
\end{definition}

Is a pushout complement always guaranteed to exist for any morphism \(L \to G\)?
The answer is no; this will be discussed at length in the next section.

If a pushout complement does exist, it specifies the rewriting context.
This leaves us a hole in which the other side of the rewrite rule can be glued
in.

\begin{center}
    \begin{tikzcd}[row sep = small, column sep = small]
        L \arrow{d}
        & i+j \arrow{l}\arrow{r}\arrow{d}
        & R \\
        G \arrow["\urcorner"{anchor=center, pos=0.125}, draw=none]{ur}
        & C \arrow{l}
        & \\
        & m+n \arrow{ul}\arrow{u}
    \end{tikzcd}
\end{center}

To actually compute the rewritten graph, we perform another pushout to retrieve
the complete DPO diagram.

\begin{center}
    \begin{tikzcd}[row sep = small, column sep = small]
        L \arrow{d}
        & i+j \arrow{l}\arrow{r}\arrow{d}
        & R \arrow{d} \\
        G \arrow["\urcorner"{anchor=center, pos=0.125}, draw=none]{ur}
        & C \arrow{l}\arrow{r}
        & H \arrow["\ulcorner"{anchor=center, pos=0.125}, draw=none]{ul} \\
        & m+n \arrow{ul}\arrow{u}\arrow{ur}
    \end{tikzcd}
\end{center}

\begin{example}
    \todo[inline]{Do a concrete example}
\end{example}
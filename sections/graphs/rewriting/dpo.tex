% !TeX root = ../../../main.tex
\section{Double pushout rewriting}

Let us first consider how equations in a monoidal theory are
applied to terms without any sort of special graph interpretation.

\begin{definition}[Rewriting system]\label{def:term-rewriting}
    A \emph{rewriting system} \(\mcr\) for a traced PROP \(\mcc\)
    consists of a set of \emph{rewrite rules} \(
    \rrule{
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    }{
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    }
    \).
    Given terms \(
    \iltikzfig{strings/category/f}[box=g,colour=white,dom=m,cod=n]
    \) and \(
    \iltikzfig{strings/category/f}[box=h,colour=white,dom=m,cod=n]
    \) in \(\stmcsigma\) we write \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    \rewrite[\mcr]
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \) if there exists rewrite rule \(\rrule{
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    }{
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    }\) in \(\mcr\) and \(
    \iltikzfig{strings/category/f-2-2}[box=c,colour=white,dom1=j,dom2=m,cod1=i,cod2=n]
    \) in \(\stmcsigma\) such that \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    =
    \iltikzfig{strings/rewriting/rewrite-l}
    \) and \(
    \iltikzfig{strings/category/f}[box=h,colour=white]
    =
    \iltikzfig{strings/rewriting/rewrite-r}
    \) by axioms of STMCs.
    We write \(
    \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
    \rewrites[\mcr]
    \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
    \) if there is a sequence of such rules.
\end{definition}

The difference between a rewriting system and an equational theory is that in
the former the rules are \emph{directed} whereas equations are not.
Of course, it is straightforward to derive a rewriting system from an equational
theory by adding the reductions for both directions of each equation.

\begin{definition}[\cite{bonchi2022stringa}, Sec. 2.4]
    For a monoidal theory \((\generators,\equations)\), let
    \(\mcr_{\equations}\) be the rewriting system defined as
    \begin{gather*}\{
        \rrule{
            \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
        }{
            \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
        }
        \,|\,
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
        =
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
        \in
        \mce
        \} \cup \{
        \rrule{
            \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
        }{
            \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
        }
        \,|\,
        \iltikzfig{strings/category/f}[box=l,colour=white,dom=i,cod=j]
        =
        \iltikzfig{strings/category/f}[box=r,colour=white,dom=i,cod=j]
        \in
        \mce
        \}.
    \end{gather*}
\end{definition}

\begin{proposition}[\cite{bonchi2022stringa}, Prop.\ 2.18]
    Given two terms \(
    \iltikzfig{strings/category/f}[box=g,colour=white],
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \in \stmc{\generators,\equations}
    \), \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    =
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \) if and only if \(
    \iltikzfig{strings/category/f}[box=g,colour=white]
    \rewrites[\mcr_{\equations}]
    \iltikzfig{strings/category/f}[box=h,colour=white]
    \).
\end{proposition}

The equivalent for graphs is, unsurprisingly, \emph{graph rewriting}.
While there are many graph rewriting techniques, we use one known as
\emph{double pushout (DPO)} rewriting, which was introduced in the early 70s by
Ehrig, Pfender, and Schneider~\cite{ehrig1973graphgrammars} as one of the first
\emph{algebraic} approaches to graph rewriting.
Although first defined in the category of graphs, it has since been generalised
to encompass a variety of combinatorial structures.
We will later see the precise categorical properties required for DPO rewriting
to be well-defined, but first we will define the procedure in terms of
hypergraphs.

A double pushout rewrite rule is defined by mapping to the left and right hand
side of a rule from their shared interface.

\begin{definition}
    A \emph{span} is a pair of morphisms \(A \to B\) and \(A \to C\), usually
    written \(\spann{B}{A}{C}\).
\end{definition}

\begin{definition}[DPO rule]\label{def:dpo-rule}
    Given two interfaced hypergraphs \(
    \cospan{i}[a_1]{L}[a_2]{j}
    \) and \(
    \cospan{i}[b_1]{R}[b_2]{j}
    \) in \(\cspdhyp\), their corresponding \emph{DPO rule} is a span in \(\hypsigma\)
    defined as \(
    \spann{L}[[a_1,a_2]]{i + j}[[b_1,b_2]]{R}
    \).
\end{definition}

A DPO rule is a span in the category of hypergraphs \(\hypsigma\),
rather than the category of interfaced hypergraphs \(\cspdhyp\).
This is because identifying the occurrence of a DPO rule in a larger graph will
be performed using a hypergraph homomorphism.

We will actually use an extension of traditional DPO rewriting, known as
\emph{double pushout rewriting with interfaces}
(DPOI rewriting)~\cite{bonchi2017confluence}.
This framework enjoys the \emph{Knuth-Bendix property}~\cite{knuth1970simple};
graph rewriting is confluent when all \emph{critical pairs are joinable}.
Put more simply, this means that a rewriting system is confluent if, whenever
there is an overlap of rules in a graph \(G\) such that \(G\) could rewrite to
\(H\) or \(H^\prime\), there exists another graph \(K\) and series of rewrites
such that both \(H\) and \(H^\prime\) rewrite to \(K\).

\begin{definition}[DPOI rewriting]\label{def:dpo-rewriting}
    Let \(\mcr\) be a set of DPO rules.
    Then, for morphisms \(G \leftarrow m + n\) and
    \(H \leftarrow m + n\) in
    \(\hypsigmac\), there is a rewrite \(G \trgrewrite[\mcr] H\) if there
    exist a span \(
    \spann{L}{i + j}{R} \in \mcr
    \) and cospan \(
    \cospan{i + j}{C}{m + n} \in \hypsigma
    \) such that the following diagram commutes.
    \begin{center}
        \begin{tikzcd}[row sep = small, column sep = small]
            L \arrow{d}
            & i + j \arrow{l}\arrow{r}\arrow{d}
            & R \arrow{d} \\
            G \arrow["\urcorner"{anchor=center, pos=0.125}, draw=none]{ur}
            & C \arrow{l}\arrow{r}
            & H \arrow["\ulcorner"{anchor=center, pos=0.125}, draw=none]{ul} \\
            & m + n \arrow{ul}\arrow{u}\arrow{ur}
        \end{tikzcd}
    \end{center}
\end{definition}

The DPO diagram above may look intimidating at first glance, so we will
break it down and describe what happens during a typical graph rewrite.
The first thing to note is that the graphs all have a \emph{single} interface
\(G \leftarrow m + n\); this means that to perform graph rewriting on graphs in
\(\hypsigma\), interfaces of terms in \(\smcsigma + \frob\) must be `folded'
into one using the compact closed structure.

\begin{definition}[\cite{bonchi2022stringa}]\label{def:fold-interfaces}
    Let \(\morph{\foldinterfaces}{\smcsigma + \frob}{\smcsigma + \frob}\)
    be defined as having action \(
    \iltikzfig{strings/category/f}[box=f,colour=white,dom=m,cod=n]
    \mapsto
    \iltikzfig{strings/rewriting/folding}[box=f,colour=white,dom=m,cod=n]
    \).
\end{definition}

The image of \(\foldinterfaces\) is not in the image of
\(\tracedtosymandfrobsigma\) or \(\tracedandcomonoidtofrobsigma\) any more,
as inputs of generators may now connect to outputs of the term.
This is not an issue, as long as we `unfold' the interfaces once rewriting is
completed.

\begin{proposition}[\cite{bonchi2022string}, Prop.\ 4.8]
    For a term \(
    \iltikzfig{strings/category/f}[box=f,colour=white,dom=m,cod=n]
    \in
    \smcsigma + \frob
    \), if \(
    \termandfrobtohypsigma[\iltikzfig{strings/category/f}[box=f,colour=white]]
    =
    \cospan{m}[i]{F}[o]{n}
    \) then \(
    \termandfrobtohypsigma[
        \foldinterfaces[
            \iltikzfig{strings/category/f}[box=f,colour=white]
        ]
    ]
    \) is isomorphic to \(
    \cospan{0}[]{F}[i+o]{m + n}
    \).
\end{proposition}
\begin{proof}
    Straightforward by definition of the cup using the Frobenius structure.
\end{proof}

We are now ready to begin rewriting.
Say we have a DPO rule \(\spann{L}{i + j}{R}\) and a larger cospan of
hypergraphs \(\cospan{m}{G}{n}\).
We suggestively assemble them as follows:

\begin{center}
    \begin{tikzcd}[row sep = small, column sep = small]
        L
        & i+j \arrow{l}\arrow{r}
        & R \\
        G
        &
        & \\
        & m+n \arrow{ul}
    \end{tikzcd}
\end{center}

To identify an occurrence of \(L\) in \(G\), we use a
hypergraph homomorphism \(L \to G\) to identify the components that will be
rewritten.

\begin{center}
    \begin{tikzcd}[row sep = small, column sep = small]
        L \arrow{d}
        & i+j \arrow{l}\arrow{r}
        & R \\
        G
        &
        & \\
        & m+n \arrow{ul}
    \end{tikzcd}
\end{center}

We now need to identify the \emph{context} in which the rewrite will occur in.
Essentially, the context is the `graph \(G\) with \(L\) cut out', which can be
formally defined with what is known as a \emph{pushout complement}.
This can be thought of as a `reverse pushout'.

\begin{definition}[Pushout complement]\label{def:pushout-complement}
    Let \(i+j \to L \to G \leftarrow m+n\) be morphisms in
    \(\hypsigmac\); their \emph{pushout complement} is an object \(C\)
    with morphisms \(i+j \to C \to G\) such that \(\cospan{L}{G}{C}\) is a
    pushout and the diagram below commutes.
    \begin{center}
        \begin{tikzcd}[column sep=large]
            L \arrow[swap]{d}
            &
            i+j
            \arrow[swap]{l}
            \arrow{d}
            \\
            G
            \arrow["\urcorner"{anchor=center, pos=0.125}, draw=none]{ur}
            &
            C
            \arrow{l}{g}
            \\
            &
            m+n
            \arrow{ul}
            \arrow[swap]{u}
        \end{tikzcd}
    \end{center}
\end{definition}

Is a pushout complement always guaranteed to exist for any morphism \(L \to G\)?
The answer is no; this will be discussed at length in the next section.
If a pushout complement does exist, it specifies the rewriting context.
This leaves us a hole in which the other side of the rewrite rule can be glued
in.

\begin{center}
    \begin{tikzcd}[row sep = small, column sep = small]
        L \arrow{d}
        & i+j \arrow{l}\arrow{r}\arrow{d}
        & R \\
        G \arrow["\urcorner"{anchor=center, pos=0.125}, draw=none]{ur}
        & C \arrow{l}
        & \\
        & m+n \arrow{ul}\arrow{u}
    \end{tikzcd}
\end{center}

To actually compute the rewritten graph, we perform another pushout to retrieve
the complete DPO diagram.

\begin{center}
    \begin{tikzcd}[row sep = small, column sep = small]
        L \arrow{d}
        & i+j \arrow{l}\arrow{r}\arrow{d}
        & R \arrow{d} \\
        G \arrow["\urcorner"{anchor=center, pos=0.125}, draw=none]{ur}
        & C \arrow{l}\arrow{r}
        & H \arrow["\ulcorner"{anchor=center, pos=0.125}, draw=none]{ul} \\
        & m+n \arrow{ul}\arrow{u}\arrow{ur}
    \end{tikzcd}
\end{center}

\begin{example}
    Consider the following term rewrite rule and its interpretation as a DPO
    rule. \[
        \raisebox{1.5em}{\(\rrule{
                \iltikzfig{strings/category/generator}[box=e_1]
            }{
                \iltikzfig{strings/category/generator}[box=e_2]
            }\)}
        \qquad
        \includestandalone{figures/graphs/dpo/example/rule}
    \]
    Now consider the term \(
    \iltikzfig{graphs/dpo/example/term}
    \); a complete DPO rewrite is performed as follows:
    \begin{center}
        \includestandalone{figures/graphs/dpo/example/rewrite}
    \end{center}
    As expected, the result is the term \(
    \iltikzfig{graphs/dpo/example/term-rewritten}
    \).
\end{example}
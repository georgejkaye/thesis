\section{Partial evaluation}

Partial evaluation~\cite{jones1996introduction} is a paradigm used in software
optimisation in which programs are `evaluated as much as possible' while only
some of the inputs are specified.
For example, it may be the case that a particular input to a program is fixed
for long periods of time; using partial evaluation, a program specialised for
this input can be defined.
This program might run significantly faster than the original.

There has been work into partial evaluation for hardware, such as constant
propagation~\cite{singh1996expressing,singh1999partial} and
unfolding~\cite{thompson2006bitlevel}.
However, this has been relatively informal, and can be made rigorous using the
categorical framework.

\subsection{Shortcut rules}

The reductions defined as part of the operational semantics assume that all the
components in the circuits are fully specified: to apply the \((\gateeqn)\)
reduction we need to know all the inputs.
However, when performing partial evaluation this might not be case; we may have
left some as variables to be specified later.
Fortunately, it is not always necessary to consider all of the inputs to a
primitive in order to determine its behaviour.
For example, for an \(\andgate\) gate, if either of its inputs are false then
the output must also be false, and if either of its inputs are true then the
output is the other input.

Exploiting this, we can define some new `shortcut' reductions shown in
\cref{fig:shortcuts}.
Two varieties are provided: one for when the inputs are instantaneous values
(although not necessarily fully reduced), and one for when the input is an
infinite waveform.
These rules are all sound for the reasons detailed above.

In a setting where we can fully reduce everything, these rule are redundant, as
eventually the \((\gateeqn)\) rule would be applied to the \(\andgate\)
gate and the same result found.
However, for partial evaluation they are a crucial way of propagating what
inputs we do have across a circuit.

\input{sections/circuits/application/floats/shortcuts}

\begin{example}[Blocking boxes]\label{ex:blocking-boxes}
    Consider the circuit \(
    \iltikzfig{circuits/examples/blocking/circuit}
    \), which contains a `blackbox' combinational circuit \(
    \iltikzfig{strings/category/f}[box=f, colour=comb]
    \) with unknown behaviour.

    Even though we cannot directly reduce the blackbox, if we set the first
    input to false and use the shortcut rule above, we can still produce an
    output value.
    \[
        \iltikzfig{circuits/examples/blocking/applied-false}
        \reduction
        \iltikzfig{circuits/examples/blocking/streamed-false}
        \reduction
        \iltikzfig{circuits/examples/blocking/reduced}
    \]
\end{example}



As well as removing redundant blackboxes, judicious use of shortcut
reductions could dramatically reduce the number of reductions needed to
get the outputs of a circuit.

The shortcut rule defined above only
which usually only arise after streaming has been applied.
With some

\begin{example}[Control switches]
    Recall that a \emph{multiplexer} is a circuit component constructed as \(
    \iltikzfig{circuits/components/gates/mux}
    \coloneqq
    \iltikzfig{circuits/components/gates/mux-construction}
    \).
    The first input is a \emph{control} which specifies which of the two other
    inputs is output.
    It is often the case that these control signals will be fixed for long
    periods of time; perhaps they specify some sort of global circuit
    configuration.
    \todo[inline]{Finish this off}
\end{example}

\begin{example}[Protocols]
    It may be the case that the inputs to a circuit are known to follow some
    sort of protocol.
    By including preconditions in our equational reasoning, we can observe
    more optimisation potential.
    We write \(=_{\mathsf{A} \in X}\) when we assume the inputs along wire
    \(\mathsf{A}\) will only be members of set \(X \subseteq \valuetuple{m}\).

    For example, \(
    \iltikzfig{circuits/examples/protocol/protocol-rule-lhs}
    =_{\mathsf{A}\in\{\mathsf{t},\mathsf{f}\}}
    \iltikzfig{circuits/examples/protocol/protocol-rule-rhs}
    \), as at least one true values will be applied to the \(\orgate\).
    Consider the larger circuit below and assume that the first two
    inputs can only ever be inverses; it can be shown that this circuit
    exhibits combinational behaviour.
    \begin{gather*}
        \iltikzfig{circuits/examples/protocol/protocol-circuit}
        \Rightarrow
        \iltikzfig{circuits/examples/protocol/circuit-with-protocol}
        =_{\mathsf{A}\in\{\mathsf{t},\mathsf{f}\}}
        \iltikzfig{circuits/examples/protocol/circuit-with-protocol-1}
        =
        \iltikzfig{circuits/examples/protocol/circuit-with-protocol-3}
    \end{gather*}
\end{example}

Since equations can be freely applied without being concerned with the context,
partial evaluation could be automated by applying as many reductions as
possible.
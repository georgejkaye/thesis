\section{Partial evaluation}

Partial evaluation~\cite{jones1996introduction} is a paradigm used in software
optimisation in which programs are `evaluated as much as possible' while only
some of the inputs are specified.
For example, it may be the case that a particular input to a program is fixed
for long periods of time; using partial evaluation, we can define a program
specialised for this input.
This program might run significantly faster than the original.

There has been work into partial evaluation for hardware, such as constant
propagation~\cite{singh1996expressing,singh1999partial} and
unfolding~\cite{thompson2006bitlevel}.
However, this has been relatively informal, and can be made rigorous using the
categorical framework.
In this section we will discuss how we could extend the reduction-based
operational semantics to define automatic procedures for applying partial
evaluation to circuits.

\subsection{Tidying up}

When building a circuit, it is often desirable to reduce the number of wires
and components used; this reduces both the physical size of the circuit and its
power consumption.
We can use partial evaluation to transform a circuit into a more minimal form.

\begin{definition}[Tidying rules]
    Let the set of \emph{tidying rules} be defined as the rules in
    \cref{fig:tidy-rules}.
\end{definition}

Most of the tidying rules are self-explanatory; the final rule is necessary in
order to deal with traced circuits with no outputs.
Since all circuits with no outputs have the same behaviour, we are permitted tot
`cut' the trace and get a circuit we can apply more tidying rules to.
As non-delay-guarded feedback is already handled by the
\((\instantfeedbackeqn)\) rule, we only need to consider the delay-guarded case.

\input{sections/circuits/application/floats/tidy-rules}

\begin{proposition}
    Applying the tidying rules to a circuit in Mealy form is confluent and
    terminating.
\end{proposition}
\begin{proof}
    The tidying rules always decrease the size of the circuit.
    The only choice is raised when there is a trace around a combinational
    circuit, but this does not change the internal structure of the subcircuit,
    so rule applications are prevented.
    Moreover, since all this rule does is `cut' a trace, it does not matter if
    this is performed `all in one go', or each feedback loop is cut one by one.
\end{proof}

\subsection{Shortcut rules}

It is often the case that we know that some of the inputs to a circuit is fixed.
This can be modelled by precomposing the relevant input with an
\emph{infinite waveform} \(
\iltikzfig{circuits/components/waveforms/infinite-register}[val=v]
\).
We can propagate these waveforms across a circuit to see if we can reduce it to
something simpler \emph{specialised} for these inputs.

To propagate waveforms across circuits we need to derive a version of the
\((\gateeqn)\) rule for applying waveforms to primitives.
These rules are illustrated in \cref{fig:waveform-rules}.

\input{sections/circuits/application/floats/waveform-rules}

This is not the only way we can partially evaluate with some inputs.
In some interpretations, it may be that we learn something about the output of
a primitive with only some of the inputs specified.

\begin{example}[Belnap shortcuts]
    In the Belnap interpretation \(\belnapinterpretation\), if one applies a
    false value to an \(\andgate\) gate then it will output false regardless of
    the other input.
    Similarly, if one applies a true value to an \(\orgate\) gate it will output
    true.

    Conversely, if one applies a true value to an \(\andgate\) gate or a false
    value to an \(\orgate\) gate, the output will be the other input.
\end{example}

These `shortcuts' can also be implemented as rules, as illustrated in
\cref{fig:shortcut-waveform-rules}.
Note that here the value that `triggers' the shortcut must be contained within
an infinite waveform; if we applied the rule with just an instantaneous value,
this value would produce \(\bot\) on ticks after the first and the rule would
be unsound.

\input{sections/circuits/application/floats/shortcut-waveform-rules}

\begin{example}[Control switches]
    Recall that a \emph{multiplexer} is a circuit component constructed as \(
    \iltikzfig{circuits/components/gates/mux}
    \coloneqq
    \iltikzfig{circuits/components/gates/mux-construction}
    \).
    The first input is a \emph{control} which specifies which of the two other
    inputs is output.
    It is often the case that these control signals will be fixed for long
    periods of time; perhaps they specify some sort of global circuit
    configuration.

    Consider the circuit \(
    \iltikzfig{circuits/examples/control/circuit}
    \), in which the control signal to the multiplexer determines which of two
    subcircuits will become the output.
    We will assume that the control signal is held at false; to use the shortcut
    rules above we expand the definition of the multiplexer so the circuit is \(
    \iltikzfig{circuits/examples/control/circuit-expanded}
    \) and reduce as follows.
    \begin{gather*}
        \iltikzfig{circuits/examples/control/circuit-applied}
        \reduction
        \iltikzfig{circuits/examples/control/circuit-applied-1}
        \reduction
        \iltikzfig{circuits/examples/control/circuit-applied-2}
        \reduction
        \\[1em]
        \iltikzfig{circuits/examples/control/circuit-applied-3}
        \reduction
        \iltikzfig{circuits/examples/control/circuit-applied-4}
    \end{gather*}
\end{example}

\subsection{Shortcuts after streaming}

The rules in the previous sections are intended for use on circuit before we
even apply values to them.
However, there is still potential for partial evaluation when we consider the
outputs of a circuit one step at a time.
To do this, we can apply variants of the shortcut rules \emph{after} performing
streaming for some inputs.
These variants are illustrated in \cref{fig:shortcuts}.

\input{sections/circuits/application/floats/shortcuts}

\begin{example}[Blocking boxes]\label{ex:blocking-boxes}
    Consider the circuit \(
    \iltikzfig{circuits/examples/blocking/circuit}
    \), which contains a `blackbox' combinational circuit \(
    \iltikzfig{strings/category/f}[box=f, colour=comb]
    \) with unknown behaviour.

    Even though we cannot directly reduce the blackbox, if we set the first
    input to false and use the shortcut rule above, we can still produce an
    output value.
    \[
        \iltikzfig{circuits/examples/blocking/applied-false}
        \reduction
        \iltikzfig{circuits/examples/blocking/streamed-false}
        \reduction
        \iltikzfig{circuits/examples/blocking/reduced}
    \]
\end{example}

As well as removing redundant blackboxes, judicious use of shortcut
reductions can dramatically reduce the reductions needed to get the outputs of a
circuit.

\subsection{Protocols}

Sometimes we may not know the exact inputs to a circuit, but know that they make
up a fixed subset of all possible inputs, or they follow some sort of protocol.
We can reason about this by considering all of the \emph{universes}


We can implement this in our reduction framework with \emph{uncertain values}
which we either know nothing about or know can only take some specified values.

\begin{definition}
    Let \(\scircsigmap\) be the result of extending \(\scircsigma\) with value
    generators for each word \(\listvar{v?} \in \freemon{\values}\).
\end{definition}

The additional value generators indicate \emph{uncertainty} over what the value
may be.
The intended interpretation of an uncertain value \(
\iltikzfig{circuits/components/values/vs-longer}[val=\listvar{v?}]
\) where \(\listvar{v?}\) is a word of length \(k\) is that there are \(k\)
possible `universes' in play; in each universe this value will be
\(\listvar{v?}(0)\), \(\listvar{v?}(1)\), and so on up to \(\listvar{v?}(k-1)\).
If an uncertain value word has length shorter than the number of universes, we
take the convention that the value in this universe is \(\bot\).

To avoid confusion with our syntax sugar for arbitrary-width values, we will
always end uncertain value lists with \(?\).
When writing concrete uncertain values, we delimit the elements of the word with
vertical bars as in \(\mathsf{f}|\mathsf{t}\) to allude to the fact this value
is either the first \emph{or} the second element.

\begin{example}
    If we have uncertain values \(
    \iltikzfig{circuits/components/values/vs-longer}[val=\belnapfalse|\belnaptrue]
    \) and \(
    \iltikzfig{circuits/components/values/vs-longer}[val=\belnaptrue|\belnapfalse]
    \) in a circuit, there are two universes to consider, one where the
    values output \(\belnapfalse\belnaptrue\) and one where they output
    \(\belnaptrue\belnapfalse\).

    If we add in a third uncertain value with three possible values, \(
    \iltikzfig{circuits/components/values/vs-even-longer}[val=\belnaptrue|\belnapfalse|\top]
    \), we now have three possible universes: the outputs are now
    \(\belnapfalse\belnaptrue\belnaptrue\),
    \(\belnaptrue\belnapfalse\belnapfalse\), and
    \(\bot\bot\top\) respectively.
\end{example}

To reason with uncertain values in the reductional framework we need to add
rules for processing them.
Once again it is useful to have versions for both waveforms and values, for
reasoning before and during execution.

\begin{definition}[Uncertain rules]
    The \emph{uncertain rules} are listed in \cref{fig:uncertain-rules}.
\end{definition}

\input{sections/circuits/application/floats/uncertain-rules}



\begin{example}[Protocols]
    One sticking point that arises when using the categorical framework is the
    presence of the \(\bot\) and \(\top\) values, which would not normally
    be explicitly provided to a circuit.
    Using uncertain values, we can specify the values that \emph{will} be
    applied to a circuit and reduce accordingly.

    For example, \(
    \iltikzfig{circuits/examples/protocol/protocol-rule-lhs}
    =_{\mathsf{A}\in\{\mathsf{t},\mathsf{f}\}}
    \iltikzfig{circuits/examples/protocol/protocol-rule-rhs}
    \), as at least one true values will be applied to the \(\orgate\).
    Consider the larger circuit below and assume that the first two
    inputs can only ever be inverses; it can be shown that this circuit
    exhibits combinational behaviour.
    \begin{gather*}
        \iltikzfig{circuits/examples/protocol/protocol-circuit}
        \Rightarrow
        \iltikzfig{circuits/examples/protocol/circuit-with-protocol}
        =_{\mathsf{A}\in\{\mathsf{t},\mathsf{f}\}}
        \iltikzfig{circuits/examples/protocol/circuit-with-protocol-1}
        =
        \iltikzfig{circuits/examples/protocol/circuit-with-protocol-3}
    \end{gather*}
\end{example}

Since equations can be freely applied without being concerned with the context,
partial evaluation could be automated by applying as many reductions as
possible.
\section{Partial evaluation}

Partial evaluation~\cite{jones1996introduction} is a paradigm used in software
optimisation in which programs are `evaluated as much as possible' while only
some of the inputs are specified.
For example, it may be the case that a particular input to a program is fixed
for long periods of time; using partial evaluation, a program specialised for
this input can be defined.
This program might run significantly faster than the original.

There has been work into partial evaluation for hardware, such as constant
propagation~\cite{singh1996expressing,singh1999partial} and
unfolding~\cite{thompson2006bitlevel}.
However, this has been relatively informal, and can be made rigorous using the
categorical framework.

\subsection{Shortcut rules}

The reductions defined as part of the operational semantics assume that all the
components in the circuits are fully specified: to apply the \((\gateeqn)\)
reduction we need to know all the inputs.
However, when performing partial evaluation this might not be case; we may have
left some as variables to be specified later.
Fortunately, it is not always necessary to consider all of the inputs to a
primitive in order to determine its behaviour.
For example, for an \(\andgate\) gate, if either of its inputs are false then
the output must also be false, and if either of its inputs are true then the
output is the other input.

Exploiting this, we can define some new `shortcut' reductions shown in
\cref{fig:shortcuts}.
These rules are only sound when the other inputs are also (unreduced)
instantaneous values, as the value will produce \(\bot\) on subsequent cycles,
violating the soundness of the shortcut.

These rule are redundant in a setting where we can fully reduce everything, as
eventually the \((\gateeqn)\) rule would be applied to the \(\andgate\) gate and
the same result found.
However, for partial evaluation they are a crucial way of propagating what
inputs we do have across a circuit.

\input{sections/circuits/application/floats/shortcuts}

\begin{example}[Blocking boxes]\label{ex:blocking-boxes}
    Consider the circuit \(
    \iltikzfig{circuits/examples/blocking/circuit}
    \), which contains a `blackbox' combinational circuit \(
    \iltikzfig{strings/category/f}[box=f, colour=comb]
    \) with unknown behaviour.

    Even though we cannot directly reduce the blackbox, if we set the first
    input to false and use the shortcut rule above, we can still produce an
    output value.
    \[
        \iltikzfig{circuits/examples/blocking/applied-false}
        \reduction
        \iltikzfig{circuits/examples/blocking/streamed-false}
        \reduction
        \iltikzfig{circuits/examples/blocking/reduced}
    \]
\end{example}

As well as removing redundant blackboxes, judicious use of shortcut
reductions can dramatically reduce the reductions needed to get the outputs of a
circuit.

The shortcut rules defined above are only applied after streaming is applied, so
they only rewrite the circuit for the current cycle of execution.
However, when some of the inputs to a circuit are fixed, partial evaluation can
be used to reduce the size of a circuit to make a circuit specialised for this
input.
This can be modelled by precomposing the relevant input with an
\emph{infinite waveform} \(
\iltikzfig{circuits/components/waveforms/infinite-register}[val=v]
\).

To propagate waveforms across circuits we need to derive a version of the
\((\gateeqn)\) rule for applying waveforms to primitives.
We also generalise the shortcut rules to work on infinite waveforms; since the
input triggering the shortcut is fixed, we no longer need to enforce that the
other inputs are instantaneous and can leave these as dangling inputs.
These rules are illustrated in \cref{fig:waveform-rules}.

\input{sections/circuits/application/floats/waveform-rules}

\begin{example}[Control switches]
    Recall that a \emph{multiplexer} is a circuit component constructed as \(
    \iltikzfig{circuits/components/gates/mux}
    \coloneqq
    \iltikzfig{circuits/components/gates/mux-construction}
    \).
    The first input is a \emph{control} which specifies which of the two other
    inputs is output.
    It is often the case that these control signals will be fixed for long
    periods of time; perhaps they specify some sort of global circuit
    configuration.

    Consider the circuit \(
    \iltikzfig{circuits/examples/control/circuit}
    \), in which the control signal to the multiplexer determines which of two
    subcircuits will become the output.
    We will assume that the control signal is held at false; to use the shortcut
    rules above we expand the definition of the multiplexer so the circuit is \(
    \iltikzfig{circuits/examples/control/circuit-expanded}
    \) and reduce as follows.
    \begin{gather*}
        \iltikzfig{circuits/examples/control/circuit-applied}
        \reduction
        \iltikzfig{circuits/examples/control/circuit-applied-1}
        \reduction
        \iltikzfig{circuits/examples/control/circuit-applied-2}
        \reduction
        \\[1em]
        \iltikzfig{circuits/examples/control/circuit-applied-3}
        \reduction
        \iltikzfig{circuits/examples/control/circuit-applied-4}
    \end{gather*}
\end{example}

\begin{example}[Protocols]
    It may be the case that the inputs to a circuit are known to follow some
    sort of protocol.
    By including preconditions in our equational reasoning, we can observe
    more optimisation potential.
    We write \(=_{\mathsf{A} \in X}\) when we assume the inputs along wire
    \(\mathsf{A}\) will only be members of set \(X \subseteq \valuetuple{m}\).

    For example, \(
    \iltikzfig{circuits/examples/protocol/protocol-rule-lhs}
    =_{\mathsf{A}\in\{\mathsf{t},\mathsf{f}\}}
    \iltikzfig{circuits/examples/protocol/protocol-rule-rhs}
    \), as at least one true values will be applied to the \(\orgate\).
    Consider the larger circuit below and assume that the first two
    inputs can only ever be inverses; it can be shown that this circuit
    exhibits combinational behaviour.
    \begin{gather*}
        \iltikzfig{circuits/examples/protocol/protocol-circuit}
        \Rightarrow
        \iltikzfig{circuits/examples/protocol/circuit-with-protocol}
        =_{\mathsf{A}\in\{\mathsf{t},\mathsf{f}\}}
        \iltikzfig{circuits/examples/protocol/circuit-with-protocol-1}
        =
        \iltikzfig{circuits/examples/protocol/circuit-with-protocol-3}
    \end{gather*}
\end{example}

Since equations can be freely applied without being concerned with the context,
partial evaluation could be automated by applying as many reductions as
possible.
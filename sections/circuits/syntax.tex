\chapter{Syntax}

Category theory is famous for being overly abstract, obfuscated
behind reams of incomprehensible terminology.
But one does not need to study category theory for the sake of abstract
nonsense.
Rather, we view category theory as a tool for exploiting connections
between fields which may at first seem completely disparate; category theory is
the \emph{common language} that brings them together.

This is not a new idea; this concept has been explored in many areas since
before the turn of the millennium.
Our \emph{soup du jour} is that of \emph{sequential digital circuits}
constructed from primitive components such as logic gates or transistors.
These circuits are \emph{sequential} as they have a notion of \emph{state}:
outputs can be impacted by inputs in previous cycles rather than solely those in
the current cycle.

\begin{remark}
    Digital (electric) circuits are not to be confused with \emph{electronic}
    circuits of switches and resistors, which are quite different!
    Essentially, the difference boils down to the difference between traced
    categories and compact closed categories discussed in the previous section.
    Digital circuits have a clear notion of \emph{causality}; one provides
    inputs and produces outputs.
    Conversely, electronic circuits are \emph{relational} in nature; they do not
    produce outputs per se but simply respect the various equalities found in
    introductory textbooks.
    Fortunately for those so inclined, electronic circuits were given the
    categorical treatment by Boisseau and Sobocinski in
    \cite{boisseau2022string}.
\end{remark}

\begin{remark}
    The content of this section is a refinement and expansion
    of~\cite[Section 2]{ghica2023compositional}.
\end{remark}

\section{Circuit signatures}

Before we can start doing anything exciting with digital circuits, we need to
define a \emph{syntactic} category in which we can construct digital circuits.
While we could go ahead and define a category of circuits with some fixed gate
set, at some point someone would come along and complain that their favourite
logic gate has been forgotten.
Instead, we set a \emph{circuit signature} to define the components in a
particular category of circuits.

\begin{definition}[Circuit signature, value, gate symbol]
    A \emph{circuit signature} \(\circuitsignature\) is a tuple \((
        \values,
        \disconnected,
        \circuitsignaturegates,
        \circuitsignaturearity,
        \circuitsignaturecoarity
    )\) where \(\values\) is a finite set of \emph{values}, \(
        \disconnected \in \values
    \) is a \emph{disconnected} value, \(\circuitsignaturegates\) is a (usually
    finite) set of \emph{gate symbols}, \(
        \morph{\circuitsignaturearity}{\circuitsignaturegates}{\natplus^\star}
    \) is an \emph{arity} function and \(
        \morph{\circuitsignaturecoarity}{\circuitsignaturegates}{\natplus^\star}
    \) is a \emph{coarity} function.
\end{definition}

A particularly important signature, and one which we will turn to for the
majority of examples in this thesis, is that of gate-level circuits.

\begin{example}[Gate-level circuits]\label{ex:sig}
    The signature for \emph{gate-level circuits} is \(
        \belnapsignature = (
            \belnap,
            \bot,
            \belnapgates,
            \belnaparity,
            \belnapcoarity
    )\), where \(
        \belnapvalues \coloneqq \{\bot, \belnapfalse, \belnaptrue, \top\}
    \), respectively representing \emph{no} signal, a \emph{false} signal, a
        \emph{true} signal and \emph{both} signals at once, \(
        \belnapgates \coloneqq \{\andgate,\orgate,\notgate\}
    \), \(
        \belnaparity \coloneqq
            \andgate \mapsto [1,1],
            \orgate \mapsto [1,1],
            \notgate \mapsto [1]
    \) and \(
        \belnapcoarity \coloneqq - \mapsto [1],
    \)
\end{example}

\begin{remark}
    Using four values may come as a surprise to those expecting the usual
    `true' and 'false' logical values.
    This logical system is an old idea going back to
    Belnap~\cite{belnap1977useful} who remarked that this is `how a computer
    should think'.
    Rather than just thinking about how much \emph{truth content} a value
    carries, the four value system adds a notion of \emph{information content}:
    the \(\bot\) value is no information at all (a disconnected wire), whereas
    the \(\top\) value is both true and false information at once
    (a short circuit).
    This notion of information content will also come in very important when
    defining the semantics of circuits in the upcoming sections.
\end{remark}

\section{Combinational circuits}

Before diving straight into sequential circuits, we will define a category of
\emph{combinational circuits}.
These are circuits with no state; they compute \emph{functions} of their inputs.

\begin{definition}[Combinational circuit generators]
    Given a circuit signature \(
        \circuitsignature = (
            \circuitsignaturevalues,
            \bullet,
            \circuitsignaturegates,
            \circuitsignaturearity,
            \circuitsignaturecoarity
        )
    \), let the set \(\generators[\ccirc{}]\) of
    \emph{combinational circuit generators} be defined as the set containing \(
        \iltikzfig{circuits/components/gates/gate}[gate=g,colour=comb,dom=\circuitsignaturearity(g),cod=\circuitsignaturecoarity(g)]
    \) for each \(g \in \circuitsignaturegates\),
    \(\iltikzfig{strings/structure/monoid/init}[colour=comb]\),
    \(\iltikzfig{strings/structure/comonoid/copy}[colour=comb]\),
    \(\iltikzfig{strings/structure/monoid/merge}[colour=comb]\), and
    \(\iltikzfig{strings/structure/comonoid/discard}[colour=comb]\).
    We write \(\ccircsigma\) for the freely generated bundled PROP
    \(\smc{\generators[\ccirc{}]}\).
\end{definition}

Each primitive symbol \(p \in \circuitsignaturegates\) has a corresponding
generator in \(\ccircsigma\).
The remaining generators are \emph{structural} generators for manipulating
wires: these are present regardless of the signature.
In order, they are for \emph{introducing} wires, \emph{forking}
wires, \emph{joining} wires and \emph{eliminating} wires.

\begin{example}
    The gate generators of \(\ccirc{\belnapsignature}\) are \(
        \iltikzfig{circuits/components/gates/and}
    \), \(
        \iltikzfig{circuits/components/gates/or}
    \), and \(
        \iltikzfig{circuits/components/gates/not}
    \).
\end{example}

When drawing circuits, the coloured backgrounds of generators will often be
omitted in the interests of clarity.
Since the category is freely generated, morphisms are defined by
juxtaposing the generators in a given signature sequentially or in parallel with
each other, the identity \iltikzfig{strings/category/identity}[colour=comb], and
the symmetry \iltikzfig{strings/symmetric/symmetry}[colour=comb].
Arbitrary combinational circuit morphisms defined in this way are drawn as light
boxes \iltikzfig{strings/category/f}[box=f,colour=comb,dom=m,cod=n].

\begin{notation}\label{not:arbitrary-width-structure}
    The structural generators are only defined on single bits, but it is a
    simple exercise to define them on arbitrary bit inputs and outputs using the
    bundlers and axioms of symmetric monoidal categories.
    \todo[inline]{Show the constructions}
    To avoid cluttering diagrams, these are drawn as their single-bit
    counterparts:
    \[
        \iltikzfig{strings/structure/monoid/init}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/structure/comonoid/copy}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/structure/monoid/merge}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/structure/comonoid/discard}[colour=comb,obj=n]
    \]
\end{notation}

\begin{example}[Half adder]
    \todo[inline]{Do the half adder example}
\end{example}

\section{Sequential circuits}

Combinational circuits compute functions of their inputs, but have no internal
state.
This is all very well for doing simple calculations, but we have ascended far
beyond primitive adding machines; we actually need to remember things!
As we have mentioned earlier, circuits with state are called
\emph{sequential circuits}.

Circuits gain state through a combination of \emph{delay} and \emph{feedback}.
The latter means we need to shift from a vanilla symmetric monoidal category to
a symmetric \emph{traced} monoidal category.

\begin{definition}[Sequential circuits]
    For a circuit signature \(\circuitsignature\) with value set \(\values\),
    let \(\scircsigma\) be the STMC freely generated over the generators of
    \(\ccircsigma\) along with new generators \(
        \iltikzfig{circuits/components/values/vs}[val=v]
    \) for each \(v \in \values \setminus \bullet\), and \(
        \iltikzfig{circuits/components/waveforms/delay}
    \).
\end{definition}

The two new types of generator are \emph{instantaneous values} and
\emph{delays}.

\begin{remark}
    We will now provide some intuition behind these sequential components, but
    don't worry, this is not yet a formal semantics!
\end{remark}

The first set of generators are \emph{instantaneous values} for each value in
\(\values \setminus \bullet\).
Value generators are intended to be interpreted as producing their value in the
first cycle of execution, followed by producing the disconnected \(\bullet\)
after that.
This is why there is no \(\bullet\) value generator; instead it is a
\emph{combinational} generator \(
    \iltikzfig{strings/structure/monoid/init}[colour=comb]
\) intended to always produce the \(\bullet\) value.

\begin{notation}
    Although \(
        \iltikzfig{strings/structure/monoid/init}[colour=comb]
    \) is itself not a sequential value, when we refer to an arbitrary `value'
    \(
        \iltikzfig{circuits/components/values/vs}[val=v]
    \), \(v\) can be any value in \(\values\) including \(\bullet\).

    For a word of values \(\listvar{v} \in \valuetuple{n}\) (again possibly
    including \(\bullet\)), we may draw multiple value generators collapsed into
    one as \(
        \iltikzfig{circuits/components/values/vs}[val=\listvar{v},width=n]
    \).
    \todo[inline]{Draw the constructions}
\end{notation}

\begin{example}
    The `values' of \(\scirc{\belnapsignature}\) are \(
        \iltikzfig{strings/structure/monoid/init}[colour=comb]
    \), \(
        \iltikzfig{circuits/components/values/vs}[val=\belnapfalse]
    \), \(
        \iltikzfig{circuits/components/values/vs}[val=\belnaptrue]
    \), \(
        \iltikzfig{circuits/components/values/vs}[val=\top]
    \); the first is a combinational generator and the latter three are
    sequential.
\end{example}

The delay component is the opposite of a value; in the first cycle of execution
it is intended to produce the \(\bullet\) value, but in future cycles it outputs
the input it received in the previous cycle.

\begin{remark}
    While the mathematical interpretation of a delay is straightforward, the
    physical aspect of a digital circuit it models is less clear.
    An obvious interpretation could be that the delay models as D flipflop in
    a clocked circuit, so the delay is one clock cycle.
    A more subtle interpretation is the `minimum obervable duration'; in this
    case the delay models inertial delay on wires up to some fixed precision.
\end{remark}

\begin{notation}
    Like values, we can derive delay components for thicker wires, drawn like
    \(
        \iltikzfig{circuits/components/waveforms/delay}[width=n]
    \).
    \todo[inline]{Draw the construction}
\end{notation}

To distinguish them from combinational circuits, arbitrary sequential circuit
morphisms are drawn as green boxes \iltikzfig{strings/category/f}[box=f,colour=comb,dom=m,cod=n].

We now have all the components for the excited reader to go off and build
all the circuits they could possibly want.
For those who need some inspiration, we provide a simple example.

\begin{example}[SR latch]\label{ex:sr-latch}
    A \(\norgate\) is the combination of an \(\orgate\) gate followed by a
    \(\notgate\); it inverts the outputs of an \(\orgate\).
    Syntactically it is constructed as \(
        \iltikzfig{circuits/components/gates/nor}
        \coloneqq
        \iltikzfig{circuits/components/gates/nor-construct}
    \).

    \(\norgate\) gates are integral to a construction that one might come across
    early on in an electronics textbook: the \emph{SR NOR latch}.
    An SR NOR latch is one of the simplest registers; an example is illustrated
    in \cref{fig:latch}.

    SR NOR latches are used to hold state.
    They have two inputs: Reset (\(\mathsf{R}\)) and Set (\(\mathsf{S}\)), and
    two outputs \(\mathsf{Q}\) and \(\bar{\mathsf{Q}}\) which are always
    negations of each other.
    When Set receives a high signal, the \(\mathsf{Q}\) output is forced high,
    and will remain as such even if the Set input stops being pulsed high.
    It is only until the Reset input is pulse high that the \(\mathsf{Q}\)
    output will return to low.
    (It is illegal for both Set and Reset to be pulsed high simultaneously; this
    issue is fixed in more complicated latches).

    SR latches work because of delays in how gates and wires transmit signals;
    one of the feedback lops between the two \(\norgate\) gates will `win'.
    We can model this in \(\scircsigma\) by using a different number of delay
    generators between the top and the bottom of the latch.
    We have opted for just the one on the bottom half in our construction in
    \cref{fig:latch}
    because otherwise the upcoming examples become excessively complicated, but
    any number would do, so long as the top and bottom differ!
\end{example}

\input{floats/sr-latch}
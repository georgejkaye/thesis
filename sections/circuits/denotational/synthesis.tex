\section{Between circuits and Mealy machines}

The main result of this section is to establish the links between circuits
and Mealy machines, and use this as a tool to help us assert the completeness of
the denotational semantics.
To do this, we must define PROP morphisms between \(\scircsigma\) and
\(\mealyi\).

Going from \(\scircsigma\) to \(\mealyi\) is straightforward since the former
is freely generated.

\begin{definition}
    Let \(\morph{\circuittomealyi}{\scircsigma}{\mealyi}\) be the traced PROP
    morphism defined on the generators as:
    \begin{align*}
        \circuittomealy[
            \iltikzfig{strings/category/f}[box=F,colour=comb]
        ]{\interpretation}
        &\coloneqq \left(\left(\{()\}, \overline{v} \mapsto \left((), {
            \circuittofunc[
                \iltikzfig{strings/category/f}[box=F,colour=comb]
            ]{\interpretation}(\overline{v})
        }\right)\right), ()\right)
        \\[0.1em]
        \circuittomealy[
            \iltikzfig{circuits/components/values/vs}[val=v]
        ]{\interpretation}
        &\coloneqq
        \left(
            \left(
            \{s_v, s_\bot\},
            \{
                s_v \mapsto \left(s_\bot,v\right),
                s_\bot \mapsto \left(s_\bot,\bot\right)
            \}\right),
            s_v
        \right)
        \\[0.1em]
        \circuittomealy[
            \iltikzfig{circuits/components/waveforms/delay}
        ]{\interpretation}
        &\coloneqq
        \left(
            \left(
            \{ s_v \,|\, v \in \values\},
            (s_v, a) \mapsto \left({v,s_a}\right)\right),
            s_\bot
        \right)
    \end{align*}
    \todo[inline]{Fiddle with spacing}
\end{definition}

\todo[inline]{Draw diagrams for values and delays maybe?}

\begin{example}\label{ex:mealy-translation}
    Applying \(\circuittomealy{\belnapinterpretation}\) to the SR NOR latch from
    \cref{ex:latch} produces the monotone Mealy machine in
    \cref{ex:trace-mealy}.
\end{example}

To check that this is the `correct' translation, it must
\emph{preserve behaviour}: that is to say, if for a sequential circuit \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=m,cod=n]
\), \(
    \circuittostreami[
        \iltikzfig{strings/category/f}[box=f,colour=seq]
    ]
\) is a stream function \(f\), then \(
    \mealytostreami[
        \circuittomealyi[
            \iltikzfig{strings/category/f}[box=f,colour=seq]
        ]
    ]
\) must be the same stream function \(f\).

\begin{theorem}\label{thm:mealy-preserves-behaviour}
    \(
        \circuittostream{\interpretation}
        =
        \mealytostream \circ \circuittomealy{\interpretation}
    \).
\end{theorem}
\begin{proof}
    Since morphisms of \(\mealyi\) and \(\streami\) are both Mealy
    coalgebras, we just need to check that the transitions and outputs of the
    image of \(\circuittomealyi\) and \(\circuittostreami\) agree.
    \todo[inline]{Well do they? Do the proof}
\end{proof}

So one direction is done; now for the other, which as is often the case is
a bit harder.
For regular Mealy machines, there is a standard procedure in circuit
design~\cite{kohavi2009switching} in which each state of a Mealy machine is
\emph{encoded} as a power of values, and combinational logic used to transform
inputs into appropriate outputs.

\begin{example}
    \todo[inline]{Simple boolean examples}
\end{example}

When considering \emph{monotone} Mealy machines and trying to map into
\(\scircsigma\), this procedure must respect monotonicity as the combinational
logic is constructed using monotone components.
This means that an arbitrary encoding cannot be used; we will now show how to
select a suitable encoding.

\begin{definition}[Encoding]\label{def:encoding}
    Let \(S\) be a set equipped with a partial order \(\stateorder\) and a total
    order \(\leq\) such that \(s_0 \leq s_1 \leq \dots s_{k-1}\).
    The \emph{\(\leq\)-encoding} for this assignment is a function
    \(\morph{\gamma_\leq}{S}{\valuetuple{k}}\) defined as
    \(\gamma_\leq(s)(i) \coloneqq \top\) if \(s_i \stateorder s\) and
    \(\gamma_\leq(s)(i) \coloneqq \bot\) otherwise.
\end{definition}

\begin{example}
    Recall the monotone Mealy machine from \cref{ex:mealy-translation}, which
    has state set \(
        \belnapvalues \coloneqq \{\bot,\belnapfalse,\belnaptrue,\top\}
    \).
    We choose the total order on \(\belnapvalues\) as
    \(\bot \leq \belnapfalse \leq \belnaptrue \leq \top\); subsequently, the
    \(\leq\)-encoding is defined as \(
        \bot \mapsto \top\bot\bot\bot, \belnapfalse \mapsto \top\top\bot\bot,
        \belnaptrue \mapsto \top\bot\top\bot, \top \mapsto \top\top\top\top
    \).
\end{example}

It is essential that a \(\leq\)-encoding respects the original ordering of the
states.

\begin{lemma}
    For an ordered state space \((S,\stateorder)\) and a \(\leq\)-encoding
    \(\gamma_\leq\), \(s \stateorder s^\prime\) if and only if
    \(\gamma_\leq(s) \sqsubseteq \gamma_\leq(s^\prime)\).
\end{lemma}
\begin{proof}
    First the \(\onlyifdir\) direction.
    Let \(s_i \stateorder s_j\); we need to show that for every \(l < k\),
    \(s_i(l) \sqsubseteq s_j(l)\).
    The only way this can be violated is if \(s_i(l) = \top\) and
    \(s_j(l) = \bot\).
    But since \(s_i \stateorder s_j\), if \(s_l \stateorder s_i\) then
    \(s_l \stateorder s_j\) also holds.

    Now the \(\ifdir\) direction.
    Assume that \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\); we need to
    show that \(s_i \stateorder s_j\); i.e.\ that \(\gamma_\leq(s_j)(i) = \top\)
    If \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\), then for each
    \(l < k\) then \(\gamma_\leq(s_i)(l) \sqsubseteq \gamma_\leq(s_j)(l)\);
    in particular \(\gamma_\leq(s_i)(i) \sqsubseteq \gamma_\leq(s_j)(i)\)
    By definition of \(\gamma_\leq\), \(\gamma_\leq(s_i)(i) = \top\), so if
    \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\) then
    \(\gamma_\leq(s_j)(i)\) is also \(\top\).
\end{proof}

Using this encoding, we will construct a combinational circuit morphism that,
when interpreted as a function, implements the output and transition function
of the Mealy machine.
There is no reason for such a morphism to exist for an arbitrary interpretation:
why should we expect some hurriedly slapped together collection of gates to be
able to model every function?
The useful interpretations are those that \emph{can} model every function.

\begin{definition}[Functional completeness]
    An interpretation \(\interpretation\) of a signature \(\signature\) is
    \emph{functionally complete} if there exists a map \(
        \morph{\mealytofunc}{\funci}{\scircsigma}
    \) which sends functions \(
        \morph{f}{\valuetuple{\listvar{m}}}{\valuetuple{\listvar{n}}}
    \), to circuits of the form \(
        \iltikzfig{circuits/synthesis/normalised-function}
    \) for some word \(\listvar{v} \in \freemon{\values}\) such that
    \(\circuittostreami[\mealytofunc[f]](\sigma)(i) = f(\sigma(i))\).
\end{definition}

For a particular interpretation there may well be many such maps from functions
to circuits, but for convenience we will assume there is a fixed procedure
\(\mealytofunc\) amd refer to a circuit \(\mealytofunc[f]\) as the
\emph{normalised circuit for \(f\)}.\

\begin{remark}
    Even though \(\mealytofunc\) concerns combinational functions, it maps into
    the category of \emph{sequential} circuits \(\scircsigma\)!
    This is because sometimes instantaneous values must be used to create the
    normalised circuit.
    However, the loop enforces that the state is \emph{constant}: it will always
    produce the word \(\listvar{v}\).
    This means the circuit has combinational behaviour despite using sequential
    components; often this is the only way to ensure every function can be
    modelled.
\end{remark}

\begin{example}
    The Belnap interpretation from \cref{ex:belnap-interpretation} is
    functionally complete; for interests of space we postpone the proof for
    \cref{sec:belnap}.
    In essence, this is due to a variation of the standard functional
    completeness method for Boolean values, in which a term in disjunctive
    normal form is created by reading lines off a truth table.
\end{example}

With the knowledge that any monotone function has a corresponding circuit
in \(\scircsigma\), we set about encoding the Mealy function.

\begin{definition}[Monotone completion]
    For lattices \(M, N, P\) such that \(M \subseteq N\), and a monotone
    function \(\morph{f}{M}{P}\), let the \emph{monotone completion} of \(f\) be
    the function \(\morph{f_\mathsf{m}}{N}{P}\) recursively defined as \[
        f_\mathsf{m}(v) = \begin{cases}
            f(v)
            &
            \text{if}\ v \in M
            \\
            \bot
            &
            \text{if}\ v = \bot^m, \bot \not\in M
            \\
            \bigsqcup \{ f_\mathsf{m}(w) \,|\, w \leq_N v \}
            &
            \text{otherwise}
        \end{cases}
    \]
\end{definition}

\begin{definition}[Monotone Mealy encoding]\label{def:mealy-encoding}
    For a monotone Mealy machine \((S, f, s_0)\) with \(k\) states and a
    monotone encoding \(\gamma_\leq\), a \emph{monotone Mealy encoding} is a
    function
    \(
        \morph{
            \gamma_\leq(f)
        }{
            \valuetuple{k} \times \valuetuple{m}
        }{
            \valuetuple{k} \times \valuetuple{n}
        }
    \) defined as the monotone completion of the function \(
        (\gamma_\leq(s), \overline{x})
        \mapsto
            (
                \gamma_\leq(\mealyfunctiontransition{f}(s, \overline{x})),
                \mealyfunctionoutput{f}(s, \overline{x})
            )
    \).
\end{definition}

To be able to obtain the syntactic circuit for a monotone Mealy function encoded
in this way, it needs to be a morphism in \(\funci\)!
It is monotone by definition, but we need to make sure it is also
\(\bot\)-preserving.

\begin{lemma}
    A monotone Mealy encoding is in \(\funci\).
\end{lemma}
\begin{proof}
    A Mealy encoding is monotone as it is a monotone completion.
    There cannot be a state encoded as \(\bot^k\), since at least one bit must
    be \(\top\); this means the monotone completion will send the input
    \(\bot^k \concat \bot^m\) to \(\bot^k \concat \bot^n\): it is
    \(\bot\)-preserving.
\end{proof}

The foundations are now set for establishing the image of a PROP morphism from
Mealy machines to circuit terms.
But before we get too ahead of ourselves, there is one more thing to consider:
\cref{def:encoding} depends on some arbitrary total ordering on the states in a
given monotone Mealy machine.
While this may not seem much of an issue (surely one could simply choose?), when
defining a PROP morphism this must be \emph{fixed}, otherwise a Mealy machine
might be mapped to different circuit morphisms depending on the time of day!

\begin{definition}[Chosen state order]
    Let \((S, f, s_0)\) be a monotone Mealy machine with input space
    \(\valuetuple{m}\), and let \(\leq\) be a total order on \(\values\);
    \(\leq\) can be extended to \(\freemon{(\values^m)}\) using the
    lexicographic order.
    Given a state \(s\), let \(t_{s,\leq} \in \freemon{(\values^m)}\) be
    the minimal element of the subset of words that transition from \(s_0\) to
    \(s\), ordered by \(\leq\).
    Then the \emph{chosen state order} \(\leq_S\) is a total order on \(S\)
    defined as \(s \leq_S s^\prime\) if \(t_{s,\leq} \leq t_{s^\prime,\leq}\).
\end{definition}

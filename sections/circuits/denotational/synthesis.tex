\section{Between circuits and Mealy machines}

We have now established the close links between \(\streami\) and \(\mealyi\).
The main result of this section is to introduce \(\scircsigma\) to the mix.

\subsection{Circuits to monotone Mealy machines}

Circuits have a very natural interpretation as Mealy machines: going from
\(\scircsigma\) to \(\mealyi\) is straightforward since the former is freely
generated.

\begin{definition}
    Let \(\morph{\circuittomealyi}{\scircsigma}{\mealyi}\) be the traced PROP
    morphism defined on the generators as:
    \begin{align*}
        \circuittomealy[
            \iltikzfig{strings/category/f}[box=F,colour=comb]
        ]{\interpretation}
        &\coloneqq \left(\left(\{()\}, \overline{v} \mapsto \left((), {
            \circuittofunc[
                \iltikzfig{strings/category/f}[box=F,colour=comb]
            ]{\interpretation}(\overline{v})
        }\right)\right), ()\right)
        \\[0.1em]
        \circuittomealy[
            \iltikzfig{circuits/components/values/vs}[val=v]
        ]{\interpretation}
        &\coloneqq
        \left(
            \left(
            \{s_v, s_\bot\},
            \{
                s_v \mapsto \left(s_\bot,v\right),
                s_\bot \mapsto \left(s_\bot,\bot\right)
            \}\right),
            s_v
        \right)
        \\[0.1em]
        \circuittomealy[
            \iltikzfig{circuits/components/waveforms/delay}
        ]{\interpretation}
        &\coloneqq
        \left(
            \left(
            \{ s_v \,|\, v \in \values\},
            (s_v, a) \mapsto \left({v,s_a}\right)\right),
            s_\bot
        \right)
    \end{align*}
    \todo[inline]{Fiddle with spacing}
\end{definition}

\todo[inline]{Draw diagrams for values and delays maybe?}

\begin{example}\label{ex:mealy-translation}
    Applying \(\circuittomealy{\belnapinterpretation}\) to the SR NOR latch from
    \cref{ex:latch} produces the monotone Mealy machine in
    \cref{ex:trace-mealy}.
\end{example}

Mealy machines are a reasonable semantics for sequential circuits, but the
image of \(\circuittomealyi\) does not always lead to minimal Mealy machines,
and there are many Mealy machines that may correspond to the same behaviour.
The `purest' semantics of a sequential circuit is a stream function in
\(\streami\).

\begin{definition}
    Let \(\morph{\circuittostreami}{\scircsigma}{\streami}\) be defined as
    \(\mealytostreami \circ \circuittostreami\).
\end{definition}

We have now finally established the \emph{denotation} of a sequential circuit \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=\listvar{m},cod=\listvar{n}]
\): it is the stream function \(
    \morph{\circuittostreami[\iltikzfig{strings/category/f}[box=f,colour=seq]]}{\valuetuplestream{\listvar{m}}}{\valuetuplestream{\listvar{n}}}
\).

\subsection{Monotone Mealy machines to circuits}

So one direction is done; now for the other, which as is often the case is
a bit harder.
For regular Mealy machines, there is a standard procedure in circuit
design~\cite{kohavi2009switching} in which each state of a Mealy machine is
\emph{encoded} as a power of values, and combinational logic used to transform
inputs into appropriate outputs.

\begin{example}
    \todo[inline]{Simple boolean examples}
\end{example}

When considering \emph{monotone} Mealy machines and trying to map into
\(\scircsigma\), this procedure must respect monotonicity as the combinational
logic is constructed using monotone components.
This means that an arbitrary encoding cannot be used; we will now show how to
select a suitable encoding.

\begin{definition}[Encoding]\label{def:encoding}
    Let \(S\) be a set equipped with a partial order \(\stateorder\) and a total
    order \(\leq\) such that \(s_0 \leq s_1 \leq \dots s_{k-1}\).
    The \emph{\(\leq\)-encoding} for this assignment is a function
    \(\morph{\gamma_\leq}{S}{\valuetuple{k}}\) defined as
    \(\gamma_\leq(s)(i) \coloneqq \top\) if \(s_i \stateorder s\) and
    \(\gamma_\leq(s)(i) \coloneqq \bot\) otherwise.
\end{definition}

\begin{example}
    Recall the monotone Mealy machine from \cref{ex:mealy-translation}, which
    has state set \(
        \belnapvalues \coloneqq \{\bot,\belnapfalse,\belnaptrue,\top\}
    \).
    We choose the total order on \(\belnapvalues\) as
    \(\bot \leq \belnapfalse \leq \belnaptrue \leq \top\); subsequently, the
    \(\leq\)-encoding is defined as \(
        \bot \mapsto \top\bot\bot\bot, \belnapfalse \mapsto \top\top\bot\bot,
        \belnaptrue \mapsto \top\bot\top\bot, \top \mapsto \top\top\top\top
    \).
\end{example}

It is essential that a \(\leq\)-encoding respects the original ordering of the
states.

\begin{lemma}
    For an ordered state space \((S,\stateorder)\) and a \(\leq\)-encoding
    \(\gamma_\leq\), \(s \stateorder s^\prime\) if and only if
    \(\gamma_\leq(s) \sqsubseteq \gamma_\leq(s^\prime)\).
\end{lemma}
\begin{proof}
    First the \(\onlyifdir\) direction.
    Let \(s_i \stateorder s_j\); we need to show that for every \(l < k\),
    \(s_i(l) \sqsubseteq s_j(l)\).
    The only way this can be violated is if \(s_i(l) = \top\) and
    \(s_j(l) = \bot\).
    But since \(s_i \stateorder s_j\), if \(s_l \stateorder s_i\) then
    \(s_l \stateorder s_j\) also holds.

    Now the \(\ifdir\) direction.
    Assume that \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\); we need to
    show that \(s_i \stateorder s_j\); i.e.\ that \(\gamma_\leq(s_j)(i) = \top\)
    If \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\), then for each
    \(l < k\) then \(\gamma_\leq(s_i)(l) \sqsubseteq \gamma_\leq(s_j)(l)\);
    in particular \(\gamma_\leq(s_i)(i) \sqsubseteq \gamma_\leq(s_j)(i)\)
    By definition of \(\gamma_\leq\), \(\gamma_\leq(s_i)(i) = \top\), so if
    \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\) then
    \(\gamma_\leq(s_j)(i)\) is also \(\top\).
\end{proof}

Using this encoding, we will construct a combinational circuit morphism that,
when interpreted as a function, implements the output and transition function
of the Mealy machine.
There is no reason for such a morphism to exist for an arbitrary interpretation:
why should we expect some hurriedly slapped together collection of gates to be
able to model every function?
The useful interpretations are those that \emph{can} model every function.

\begin{definition}[Functional completeness]
    An interpretation \(\interpretation\) of a signature \(\signature\) is
    \emph{functionally complete} if there exists a map \(
        \morph{\mealytofunc}{\funci}{\scircsigma}
    \) which sends functions \(
        \morph{f}{\valuetuple{\listvar{m}}}{\valuetuple{\listvar{n}}}
    \), to circuits of the form \(
        \iltikzfig{circuits/synthesis/normalised-function}
    \) for some word \(\listvar{v} \in \freemon{\values}\) such that
    \(\circuittostreami[\mealytofunc[f]](\sigma)(i) = f(\sigma(i))\).
\end{definition}

For a particular interpretation there may well be many such maps from functions
to circuits, but for convenience we will assume there is a fixed procedure
\(\mealytofunc\) amd refer to a circuit \(\mealytofunc[f]\) as the
\emph{normalised circuit for \(f\)}.\

\begin{remark}
    Even though \(\mealytofunc\) concerns combinational functions, it maps into
    the category of \emph{sequential} circuits \(\scircsigma\)!
    This is because sometimes instantaneous values must be used to create the
    normalised circuit.
    However, the loop enforces that the state is \emph{constant}: it will always
    produce the word \(\listvar{v}\).
    This means the circuit has combinational behaviour despite using sequential
    components; often this is the only way to ensure every function can be
    modelled.
\end{remark}

\begin{example}
    The Belnap interpretation from \cref{ex:belnap-interpretation} is
    functionally complete; for interests of space we postpone the proof for
    \cref{sec:belnap}.
    In essence, this is due to a variation of the standard functional
    completeness method for Boolean values, in which a term in disjunctive
    normal form is created by reading lines off a truth table.
\end{example}

With the knowledge that any monotone function has a corresponding circuit
in \(\scircsigma\), we set about encoding the Mealy function.

\begin{definition}[Monotone completion]
    For lattices \(M, N, P\) such that \(M \subseteq N\), and a monotone
    function \(\morph{f}{M}{P}\), let the \emph{monotone completion} of \(f\) be
    the function \(\morph{f_\mathsf{m}}{N}{P}\) recursively defined as \[
        f_\mathsf{m}(v) = \begin{cases}
            f(v)
            &
            \text{if}\ v \in M
            \\
            \bot
            &
            \text{if}\ v = \bot^m, \bot \not\in M
            \\
            \bigsqcup \{ f_\mathsf{m}(w) \,|\, w \leq_N v \}
            &
            \text{otherwise}
        \end{cases}
    \]
\end{definition}

\begin{definition}[Monotone Mealy encoding]\label{def:mealy-encoding}
    For a monotone Mealy machine \((S, f, s_0)\) with \(k\) states and a
    monotone encoding \(\gamma_\leq\), a \emph{monotone Mealy encoding} is a
    function
    \(
        \morph{
            \gamma_\leq(f)
        }{
            \valuetuple{k} \times \valuetuple{m}
        }{
            \valuetuple{k} \times \valuetuple{n}
        }
    \) defined as the monotone completion of the function \(
        (\gamma_\leq(s), \overline{x})
        \mapsto
            (
                \gamma_\leq(\mealyfunctiontransition{f}(s, \overline{x})),
                \mealyfunctionoutput{f}(s, \overline{x})
            )
    \).
\end{definition}

To be able to obtain the syntactic circuit for a monotone Mealy function encoded
in this way, it needs to be a morphism in \(\funci\)!
It is monotone by definition, but we need to make sure it is also
\(\bot\)-preserving.

\begin{lemma}
    A monotone Mealy encoding is in \(\funci\).
\end{lemma}
\begin{proof}
    A Mealy encoding is monotone as it is a monotone completion.
    There cannot be a state encoded as \(\bot^k\), since at least one bit must
    be \(\top\); this means the monotone completion will send the input
    \(\bot^k \concat \bot^m\) to \(\bot^k \concat \bot^n\): it is
    \(\bot\)-preserving.
\end{proof}

The foundations are now set for establishing the image of a PROP morphism from
Mealy machines to circuit terms.
But before we get too ahead of ourselves, there is one more thing to consider:
\cref{def:encoding} depends on some arbitrary total ordering on the states in a
given monotone Mealy machine.
While this may not seem much of an issue (surely one could simply choose?), when
defining a PROP morphism this must be \emph{fixed}, otherwise a Mealy machine
might be mapped to different circuit morphisms depending on the time of day!

\begin{definition}[Chosen state order]
    Let \((S, f, s_0)\) be a monotone Mealy machine with input space
    \(\valuetuple{m}\), and let \(\leq\) be a total order on \(\values\);
    \(\leq\) can be extended to \(\freemon{(\values^m)}\) using the
    lexicographic order.
    Given a state \(s\), let \(t_{s,\leq} \in \freemon{(\values^m)}\) be
    the minimal element of the subset of words that transition from \(s_0\) to
    \(s\), ordered by \(\leq\).
    Then the \emph{chosen state order} \(\leq_S\) is a total order on \(S\)
    defined as \(s \leq_S s^\prime\) if \(t_{s,\leq} \leq t_{s^\prime,\leq}\).
\end{definition}

The PROP morphism from monotone Mealy machines to circuits can then be
parameterised by some ordering on the set of values \(\values\), ensuring that
there is a canonical term in \(\scircsigma\) for each monotone Mealy machine.

\begin{definition}\label{def:mealy-to-circuit}
    For a functionally complete interpretation \(\interpretation\) and total
    order \(\leq\) on \(\values\), let \(
        \morph{
            \mealytocircuiti
        }{
            \mealyi
        }{
            \scircsigma
        }
    \) be the traced PROP morphism with action defined for a monotone Mealy
    machine \((S,f,s)\) as producing \(
        \iltikzfig{circuits/synthesis/mealy-term}
    \).
\end{definition}

Before proceeding to the result that this PROP morphism is behaviour-preserving,
we must show a lemma linking the behaviour circuits in the image of
\(\mealytocircuiti\) to initial outputs and stream derivatives.

\begin{proposition}
    \label{prop:mealy-form-image}
    Given a combinational circuit \(
        \iltikzfig{strings/category/f-2-2}[box=\hat{F},dom1=x,dom2=m,cod1=x,cod2=n,colour=comb]
    \), let \(f\) be the map with action \(
        (\listvar{s}) \mapsto
            \circuittostreami[
                \iltikzfig{circuits/productivity/mealy-form}[core=\hat{F},state=\listvar{s},dom=m,cod=n,delay=x]
            ]
    \) and let \(
        \hat{f}
        :=
        \circuittofunci[
            \iltikzfig{strings/category/f-2-2}[box=\hat{F},colour=comb]
        ]
    \).
    Then, \(
        \mealyoutput{f(\listvar{s})}{\listvar{a}}
        =
        \proj{1}(\hat{f}(\listvar{s}, \listvar{a}))
    \) and \(
        \mealytransition{f(\listvar{s})}{\listvar{a}}
        =
        f(\proj{0}(\hat{f}(\listvar{s}, \listvar{a})))
    \).
\end{proposition}
\begin{proof}
    None of the traced inputs affect the outputs at the
    current cycle, so the initial output is trivial.
    The least fixpoint is reached immediately as \(
        \mu_a := \proj{0}(\hat{f}(\listvar{s}, \listvar{a}))
    \) and the traced input is captured by the delay, so the derivative
    will indeed be \(f(\mu_a)\).
\end{proof}

Now we can show the behaviour-preserving result.

\begin{theorem}\label{thm:mealy-to-circuit}
    \(
        \mealytostream = \circuittostreami \circ \mealytocircuiti
    \).
\end{theorem}
\begin{proof}
    For fixed state set \(S\) and Mealy function \(g\), let
    \(h := (s) \mapsto \mealytostreami[(S, g, s)]\) and \(
        h^\prime := (s) \mapsto \circuittostreami[\mealytocircuiti[(S, g, s)]]
    \).
    We will show that for a state \(s \in S\), there is a bisimulation
    between \(h(s)\) and \(h^\prime(s)\).

    We can transform \(h^\prime(s)\) into a circuit of the form in
    \cref{prop:mealy-form-image} by concatenating the values created by
    \(\mealytofunc\) to the encoded state using axioms of STMCs.
    Then, by finality of \(\mealytostreami\), \cref{def:mealy-to-circuit} and
    \cref{prop:mealy-form-image}, these stream functions both have initial output \(
        \proj{1}(g(s, \listvar{a}))
    \).
    The former has \(
        \streamderivative{h(s)}{\listvar{a}} = h(\proj{0}(g(s, \listvar{a})))
    \) and the latter has \(
        \streamderivative{h^\prime(s)}{\listvar{a}} =
            \gamma(\proj{0}(g(s, \listvar{a})) =
            h^\prime(\proj{0}(g(s, \listvar{a})))
    \).
    As \(h(s)\) and \(h^\prime(s)\) are defined on all states,
    \(\mealytostreami[(S, g, s)]\) and
    \(\circuittostreami[\mealytocircuiti[(S, g, s)]]\) are equal for any Mealy
    machine \((S, g, s)\).
\end{proof}


This brings our foray into Mealy machines to a close: we can translate back and
forth between circuits and \emph{monotone} Mealy machines without fear of
altering their behaviour in terms of their stream functions.

This already is quite nice to have; if we only know the specification of a
circuit in terms of a (monotone) Mealy machine, we can use the PROP morphism
\(\mealytocircuiti\) to generate a circuit rather than attempting to blindly
construct one from primitive logical

Our work is not done yet though: these results on Mealy machines only set the
stage for the final result of this chapter: the completeness of
the denotational semantics.
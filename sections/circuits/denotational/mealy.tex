\section{Monotone Mealy machines}

It is not immediately obvious how to translate back from stream functions in
\(\streami\) to circuits in \(\scircsigma\).
Even though these stream functions have finitely many stream derivatives, how
does one encapsulate this behaviour into a circuit made from finitely many
components while taking into account inputs and state?
Fortunately, we have a secret weapon; the old chestnut that is the
\emph{Mealy machine}~\cite{mealy1955method}.
Working tirelessly in industry as a way of specifying the behaviour of a
circuit without restricting to particular circuitry, Mealy machines also have
a very useful \emph{coalgebraic} viewpoint which we will wield in order to
build a bridge from circuits into stream functions: there is a unique
homomorphism from a Mealy machine to a causal, finitely specified stream
function.

We will do this by assembling a special class of Mealy machines which we dub
\emph{monotone Mealy machines} into another traced PROP.
By constructing PROP morphisms between these two categories that preserve
behaviour of stream functions, we establish that we can work with either
circuit representation.

\begin{definition}[Mealy machine~\cite{mealy1955method}]\label{def:mealy}
    Let \(A\) and \(B\) be finite sets.
    A (finite) \((A,B)\)-\emph{Mealy machine} is a tuple \((S, f)\) where
    \(S\) is a finite set called the \emph{state space},
    \(\morph{f}{S}{(S \times B)^A}\) is the \emph{Mealy function}.
\end{definition}

An \((M,N\)-Mealy machine is parameterised over a set \(A\) of \emph{inputs} and
a set \(B\) of \emph{outputs}.
Each Mealy machine then has a set \(S\) of \emph{states}; the Mealy function
takes in a currrent state and input \((s, a)\) and produces a pair
\(\langle{s^\prime, b}\rangle\) of a transition and output.

\begin{notation}
    We will use the shorthand \(
    \mealyfunctiontransition{f} \coloneqq (s, a) \mapsto \proj{0}(f(s)(a))
\) and \(
    \mealyfunctionoutput{f} \coloneqq (s, a) \mapsto \proj{1}(f(s)(a))
\) for the transition and output component of the Mealy function respectively.
\end{notation}

\begin{example}
    \todo[inline]{Example!}
\end{example}

\subsection{The coalgebraic perspective}

The definition of Mealy machine above is timeless and forms the basis for most
of modern electronics.
Of course, the natural question for the categorist to ask is
\emph{can we make it more categorical?}
And as is often the case, we can, using the notion of a \emph{coalgebra}.

\begin{definition}[Coalgebra]
    Let \(\mcc\) and \(\mcd\) be categories, and let \(\morph{F}{\mcc}{\mcc}\)
    be an endofunctor.
    A \emph{coalgebra} for \(F\), or \(F\)-coalgebra, is an object
    \(A \in \mcc\) along with a morphism \(\morph{\alpha}{A}{FA} \in \mcc\),
    usually written \((A,\alpha)\).
\end{definition}

The light bulb should already have lit up: a Mealy machine is a pair of a set
and a function, so this is clearly a coalgebra in \(\set\).

\begin{definition}
    An \emph{\((A,B)\)-Mealy coalgebra} is a coalgebra of the functor
    \(\morph{Y}{\set}{\set}\) defined as \(S \mapsto (S \times B)^A\).
\end{definition}

\begin{example}
    In \cite{bonsangue2008coalgebraic}, the notation \(
        f(s)(a) = \langle{\initialoutput{s}{a},\streamderivative{s}{a}}\rangle
    \) is used to describe the Mealy function, which coincides with the notation
    used for stream functions; this is not a coincidence!

    Given sets \(A\) and \(B\), let \(\Gamma\) be the set of causal stream
    functions \(\stream{A} \to \stream{B}\), and let
    \(\morph{\nu}{\Gamma}{\Gamma \times B}^A\) be the function defined as \(
        (f, a) \mapsto \langle{\initialoutput{s}{a},\streamderivative{s}{a}}\rangle
    \).
    Then \((\Gamma,\nu)\) is a \((A,B)\)-Mealy coalgebra.
\end{example}

The above example is incredibly important, as it lays the groundwork we will
use extensively to establish connections between circuits, stream functions and
Mealy machines.
If we inspect it a little closer, we find that stream functions are even more
special than just being `a' \((A,B)\)-Mealy coalgebra.

\begin{definition}[Mealy homomorphism]
    For sets \(A\) and \(B\), an \emph{\(A,B\)-Mealy homomorphism} between two
    \((A,B)\)-Mealy coalgebra \((S,f)\) and \((T,g)\) is a function
    \(\morph{h}{S}{T}\) preserving transitions and
    outputs, i.e.\ for a Mealy function \(f\), a Mealy homomorphism \(h\)
    satisfies \(
        h\left(\mealyfunctiontransition{f}(s, a)\right)
        =
        \mealyfunctiontransition{f}(h(s), a)
    \) and \(
        h\left(\mealyfunctionoutput{f}(s, a)\right)
        =
        \mealyfunctionoutput{f}(s, a)
    \).
\end{definition}

The \emph{final} \((M,N)\)-Mealy coalgebra is a \((M,N)\)-Mealy coalgebra to
which every other \((M,N)\)-Mealy coalgebra has a unique homomorphism to.

\begin{remark}
    The coalgebra crowd tend to prefer the use of the word \emph{final} over
    \emph{terminal}; one could quite reasonably call the final coalgebra a
    terminal coalgebra and everything would be alright, but you might get a few
    funny looks.
\end{remark}

\begin{proposition}[\cite{rutten2006algebraic}, Prop. 2.2]
    \label{prop:final-coalgebra}
    For every \((A,B)\)-Mealy coalgebra \((S,f)\), there exists a
    unique \((A,B)\)-Mealy homomorphism \(\morph{{!}}{(S,f)}{(\Gamma,\nu)}\).
\end{proposition}
\begin{proof}
    An \((A,B)\)-Mealy homomorphism \(\morph{g}{(S, f)}{(\Gamma, \nu)}\) is a
    function \(S \to \Gamma\), so for a state \(s_0 \in S\), \(g(s)\) will be a
    stream function \(\stream{A} \to \stream{B}\).
    Let \(\sigma \in \stream{A}\) be an input stream; there is a (unique) series
    of transitions \[
        s_0
        \mealyarrow{\sigma(0)}{b_0}
        s_1
        \mealyarrow{\sigma(1)}{b_1}
        s_2
        \mealyarrow{\sigma(2)}{b_2}
        s_3
        \mealyarrow{\sigma(3)}{b_3}
        \cdots
    \]
    The stream function \(!(s)\) is defined for input \(\sigma\) and
    index \(i \in \nat\) as \(!(s)(\sigma)(i) \coloneqq b_i\).
\end{proof}

For a Mealy coalgebra \((S, f)\) and a start state \(s_0\),
\(!(s)(\sigma)\) maps to the stream of outputs that \((S, f)\) would produce
by applying \(f\) to each element of \(\sigma\), starting from \(s_0\).

When viewed through this perspective, stream functions are nothing more than the
states in another Mealy machine.
However, this is not just any Mealy machine, it is the \emph{minimal} Mealy
machine with the same behaviour as \((S, f)\).

\subsection{Circuits as Mealy machines}

The fact that causal stream functions are the final Mealy coalgebra is the
ingredient that will help us build a bridge between circuits in \(\scircsigma\)
and stream functions in \(\streami\).
The crucial step is to now assemble Mealy machines into another traced PROP
and define PROP morphisms between all three categories in play.

However, not all Mealy machines defined thus far correspond to circuits in
\(\scircsigma\).
As with stream functions, we must refine our notion of Mealy machine in
order to find those that do.
There is an easy check for this: a Mealy machine \((S, f)\) with start state
\(s_0\) specifies the behaviour of a circuit in \(\scircsigma\) if the
stream function \(!(s_0)\) is in \(\streami\).

As established, all stream functions in the image of \(!\) are causal, and since
we only work with \emph{finite} Mealy machines we can also conclude the
following:

\begin{lemma}
    Given a Mealy machine \((S, f)\) and start state \(s_0 \in S\), \(!(s_0)\)
    is finitely specified.
\end{lemma}
\begin{proof}
    \(S\) is finite, and \(\mealytostream\) must preserve transitions.
\end{proof}

Monotonicity is a little less straightforward.
One could set the input, output and state sets to all be posets, and use the
usual definition of monotonicity that way.
However, this overcomplicates things: since each Mealy coalgebra has a
corresponding stream function, we can appeal to this rather than having to
manually order the state set.

First an ordering on stream \emph{functions} is required.

\begin{definition}
    Let \(A\) and \(B\) be posets.
    For stream functions \(\morph{f,g}{\stream{A}}{\stream{B}}\), we say that
    \(f \stateorder g\) if, for all \(\sigma \in \stream{A}\),
    \(f(\sigma) \leq_{\stream{B}}\).
\end{definition}

\begin{definition}[State order]
    Let \(A\) and \(B\) posets.
    For an \((A,B)\)-Mealy machine \((S, f)\) and states \(s,s^\prime \in S\)
    we say that \(s \stateorder s^\prime\) if \(!(s) \stateorder !(s^\prime)\).
\end{definition}

With an ordering on the states of a Mealy machine, monotonicity quickly follows.

\begin{definition}[Monotone Mealy machine]
    Let \(A\) and \(B\) be posets; an \((A,B)\)-Mealy machine is called a
    \emph{monotone} Mealy machine if \(f\) is monotone with respect to the
    appropriate orders.
\end{definition}

This establishes the properties of Mealy machines required to model circuits.
To map to Mealy machines from circuits we need to assemble them into another
PROP, in which the morphisms \(\listvar{m} \to \listvar{n}\) are
\((\valuetuple{m},\valuetuple{n})\)-Mealy machines.
There is one nuance to consider: circuits in \(\scircsigma\) have a `hardcoded'
initial state in the form of the value generators, whereas the Mealy machines
as presented do not have a designated start state per se.
This means that as well as a Mealy machine, each morphism will need to be
equipped with such a start state.

All that remains to define is the composition of Mealy machines, which is
standard.

\begin{definition}[Cascade product~\cite{ginzburg2014algebraic}]
    Given an \((A,B)\)-Mealy machine \((S,f)\) with start state \(s_0\) and
    an \((B,C)\)-Mealy machine \((T,g)\) with state state \((t_0)\), their
    \emph{cascade product} is an \((A,C)\)-Mealy machine defined as \[
        (S \times T, ((s, t), a) \mapsto ((
            \mealyfunctiontransition{f}(s,a),
            \mealyfunctiontransition{g}(t, \mealyfunctionoutput{f}(s, a))
        ),
            \mealyfunctionoutput{g}(t, \mealyfunctionoutput{f}(s, a))
        )).
    \] with start state \((s_0, t_0)\).
\end{definition}

The cascade product of two Mealy machines effectively executes the first on the
inputs, then executes the second on the outputs of the first; the inputs are
`cascaded' through the two Mealy machines.

\begin{example}
    \todo[inline]{Example!}
\end{example}

Tensor product is far more straightforward: it is the direct product of states
and functions.

\begin{definition}
    Let \(\mealyi\) be the PROP in which each morphism
    \(\listvar{m} \to \listvar{n}\) is a pair of a monotone
    \(\valuetuple{\listvar{m}}, \valuetuple{\listvar{n}}\)-Mealy machine
    \((S, f)\) along with a start state \(s_0 \in S\).
    Composition is by cascade product and tensor on morphisms is by
    direct product.
    The identity and the symmetry are the single-state machines that output the
    input and swap the inputs respectively.
\end{definition}

Once again, we must show that this category has a trace.
This can be computed in much the same way as it was for stream functions.

\begin{definition}
    Let \((S, f)\) be a monotone \(
        (\valuetuple{\listvar{xm}}, \valuetuple{\listvar{xn}})
    \)-Mealy machine.
    For a state \(s \in S\) and input \(\listvar{a} \in \listvar{m}\), let
    \(\mu_{s,\listvar{a}}\) be the least fixpoint of \(
        \listvar{r} \mapsto \proj{0}\left(f\left(s, \listvar{ra}\right)\right)
    \).
    The \emph{least fixed point} of \((S, f)\) with start state \(s_0\) is a \(
        (\valuetuple{\listvar{m}}, \valuetuple{\listvar{n}})
    \)-Mealy machine \(
        (S, (s, \listvar{a}) \mapsto f((\mu_{s,\listvar{a}})\listvar{a}))
    \) with start state \(s_0\).
\end{definition}

\begin{proposition}
    The least fixed point is a trace on \(\mealyi\).
\end{proposition}
\begin{proof}
    Let \((S, f)\) be a monotone
    \((\valuetuple{\listvar{xm}}, \valuetuple{\listvar{xn}})\)-Mealy machine.
    Since \(\morph{f}{S \times \listvar{xm}}{S \times \listvar{xn}}\) is
    monotone with regards to the orders on \(S\) and
    \(\valuetuple{\listvar{xm}}\) and \(S \times \listvar{xn}\) is finite, it
    has a least fixed point.
    The function \(
        f^\prime \coloneqq (s, \listvar{a})
        \mapsto
        \proj{1}\left(f((\mu_{s,\listvar{a}})\listvar{a})\right)
    \) is a composition of monotone functions, so it is itself monotone.
    This means \((S, f^\prime)\) is a monotone \(
        (\valuetuple{\listvar{m}}, \valuetuple{\listvar{n}})
    \)-Mealy machine.
    This construction is a trace for the same reason as the trace of
    \(\streami\) is.
\end{proof}

\begin{example}\label{ex:trace-mealy}
    Consider the monotone \((\valuetuple{3},\valuetuple{3})\)-Mealy machine with
    state set \(\belnapvalues\), initial state \(\bot\), and Mealy function \[
        g \coloneqq (s, (v, u, w))
        \mapsto \left\langle
                \neg(u \land v),
                (\neg(s \land w), \neg(u \land v), \neg(s \land w))
        \right\rangle
    ).\]
    To take the trace of this machine, we must first compute the least fixed
    point of \(v \mapsto \neg(s \land w)\), which is clearly just
    \(\neg(s \land w)\).
    Therefore the Mealy function of the traced
    \((\valuetuple{2}, \valuetuple{2})\) machine is \(
        (s, (u, w)) \mapsto g(s, (\neg(s \land w), u, w))
    \).
\end{example}

With monotone Mealy machines in a PROP, we can now represent the unique
homomorphism from a Mealy machine to a set of state functions as a PROP
morphism.

\begin{proposition}
    There is a traced PROP morphism
    \(\morph{\mealytostreami}{\mealyi}{\streami}\) sending a monotone Mealy
    machine \(\left((S, f), s_0\right)\) to \(!(s_0)\), where \(!\) is the
    unique homomorphism \((S,f) \to (\Gamma,\nu)\).
\end{proposition}

We can now interpret both circuits in \(\scircsigma\) and monotone Mealy
machines in \(\mealyi\) as stream functions in \(\streami\).
In essence, given one of these structures, we can determine its \emph{behaviour}
as a stream function.
What is missing, of course, is the links between them.

\section{Between circuits and Mealy machines}

The main result of this section is to establish the links between circuits
and Mealy machines, and use this as a tool to help us assert the completeness of
the denotational semantics.
To do this, we must define PROP morphisms between \(\scircsigma\) and
\(\mealyi\).

Going from \(\scircsigma\) to \(\mealyi\) is straightforward since the former
is freely generated.

\begin{definition}
    Let \(\morph{\circuittomealyi}{\scircsigma}{\mealyi}\) be the traced PROP
    morphism defined on the generators as:
    \begin{align*}
        \circuittomealy[
            \iltikzfig{strings/category/f}[box=F,colour=comb]
        ]{\interpretation}
        &\coloneqq \left(\left(\{()\}, \overline{v} \mapsto \left((), {
            \circuittofunc[
                \iltikzfig{strings/category/f}[box=F,colour=comb]
            ]{\interpretation}(\overline{v})
        }\right)\right), ()\right)
        \\[0.1em]
        \circuittomealy[
            \iltikzfig{circuits/components/values/vs}[val=v]
        ]{\interpretation}
        &\coloneqq
        \left(
            \left(
            \{s_v, s_\bot\},
            \{
                s_v \mapsto \left(s_\bot,v\right),
                s_\bot \mapsto \left(s_\bot,\bot\right)
            \}\right),
            s_v
        \right)
        \\[0.1em]
        \circuittomealy[
            \iltikzfig{circuits/components/waveforms/delay}
        ]{\interpretation}
        &\coloneqq
        \left(
            \left(
            \{ s_v \,|\, v \in \values\},
            (s_v, a) \mapsto \left({v,s_a}\right)\right),
            s_\bot
        \right)
    \end{align*}
    \todo[inline]{Fiddle with spacing}
\end{definition}

\todo[inline]{Draw diagrams for values and delays maybe?}

\begin{example}\label{ex:mealy-translation}
    Applying \(\circuittomealy{\belnapinterpretation}\) to the SR NOR latch from
    \cref{ex:latch} produces the monotone Mealy machine in
    \cref{ex:trace-mealy}.
\end{example}

To check that this is the `correct' translation, it must
\emph{preserve behaviour}: that is to say, if for a sequential circuit \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=m,cod=n]
\), \(
    \circuittostreami[
        \iltikzfig{strings/category/f}[box=f,colour=seq]
    ]
\) is a stream function \(f\), then \(
    \mealytostreami[
        \circuittomealyi[
            \iltikzfig{strings/category/f}[box=f,colour=seq]
        ]
    ]
\) must be the same stream function \(f\).

\begin{theorem}\label{thm:mealy-preserves-behaviour}
    \(
        \circuittostream{\interpretation}
        =
        \mealytostream \circ \circuittomealy{\interpretation}
    \).
\end{theorem}
\begin{proof}
    Since morphisms of \(\mealyi\) and \(\streami\) are both Mealy
    coalgebras, we just need to check that the transitions and outputs of the
    image of \(\circuittomealyi\) and \(\circuittostreami\) agree.
\end{proof}

So one direction is done; now for the other, which as is often the case is
a bit harder.
For regular Mealy machines, there is a standard procedure in circuit
design~\cite{kohavi2009switching} in which each state of a Mealy machine is
\emph{encoded} as a power of values, and combinational logic used to transform
inputs into appropriate outputs.

\begin{example}
    \todo[inline]{Simple boolean examples}
\end{example}

When considering \emph{monotone} Mealy machines and trying to map into
\(\scircsigma\), this procedure must respect monotonicity as the combinational
logic is constructed using monotone components.
This means that an arbitrary encoding cannot be used; we will now show how to
select a suitable encoding.

\begin{definition}
    Let \(S\) be a set equipped with a partial order \(\stateorder\) and a total
    order \(\leq\) such that \(s_0 \leq s_1 \leq \dots s_{k-1}\).
    The \emph{\(\leq\)-encoding} for this assignment is a function
    \(\morph{\gamma_\leq}{S}{\valuetuple{k}}\) defined as
    \(\gamma_\leq(s)(i) \coloneqq \top\) if \(s_i \stateorder s\) and
    \(\gamma_\leq(s)(i) \coloneqq \bot\) otherwise.
\end{definition}

\begin{example}
    Recall the monotone Mealy machine from \cref{ex:mealy-translation}, which
    has state set \(
        \belnapvalues \coloneqq \{\bot,\belnapfalse,\belnaptrue,\top\}
    \).
    We choose the total order on \(\belnapvalues\) as
    \(\bot \leq \belnapfalse \leq \belnaptrue \leq \top\); subsequently, the
    \(\leq\)-encoding is defined as \(
        \bot \mapsto \top\bot\bot\bot, \belnapfalse \mapsto \top\top\bot\bot,
        \belnaptrue \mapsto \top\bot\top\bot, \top \mapsto \top\top\top\top
    \).
\end{example}

It is essential that a \(\leq\)-encoding respects the original ordering of the
states.

\begin{lemma}
    For an ordered state space \((S,\stateorder)\) and a \(\leq\)-encoding
    \(\gamma_\leq\), \(s \stateorder s^\prime\) if and only if
    \(\gamma_\leq(s) \sqsubseteq \gamma_\leq(s^\prime)\).
\end{lemma}
\begin{proof}
    First the \(\onlyifdir\) direction.
    Let \(s_i \stateorder s_j\); we need to show that for every \(l < k\),
    \(s_i(l) \sqsubseteq s_j(l)\).
    The only way this can be violated is if \(s_i(l) = \top\) and
    \(s_j(l) = \bot\).
    But since \(s_i \stateorder s_j\), if \(s_l \stateorder s_i\) then
    \(s_l \stateorder s_j\) also holds.

    Now the \(\ifdir\) direction.
    Assume that \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\); we need to
    show that \(s_i \stateorder s_j\); i.e.\ that \(\gamma_\leq(s_j)(i) = \top\)
    If \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\), then for each
    \(l < k\) then \(\gamma_\leq(s_i)(l) \sqsubseteq \gamma_\leq(s_j)(l)\);
    in particular \(\gamma_\leq(s_i)(i) \sqsubseteq \gamma_\leq(s_j)(i)\)
    By definition of \(\gamma_\leq\), \(\gamma_\leq(s_i)(i) = \top\), so if
    \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\) then
    \(\gamma_\leq(s_j)(i)\) is also \(\top\).
\end{proof}

Using this encoding, we will construct a combinational circuit morphism that,
when interpreted as a function, implements the output and transition function
of the Mealy machine.
There is no reason for such a morphism to exist for an arbitrary interpretation:
why should we expect some hurriedly slapped together collection of gates to be
able to model every function?
The useful interpretations are those that \emph{can} model every function.

\begin{definition}[Functional completeness]
    An interpretation \(\interpretation\) of a signature \(\signature\) is
    \emph{functionally complete} if there exists a map \(
        \morph{\mealytofunc}{\funci}{\scircsigma}
    \) which sends functions \(
        \morph{f}{\valuetuple{\listvar{m}}}{\valuetuple{\listvar{n}}}
    \), to circuits of the form \(
        \iltikzfig{circuits/synthesis/normalised-function}
    \) for some word \(\listvar{v} \in \freemon{\values}\) such that
    \(\circuittostreami[\mealytofunc[f]](\sigma)(i) = f(\sigma(i))\).
\end{definition}

For a particular interpretation there may well be many such maps from functions
to circuits, but for convenience we will assume there is a fixed procedure
\(\mealytofunc\) amd refer to a circuit \(\mealytofunc[f]\) as the
\emph{normalised circuit for \(f\)}.\

\begin{remark}
    Even though \(\mealytofunc\) concerns combinational functions, it maps into
    the category of \emph{sequential} circuits \(\scircsigma\)!
    This is because sometimes instantaneous values must be used to create the
    normalised circuit.
    Despite this, the semantics of the circuit are still combinational since the
    loop enforces that the state is \emph{constant}: it will always produce the
    word \(\listvar{v}\).
    This means the circuit has combinational behaviour despite using sequential
    components; often this is the only way to ensure every function can be
    modelled.
\end{remark}

\begin{example}
    The Belnap interpretation from \cref{ex:belnap-interpretation} is
    functionally complete; for interests of space we postpone the proof for
    \cref{sec:belnap}.
\end{example}

\section{Terms}

Processes are modelled as \emph{terms}.
Before we can begin, the components that make up processes in a given system
must be specified.

\begin{notation}[Lists]
    Given a set \(X\), the set of lists of elements of \(X\) is denoted
    \(\freemon{X}\).
    Lists are written \([x_0, x_1, x_2, \cdots, x_{n-1}]\); the brackets around
    single element lists may be dropped when clear from context \(x := [x]\);
    and variables representing arbitrary lists are generally written with an
    overline \(
        \listvar{x}, \listvar{y}, \listvar{z}... \in \freemon{X}
    \).
    Given two lists \(\listvar{x}, \listvar{y}\), their concatenation is
    denoted \(\listvar{xy}\).
    The list of length \(n\) containing just element \(x\) is written \(x^n\).
    Given a list \(\listvar{x}\), its \emph{length} is denoted
    \(\wordlen{\listvar{x}}\); for \(i < \wordlen{\listvar{x}}\), its
    \(i\)\emph{th element} is denoted \(\listvar{x}(i)\); and its
    \emph{sum}, denoted \(\wordsum{\listvar{x}}\), is computed as
    \(\Sigma_{i < |\listvar{m}|}\listvar{m}(i)\).
\end{notation}

\begin{notation}
    Let \(\natplus\) be the set of non-zero natural numbers.
\end{notation}

\begin{definition}[Generators]
    A set of \emph{generators} is a set \(\generators\) equipped with two
    functions \(\morph{\domw,\codw}{\generators}{\natplus^\star}\).
\end{definition}

Generators are the primitive building blocks of terms: their domains and
codomains specify the widths of their input and output wires respectively.
Terms are defined by combining these primitives together.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of generators.
    A \(\generators\)-term is written \(\morph{f}{\listvar{m}}{\listvar{n}}\)
    where \(\listvar{m}, \listvar{n} \in \natplus^\star\).
    The set of \(\generators\)-terms, denoted \(\sigmaterms\), is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\domw[\phi]}{\codw[\phi]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[\overline{n}]}{\overline{n}}{\overline{n}} \in \sigmaterms\)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(
                \morph{\swap{\overline{m}}{\overline{n}}}{\overline{mn}}{\overline{nm}} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(
                \morph{\bundleexpand{\listvar{n}}}{\listvar{n}}{1^{\wordsum{\listvar{n}}}} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(
                \morph{\bundlecontract{\listvar{n}}}{1^{\wordsum{\listvar{n}}}}{\listvar{n}} \in \sigmaterms
            \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\listvar{m}}{\listvar{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\listvar{n}}{\listvar{p}} \in \sigmaterms\)}
            \BinaryInfC{\(\morph{f \seq g}{\listvar{m}}{\listvar{p}} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\listvar{m}}{\listvar{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\listvar{p}}{\listvar{q}} \in \sigmaterms\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{\listvar{mp}}{\listvar{nq}} \in \sigmaterms
            \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms are constructed recursively.
There are four base cases: a generator from \(\generators\) with appropriate
inputs and outputs;
an \emph{identity} for empty wires with no generators;
a \emph{symmetry} for swapping over two wires;
a \emph{splitter} for transforming a list of `thicker' wires into a list of
`thin' one-bit wires, and a \emph{combiner} for the reverse operation.
The two inductive cases are called \emph{composition} and \emph{tensor}
respectively.
Intuitively, these can be thought of generating larger terms by sequencing
subterms in sequence or parallel.

\(\Sigma\)-terms will be abbreviated to `terms' when the signature is clear from
context.
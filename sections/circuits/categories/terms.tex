\section{Terms}

Processes are modelled as \emph{terms}.
Before we can begin, the components that make up processes in a given system
must be sepcified.

\begin{notation}[List, sum]
    Given a set \(X\), the set of lists of elements of \(X\) is denoted
    \(\freemon{X}\).
    Words are written \([x_0, x_1, x_2, \cdots, x_{n-1}]\); the brackets around
    single element lists may be dropped when clear from context \(x := [x]\);
    and variables representing arbitrary lists are generally written with an
    overline \(
        \overline{x}, \overline{y}, \overline{z}... \in \freemon{X}
    \).
    Given two words \(\overline{x}, \overline{y}\), their concatenation is
    denoted \(\overline{x}\overline{y}\).
    The list of length \(n\) containing just element \(x\) is written \(x^n\).
    Given a list \(\overline{x}\), its \emph{length} is denoted
    \(\wordlen{\overline{x}}\); for \(i < \wordlen{\overline{x}}\), its
    \(i\)\emph{th element} is denoted \(\overline{x}(i)\); and its
    \emph{sum}, denoted \(\wordsum{\overline{x}}\), is computed as
    \(\Sigma_{i < |\overline{m}|}\overline{m}(i)\).
\end{notation}

\begin{notation}
    Let \(\natplus\) be the set of non-zero natural numbers.
\end{notation}

\begin{definition}[Generators]
    A set of \emph{generators} is a set \(\generators\) equipped with two
    functions \(\morph{\domw,\codw}{\generators}{\natplus^\star}\).
\end{definition}

Generators are the primitive building blocks of terms: their domains and
codomains specify the widths of their input and output wires respectively.
Terms are defined by combining these primitives together.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of generators.
    A \(\generators\)-term is written \(\morph{f}{\overline{m}}{\overline{n}}\)
    where \(\overline{m}, \overline{n} \in \natplus^\star\).
    The set of \(\generators\)-terms, denoted \(\sigmaterms\), is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\domw[\phi]}{\codw[\phi]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[n]}{[n]}{[n]} \in \sigmaterms\)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(
                \morph{\swap{m}{n}}{[m,n]}{[n,m]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\wordsum{\overline{m}} = \wordsum{\overline{n}}\)}
            \UnaryInfC{\(
                \morph{\bundle{\overline{m}}{\overline{n}}}{\overline{m}}{\overline{n}} \in \sigmaterms
            \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{n}}{\overline{p}} \in \sigmaterms\)}
            \BinaryInfC{\(\morph{f \seq g}{\overline{m}}{\overline{p}} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{p}}{\overline{q}} \in \sigmaterms\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{\overline{mp}}{\overline{nq}} \in \sigmaterms
            \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms are constructed recursively.
There are four base cases: a generator from \(\generators\) with appropriate
inputs and outputs;
an \emph{identity} for empty wires with no generators;
a \emph{symmetry} for swapping over two wires;
and a \emph{bundler} for reorganising lists of wires.
The two inductive cases are called \emph{composition} and \emph{tensor}
respectively.
Intuitively, these can be thought of generating larger terms by sequencing
subterms in sequence or parallel.

\(\Sigma\)-terms will be abbreviated to `terms' when the signature is clear from
context.
\section{Terms}

Processes are modelled as \emph{terms}.
Before we can begin, the components that make up processes in a given system
must be specified.

\begin{notation}[Lists]
    Given a set \(X\), the set of lists of elements of \(X\) is denoted
    \(\freemon{X}\).
    Lists are written \([x_0, x_1, x_2, \cdots, x_{n-1}]\); the brackets around
    single element lists may be dropped when clear from context \(x := [x]\);
    and variables representing arbitrary lists are generally written with an
    overline \(
        \listvar{x}, \listvar{y}, \listvar{z}... \in \freemon{X}
    \).
    Given two lists \(\listvar{x}, \listvar{y}\), their concatenation is
    denoted \(\listvar{xy}\).
    The list of length \(n\) containing just element \(x\) is written \(x^n\).
    Given a list \(\listvar{x}\), its \emph{length} is denoted
    \(\wordlen{\listvar{x}}\); for \(i < \wordlen{\listvar{x}}\) and its
    \(i\)\emph{th element} is denoted \(\listvar{x}(i)\).
\end{notation}

\begin{notation}
    Let \(\natplus\) be the set of non-zero natural numbers.
\end{notation}

\begin{definition}[Generators]
    A set of \emph{generators} is a set \(\generators\) equipped with two
    functions \(\morph{\domw,\codw}{\generators}{\natplus^\star}\).
\end{definition}

Generators are the primitive building blocks of terms: their domains and
codomains specify the widths of their input and output wires respectively.
Terms are defined by combining these primitives together.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of generators.
    A \(\generators\)-term is written \(\morph{f}{\listvar{m}}{\listvar{n}}\)
    where \(\listvar{m}, \listvar{n} \in \natplus^\star\).
    The set of \(\generators\)-terms, denoted \(\sigmaterms\), is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\domw[\phi]}{\codw[\phi]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(n \in \natplus\)}
            \UnaryInfC{\(\morph{\id[n]}{[n]}{[n]} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[0]}{\varepsilon}{\varepsilon} \in \sigmaterms\)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(
                \morph{\swap{m}{n}}{[m,n]}{[n,m]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(
                \morph{\bundleexpand{m}}{[m]}{1^m} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(
                \morph{\bundlecontract{n}}{1^n}{[n]} \in \sigmaterms
            \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\listvar{m}}{\listvar{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\listvar{n}}{\listvar{p}} \in \sigmaterms\)}
            \BinaryInfC{\(\morph{f \seq g}{\listvar{m}}{\listvar{p}} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\listvar{m}}{\listvar{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\listvar{p}}{\listvar{q}} \in \sigmaterms\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{\listvar{mp}}{\listvar{nq}} \in \sigmaterms
            \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms are constructed recursively.
There are four base cases: a generator from \(\generators\) with appropriate
inputs and outputs;
an \emph{identity} for empty wires with no generators;
a \emph{symmetry} for swapping over two wires;
a \emph{splitter} for transforming a list of `thicker' wires into a list of
`thin' one-bit wires, and a \emph{combiner} for the reverse operation.
The two inductive cases are called \emph{composition} and \emph{tensor}
respectively.
Intuitively, these can be thought of generating larger terms by sequencing
subterms in sequence or parallel.

\begin{notation}
    Identities for lists of wires are defined inductively as \begin{gather*}
        \id[\varepsilon] := \id[0]
        \quad
        \id[n^\prime \streamcons \overline{n}]
        :=
        \id[n^\prime] \tensor \id[\overline{n}]
    \end{gather*}
    Symmetries for lists of wires are defined inductively as \begin{gather*}
        \swap{\varepsilon}{\listvar{n}}
        :=
        \id[\listvar{n}]
        \quad
        \swap{\varepsilon}{\listvar{n}}
        := \id[\listvar{n}]
        \\
        \swap{m}{n^\prime \streamcons \listvar{n}}
        :=
        \swap{m}{n^\prime} \tensor \id[\listvar{n}]
        \seq
        \id[y^\prime] \tensor \swap{m}{\listvar{n}}
        \quad
        \swap{m^\prime \streamcons \listvar{m}}{\listvar{n}}
        :=
        \id[m^\prime] \tensor \swap{\listvar{m}}{\listvar{n}}
        \seq
        \swap{[m^\prime]}{\listvar{n}} \tensor \id[\listvar{m}]
    \end{gather*}
\end{notation}

\(\Sigma\)-terms will be abbreviated to `terms' when the signature is clear from
context.

\begin{example}
    \todo[inline]{Think of a funky example}
\end{example}

\begin{remark}
    It is clear that even simple terms described using one-dimensional text
    strings quickly become indecipherable.
    In the next section we will detail a \emph{graphical syntax} which should
    make things much clearer.
\end{remark}
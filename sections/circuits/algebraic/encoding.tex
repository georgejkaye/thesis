\section{Encoding equations}

While the core of a circuit in normalised Mealy form is the canonical
representation of that circuit's Mealy function, there is no reason that
circuits with the same behaviour should have the same Mealy function.
Even if the state words are the same, they may be jumbled up in different
orders.
This is why checking equivalence of Mealy machines is usually performed by
constructing a \emph{bisimulation} rather than basic equality.
To bring this notion into the syntactic realm, we must consider the states

\begin{remark}
    Rather than equations between concrete generators, the equations in this
    section will be \emph{families} of equations parameterised by normalised
    combinational cores and initial states.
    While this does lead to infinite equations, we are working with normalised
    cores so there will be exactly one equation for each combination of
    `behaviour' and state.
\end{remark}

\begin{definition}[States]
    Let \(\morph{f}{\valuetuple{\listvar{xm}}}{\valuetuple{\listvar{xn}}}\) be a
    monotone function and let \(\listvar{s} \in  \valuetuple{x}\) be an
    initial state.
    Then the \emph{states of \(f\) from \(\listvar{s}\)}, denoted
    \(S_{f,\listvar{s}}\), is the smallest set containing \(\listvar{s}\) and
    closed under \(
    \listvar{r}
    \mapsto
    \proj{x}\left(\tilde{f}_0(\listvar{r},\listvar{v})\right)
    \) for any \(\listvar{v} \in \valuetuple{\listvar{m}}\).
\end{definition}

A circuit with a state of width \(x\) will not necessarily assume all the states
in \(\valuetuple{x}\); this means that it is sometimes possible to \emph{encode}
a circuit's states into a smaller word without losing data.

\begin{definition}[Encoder]\label{def:encoder}
    Let \(S \subseteq \valuetuple{x}\) and \(T \subseteq \valuetuple{y}\) be two
    sets; an \emph{(S,T)-encoder} is two functions \(
    \morph{\mathsf{enc}}{S}{T}
    \) and \(
    \morph{\mathsf{dec}}{T}{S}
    \) such that \(\mathsf{dec} \circ \mathsf{enc} = \id\).
\end{definition}

\begin{example}
    Given a set of states \(S \subseteq \valuetuple{x}\), a \(\leq\)-encoding
    \(\morph{\gamma_\leq}{S}{\valuetuple{k}}\) used when defining the map from
    Mealy machines to circuits (\cref{def:encoding}) is an example of a
    \((S,\valuetuple{k})\)-encoder; the decoder
    \(\mathsf{dec}_{S,\valuetuple{x}}\) is defined as the monotone completion
    of \(\gamma_\leq^{-1}\).
\end{example}

Using a decoder and an encoder, we can change the state words that a circuit
operates with.

\begin{proposition}[Encoding equation]\label{prop:encoding-equation}
    For a normalised circuit \(
    \iltikzfig{strings/category/f-2-2}[box=|f|,colour=seq,dom1=\listvar{x},dom2=\listvar{m},cod1=\listvar{x},cod2=\listvar{y}]
    \) and initial state \(\listvar{s} \in \valuetuple{\listvar{x}}\), let
    \(\mathsf{enc},\mathsf{dec}\) be the two functions of a
    \((S_{f,\listvar{s}},\valuetuple{y})\)-encoder as defined above.
    Then the \emph{encoding equation} \((\encodingequation)\) in
    \cref{fig:encoding-equation} is sound, where
    \(\mathsf{enc}_\mathsf{m},\mathsf{dec}_\mathsf{m}\) are monotone completions
    as defined in \cref{def:monotone-completion}.
\end{proposition}
\begin{proof}
    Let \(g\) be the map \(\listvar{r} \mapsto
    \circuittostreami[\iltikzfig{circuits/algebraic/state-encoding}[core=|f|,delay=x,state=\listvar{r}]]
    \); by \cref{prop:mealy-form-image} we know that \(
    \mealyoutput{g(\listvar{t})}{\listvar{v}}
    =
    \proj{1}(f(\mathsf{dec}(\mathsf{enc}(\listvar{t})), \listvar{v}))
    \) and \(
    \mealytransition{g(\listvar{t})}{\listvar{v}}
    =
    g(\proj{0}(f(\mathsf{dec}(\mathsf{enc}(\listvar{t})), \listvar{v})))
    \).
    When \(\listvar{t} \in S_{f, \listvar{s}}\) we have that \(
    \mealyoutput{g(\listvar{t})}{\listvar{v}}
    =
    \proj{1}(f(\listvar{t}), \listvar{v})
    \) and \(
    \mealytransition{g(\listvar{t})}{\listvar{v}}
    =
    g(\proj{0}(f(\listvar{t})), \listvar{v})
    \) by definition of encoders.
    As \(
    \iltikzfig{circuits/algebraic/state-encoding}[core=|f|,delay=x,state=\listvar{s}]
    \coloneqq
    g(\listvar{s})
    \) and \(\listvar{s} \in S_{f,\listvar{s}}\),
    every subsequent stream derivative will also be of the form
    \(g(\listvar{t})\) where \(\listvar{t} \in S_{f,\listvar{s}}\), so the
    equation is sound.
\end{proof}

After applying the encoding equation, the state has not actually changed; we
have just inserted a pair of an encoder and a decoder.
To translate the state we recycle some of the rules from the operational
semantics.
As with the Mealy equations, it is desirable to express these transformations in
terms of smaller components.

\begin{lemma}
    For a combinational circuit \(
    \iltikzfig{strings/category/f}[box=f,colour=comb]
    \), \(
    \iltikzfig{circuits/axioms/generalised-streaming-lhs}[box=f]
    =
    \iltikzfig{circuits/axioms/generalised-streaming-rhs}[box=f]
    \) by the equations in \cref{fig:encoding-equation}.
\end{lemma}
\begin{proof}
    This is by induction on the structure of \(
    \iltikzfig{strings/category/f}[box=f,colour=comb]
    \).
    First the base cases.
    The case for the gate is immediate by \((\streamingeqn)\).
    For \(\iltikzfig{strings/structure/comonoid/copy}[colour=comb]\) we have
    that \(
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-0}
    \eqaxioms[(\bialgmoncomeqn)]
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-1}
    \eqaxioms[(\delayforkeqn)]
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-2}
    \).
    For \(\iltikzfig{strings/structure/monoid/merge}[colour=comb]\):
    \begin{gather*}
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-2}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-3}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-4}
        \eqaxioms[(\monoidcommeqnletter)]
        \\
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-5}
        =
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-6}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-7}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-8}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-9}
    \end{gather*}
    The case for \(\iltikzfig{strings/structure/comonoid/discard}[colour=comb]\) is
    trivial, and the case for \(\iltikzfig{strings/structure/monoid/init}[colour=comb]\)
    follows by \((\comonoiduniteqnletter)\) and \((\bottomdelayeqn)\).
    The cases for \(\iltikzfig{strings/category/identity}[colour=comb]\) and
    \(\iltikzfig{strings/symmetric/symmetry}[colour=comb]\) follow by axioms of STMCs.
    Since the underlying circuit is combinational, for the inductive cases we just
    need to check composition and tensor, which are also trivial.
\end{proof}

\begin{lemma}
    For any value \(v \in \values\), \(
    \iltikzfig{circuits/algebraic/unroll-waveform/step-0}[value=v]
    =
    \iltikzfig{circuits/algebraic/unroll-waveform/step-6}[value=v]
    \) by equations in \cref{fig:encoding-equation}.
\end{lemma}
\begin{proof}
    \begin{gather*}
        \iltikzfig{circuits/algebraic/unroll-waveform/step-0}[value=v]
        \coloneqq
        \iltikzfig{circuits/algebraic/unroll-waveform/step-1}[value=v]
        \eqaxioms[(\joinforkeqn)]
        \iltikzfig{circuits/algebraic/unroll-waveform/step-2}[value=v]
        \eqaxioms[(\forkeqn)]
        \iltikzfig{circuits/algebraic/unroll-waveform/step-3}[value=v]
        \eqaxioms[(\delayforkeqn)]
        \\
        \iltikzfig{circuits/algebraic/unroll-waveform/step-4}[value=v]
        \coloneqq
        \iltikzfig{circuits/algebraic/unroll-waveform/step-5}[value=v]
        =
        \iltikzfig{circuits/algebraic/unroll-waveform/step-6}[value=v]
    \end{gather*}
\end{proof}

\begin{proposition}
    For a normalised circuit \(
    \iltikzfig{strings/category/f-2-2}[box=|f|,colour=seq,dom1=\listvar{x},dom2=\listvar{m},cod1=\listvar{x},cod2=\listvar{y}]
    \) and initial state \(\listvar{s} \in \valuetuple{\listvar{x}}\), the
    equation \(
    \iltikzfig{circuits/productivity/mealy-form}[core=|f|, colour=seq]
    =
    \iltikzfig{circuits/algebraic/state-encoded}[core=|f|,state=\listvar{s}]
    \) is derivable by the equations in \cref{fig:encoding-equation}.
\end{proposition}
\begin{proof}
    By the \((\encodingequation)\) equation we have that \(
    \iltikzfig{circuits/productivity/mealy-form}[core=|f|,delay=x, colour=seq]
    =
    \iltikzfig{circuits/algebraic/state-encoding}[core=|f|,delay=x,state=\listvar{s}]
    \); we need to `push' the encoder \(
    \iltikzfig{circuits/algebraic/encoder}
    \) through the state.
    Although the encoder is sequential, by the definition of \(\lvert-\rvert\),
    it must be of the form \(
    \iltikzfig{circuits/synthesis/normalised-function}[box=g]
    \) by definition of functional completeness.
    \begin{align*}
        \iltikzfig{circuits/algebraic/encoding-state/step-0}
        =
        \iltikzfig{circuits/algebraic/encoding-state/step-1}
        =
        \iltikzfig{circuits/algebraic/encoding-state/step-2}
    \end{align*}

\end{proof}


\input{sections/circuits/algebraic/floats/encoding-equation}

\begin{remark}
    The encoding equation is really a \emph{family} of equations parameterised
    over the circuits \(
    \iltikzfig{strings/category/f}[box=f,colour=seq]
    \) and \(
    \iltikzfig{strings/category/f}[box=g,colour=seq]
    \).
    Since we have the precondition that these circuits are normalised, this is
    not quite every circuit in the universe but there will still be an equation
    for each possible function \(
    \valuetuple{\listvar{m}} \to \valuetuple{\listvar{n}}
    \), of which there are infinitely many.
    any old circuit.
    What is important is that given the two subcircuits and state word of a
    circuit in normalised Mealy form, one can compute the set of circuit states
    and subsequently the encoded circuit.
\end{remark}

The circuit on the right hand side of the encoding equation has a state
containing just \(\bot\) and \(\top\) values.
This is the `pseudo-normal form' for sequential circuits; depending on the
state order picked there are likely to be multiple circuits of this form.
Fortunately, since these circuits are also in normalised Mealy form, the
encoding equation can be used to translate between pseudo-normal forms as well.

\begin{definition}
    For an interpretation \(\interpretation\), let
    \(\mce_{\interpretation}\) be defined as \(
    \mealyequations +
    \instantfeedbackeqn +
    \cartesianequations +
    \normalisingequations +
    \encodingequation
    \), and let \(\scircsigmae\) be defined as
    \(\scircsigma / \mce_{\interpretation}\).
\end{definition}

\begin{theorem}
    For a functionally complete interpretation \(\interpretation\), \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=\listvar{m},cod=\listvar{n}]
    =
    \iltikzfig{strings/category/f}[box=g,colour=seq,dom=\listvar{m},cod=\listvar{n}]
    \) in \(\scircsigmae\) if and only if \(
    \circuittostreami[
        \iltikzfig{strings/category/f}[box=f,colour=seq,dom=\listvar{m},cod=\listvar{n}]
    ]
    =
    \circuittostreami[
        \iltikzfig{strings/category/f}[box=g,colour=seq,dom=\listvar{m},cod=\listvar{n}]
    ]
    \).
\end{theorem}
\begin{proof}
    All the equations are sound, so we only need to consider the \(\ifdir\)
    direction.
    By \cref{lem:normalised-mealy}, the two circuits can be brought to
    normalised Mealy form using
    \(
    \mealyequations +
    \instantfeedbackeqn +
    \cartesianequations +
    \normalisingequations
    \).
    By \cref{def:mealy-to-circuit} and
    \cref{thm:circuit-stream-correspondence} there must exist a circuit \(
    \iltikzfig{strings/category/f}[box=h,colour=seq]
    \coloneqq
    \iltikzfig{circuits/algebraic/encoding}[transition={h_0},output={h_1},state={\listvar{s}}]
    \) such that \(
    \circuittostream[
        \iltikzfig{strings/category/f}[box=f,colour=seq]
    ]{\interpretation}
    =
    \circuittostream[
        \iltikzfig{strings/category/f}[box=h,colour=seq]
    ]{\interpretation}
    =
    \circuittostream[
        \iltikzfig{strings/category/f}[box=g,colour=seq]
    ]{\interpretation}
    \).
    The circuit \(
    \iltikzfig{strings/category/f}[box=H,colour=seq]
    \) is encoded such that the state words are in the image of
    \(\gamma_\leq\).
    This means that applying the encoding equation with \(\leq\) to the
    normalised Mealy forms obtained above will yield the circuit \(
    \iltikzfig{strings/category/f}[box=h,colour=seq]
    \).
\end{proof}

As always, the soundness and completeness of the algebraic semantics means we
can establish another isomorphism of PROPs.

\begin{corollary}
    \(\scircsigmai \cong \scircsigmae\).
\end{corollary}

This brings our jaunt into algebraic semantics to a close; given a circuit \(
\iltikzfig{strings/category/f}[box=f,colour=seq,dom=\listvar{m},cod=\listvar{n}]
\) we know that we can translate it into another circuit \(
\iltikzfig{strings/category/f}[box=g,colour=seq,dom=\listvar{m},cod=\listvar{n}]
\) with the same behaviour by only using equations in \(\mce_\interpretation\).

Of course, the procedure of using the normalisation equations to translate a
circuit into normalised Mealy form before using the encoding equation (possibly
multiple times depending on how lucky one gets with their orderings) may be
tedious; one might wonder how this is beneficial to the operational approach in
the previous chapter.
But the beauty of the \emph{algebraic} semantics is that we \emph{don't} need to
do this every time!
Equations can be proven as lemmas and then used repeatedly in the future as
`shortcuts', possibly saving many reasoning steps.
In time, the algebraicist will build up a powerful repertoire of equations and
wield them to bend circuits to their will.
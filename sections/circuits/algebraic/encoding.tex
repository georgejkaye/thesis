\section{Encoding equations}

While the core of a circuit in normalised Mealy form is the canonical
representation of that circuit's Mealy function, there is no reason that
circuits with the same behaviour should have the same Mealy function.
Even if the state words are the same, they may be jumbled up in different
orders, or the cores may only have the same behaviour when restricted to a
particular subset of inputs.

The optimistic reader might think that we we might stumble across a way of
translating one circuit into the other through some combination of using the
normalisation equations and sliding components around the trace.
Unfortunately, these is simply \emph{not sufficient} for translating between
circuits with the same semantics.

\begin{example}
    Consider the following circuit in \(\scirc{\belnapsignature}\): \[
        \iltikzfig{circuits/examples/state-change/circuit}
        \quad
        \iltikzfig{circuits/examples/state-change/circuit-simpler}
    \]
    The registers will \emph{always} contain
    \(\belnapfalse\) and \(\belnaptrue\) and both circuits will
    produce a constant \(\belnapfalse\) output, so a complete equational theory
    should be able to translate between them.
    To this end, we assemble these into Mealy forms with the same initial states:
    \[
        \iltikzfig{circuits/examples/state-change/circuit-mealy}
        \quad
        \iltikzfig{circuits/examples/state-change/circuit-simpler-mealy}
    \]
    The combinational cores do \emph{not} have the same semantics!
    They only act the same because they receive certain inputs
    from \(\belnapvalues^{3}\).
\end{example}

We must take \emph{context} into account when defining
equations; unfortunately equations that only deal with the interactions between
individual generators are not enough.
This is why checking equivalence of Mealy machines is usually performed by
constructing a \emph{bisimulation} rather than basic equality.
To bring this notion into the syntactic realm, we must consider the states a
circuit may assume.

\begin{remark}
    Rather than equations between concrete generators, some of the `equations'
    in this and the next section are really equation \emph{schema}, specifying
    the   parameterised by normalised
    combinational cores and initial states.
    While this means there may be infinite equations, we are working with
    normalised cores so there will be exactly one equation for each combination
    of behaviour and state.
\end{remark}

\begin{definition}[States]
    Let \(\morph{f}{\valuetuple{\listvar{xm}}}{\valuetuple{\listvar{xn}}}\) be a
    monotone function and let \(\listvar{s} \in  \valuetuple{x}\) be an
    initial state.
    Then the \emph{states of \(f\) from \(\listvar{s}\)}, denoted
    \(S_{f,\listvar{s}}\), is the smallest set containing \(\listvar{s}\) and
    closed under \(
    \listvar{r}
    \mapsto
    \proj{x}\left(\tilde{f}_0(\listvar{r},\listvar{v})\right)
    \) for any \(\listvar{v} \in \valuetuple{\listvar{m}}\).
\end{definition}

A circuit with a state of width \(x\) will not necessarily assume all the states
in \(\valuetuple{x}\); this means that it is sometimes possible to \emph{encode}
a circuit's states into a smaller word without losing data.
To do this we recall the notion of \emph{Mealy homomorphism}
(\cref{def:mealy-homomorphism}): a mapping between states that preserves
transitions and outputs.

\begin{notation}[Restriction]
    For a function \(\morph{f}{A}{B}\) and a set \(C \subseteq A\), let
    the \emph{restriction of \(f\) to \(C\)} be denoted as \(f|C\).
\end{notation}

\begin{definition}
    For a Mealy coalgebra \((S, f)\), two states \(s,t \in S\) are
    \emph{equivalent} if
    \(\mealyfunctionoutput{f}{s} = \mealyfunctionoutput{f}{t}\) and
    \(\mealyfunctiontransition{f}{s} = \mealyfunctiontransition{f}{t}\) are
    equivalent states.
\end{definition}

\begin{definition}[Encoder-decoder pair]\label{def:encoder-decoder}
    For a Mealy coalgebra \((S, f)\) and another set \(T\), two functions
    \(\morph{\mathsf{enc}}{S}{T}\) and \(\morph{\mathsf{dec}}{T}{S}\) are an
    \emph{encoder-decoder pair} if, for all \(s \in S\),
    \(s\) and \(\mathsf{dec}(\mathsf{enc}(s))\) are equivalent states.
\end{definition}

The functions of an encoder-decoder pair can be interpreted syntactically using
the functional completeness map.
Of course, these circuits cannot be inserted arbitrarily into a circuit as they
are not isomorphisms on all inputs, only the states a circuit will assume.

\begin{proposition}[Encoding equation]\label{prop:encoding-equation}
    For a normalised circuit \(
    \iltikzfig{strings/category/f-2-2}[box=|f|,colour=seq,dom1=\listvar{x},dom2=\listvar{m},cod1=\listvar{x},cod2=\listvar{y}]
    \) and initial state \(\listvar{s} \in \valuetuple{\listvar{x}}\), let
    \(\morph{\mathsf{enc}}{S_{f,\listvar{s}}}{\valuetuple{y}}\) and
    \(\morph{\mathsf{enc}}{\valuetuple{y}}{S_{f, \listvar{s}}}\) be an
    encoder-decoder pair as defined above in \cref{def:encoder-decoder}.

    Then the \emph{encoding equation} \((\encodingequation)\) in
    \cref{fig:encoding-equation} is sound, where
    \(\mathsf{enc}_\mathsf{m},\mathsf{dec}_\mathsf{m}\) are monotone completions
    as defined in \cref{def:monotone-completion}.
\end{proposition}
\begin{proof}
    Let \(g\) be the map \(\listvar{r} \mapsto
    \circuittostreami[\iltikzfig{circuits/algebraic/state-encoding}[core=|f|,delay=x,state=\listvar{r}]]
    \); by \cref{prop:mealy-form-image} we know that \(
    \mealyoutput{g(\listvar{t})}{\listvar{v}}
    =
    \proj{1}(f(\mathsf{dec}(\mathsf{enc}(\listvar{t})), \listvar{v}))
    \) and \(
    \mealytransition{g(\listvar{t})}{\listvar{v}}
    =
    g(\proj{0}(f(\mathsf{dec}(\mathsf{enc}(\listvar{t})), \listvar{v})))
    \).
    When \(\listvar{t} \in S_{f, \listvar{s}}\) we have that \(
    \mathsf{dec}(\mathsf{enc}(\listvar{s}))\) is an equivalent state to
    \(\listvar{s}\),
    so
    \(
    \mealyoutput{g(\listvar{t})}{\listvar{v}}
    =
    \proj{1}(f(\listvar{t}), \listvar{v})
    \) and \(
    \mealytransition{g(\listvar{t})}{\listvar{v}}
    \) is equivalent to \(
    g(\proj{0}(f(\listvar{t})), \listvar{v})
    \) by definition of encoders.
    As \(
    \iltikzfig{circuits/algebraic/state-encoding}[core=|f|,delay=x,state=\listvar{s}]
    \coloneqq
    g(\listvar{s})
    \) and \(\listvar{s} \in S_{f,\listvar{s}}\),
    every subsequent stream derivative will also be of the form
    \(g(\listvar{t})\) where \(\listvar{t} \in S_{f,\listvar{s}}\), so the
    equation is sound.
\end{proof}

After applying the encoding equation, the state has not actually changed; we
have just inserted a pair of an encoder and a decoder circuit.
To translate the state we recycle some of the rules from the operational
semantics.
As with the Mealy equations, it is desirable to express these transformations in
terms of smaller components

\begin{lemma}
    The equations on the bottom three rows of \cref{fig:encoding-equation} are
    sound.
\end{lemma}
\begin{proof}
    It is a straightforward exercise to compare the stream functions.
\end{proof}

Before proceeding to show how , we show some intermediate lemmas provable using
the equations in \cref{fig:encoding-equation}.

\begin{lemma}\label{lem:generalised-streaming}
    For a combinational circuit \(
    \iltikzfig{strings/category/f}[box=f,colour=comb]
    \), \(
    \iltikzfig{circuits/axioms/generalised-streaming-lhs}[box=f]
    =
    \iltikzfig{circuits/axioms/generalised-streaming-rhs}[box=f]
    \) by the equations in \cref{fig:encoding-equation}.
\end{lemma}
\begin{proof}
    This is by induction on the structure of \(
    \iltikzfig{strings/category/f}[box=f,colour=comb]
    \).
    First the base cases.
    The case for the gate is immediate by \((\streamingeqn)\).
    For \(\iltikzfig{strings/structure/comonoid/copy}[colour=comb]\) we have
    that \(
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-0}
    \eqaxioms[(\joinforkeqn)]
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-1}
    \eqaxioms[(\delayforkeqn)]
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-2}
    \).
    For \(\iltikzfig{strings/structure/monoid/merge}[colour=comb]\):
    \begin{gather*}
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-2}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-3}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-4}
        \eqaxioms[(\monoidcommeqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-5}
        =
        \\
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-6}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-7}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-8}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-9}
    \end{gather*}
    The case for \(\iltikzfig{strings/structure/comonoid/discard}[colour=comb]\) is
    trivial, and the case for \(\iltikzfig{strings/structure/monoid/init}[colour=comb]\)
    follows by \((\comonoiduniteqnletter)\) and \((\bottomdelayeqn)\).
    The cases for \(\iltikzfig{strings/category/identity}[colour=comb]\) and
    \(\iltikzfig{strings/symmetric/symmetry}[colour=comb]\) follow by axioms of STMCs.
    Since the underlying circuit is combinational, for the inductive cases we just
    need to check composition and tensor, which are also trivial.
\end{proof}

\begin{lemma}\label{lem:unroll-waveform}
    For any value \(v \in \values\), \(
    \iltikzfig{circuits/algebraic/unroll-waveform/step-0}[value=v]
    =
    \iltikzfig{circuits/algebraic/unroll-waveform/step-6}[value=v]
    \) by equations in \cref{fig:encoding-equation}.
\end{lemma}
\begin{proof}
    \begin{gather*}
        \iltikzfig{circuits/algebraic/unroll-waveform/step-0}[value=v]
        \coloneqq
        \iltikzfig{circuits/algebraic/unroll-waveform/step-1}[value=v]
        \eqaxioms[(\joinforkeqn)]
        \iltikzfig{circuits/algebraic/unroll-waveform/step-2}[value=v]
        \eqaxioms[(\forkeqn)]
        \iltikzfig{circuits/algebraic/unroll-waveform/step-3}[value=v]
        \eqaxioms[(\delayforkeqn)]
        \\
        \iltikzfig{circuits/algebraic/unroll-waveform/step-4}[value=v]
        \coloneqq
        \iltikzfig{circuits/algebraic/unroll-waveform/step-5}[value=v]
        =
        \iltikzfig{circuits/algebraic/unroll-waveform/step-6}[value=v]
    \end{gather*}
\end{proof}

With these facts under our belt, we will now show that the equations in
\cref{fig:encoding-equation} allow us to translate a circuit into one
with an encoded state.

\begin{proposition}
    For a normalised circuit \(
    \iltikzfig{strings/category/f-2-2}[box=|f|,colour=seq,dom1=\listvar{x},dom2=\listvar{m},cod1=\listvar{x},cod2=\listvar{y}]
    \) and initial state \(\listvar{s} \in \valuetuple{\listvar{x}}\), the
    equation \(
    \iltikzfig{circuits/productivity/mealy-form}[core=|f|, colour=seq]
    =
    \iltikzfig{circuits/algebraic/state-encoded}[core=|f|,state=\listvar{s}]
    \) is derivable by the equations in \cref{fig:encoding-equation}.
\end{proposition}
\begin{proof}
    By the \((\encodingequation)\) equation we have that \(
    \iltikzfig{circuits/productivity/mealy-form}[core=|f|,delay=x, colour=seq]
    =
    \iltikzfig{circuits/algebraic/state-encoding}[core=|f|,delay=x,state=\listvar{s}]
    \); we need to `push' the encoder \(
    \iltikzfig{circuits/algebraic/encoder}
    \) through the state.
    Although the encoder is sequential, by the definition of \(\lvert-\rvert\),
    it must be of the form \(
    \iltikzfig{circuits/synthesis/normalised-function}[box=g]
    \) by definition of functional completeness; this means we can perform a
    variant of streaming.
    \begin{gather*}
        \iltikzfig{circuits/algebraic/encoding-state/step-0a}[box=g]
        \coloneqq
        \iltikzfig{circuits/algebraic/encoding-state/step-0}[box=g]
        \eqaxioms[\text{\cref{lem:unroll-waveform}}]
        \iltikzfig{circuits/algebraic/encoding-state/step-1}[box=g]
        \eqaxioms[\text{\cref{lem:generalised-streaming}}]
        \\[0.5em]
        \iltikzfig{circuits/algebraic/encoding-state/step-2}[box=g]
        \eqaxioms[\text{\cref{def:encoder}}]
        \iltikzfig{circuits/algebraic/encoding-state/step-3}[box=g]
        \\[0.5em]
        \coloneqq
        \iltikzfig{circuits/algebraic/encoding-state/step-4}[box=g]
        \coloneqq
        \iltikzfig{circuits/algebraic/encoding-state/step-5}[box=g]
    \end{gather*}
    The proof is completed by sliding the encoder around the trace.
\end{proof}

\input{sections/circuits/algebraic/floats/encoding-equation}

If we have the right encoders, we can translate the initial state of a circuit
into a different word, and end up with a new circuit in a `Mealy form' with a
sequential core.
However, since the encoders, decoders, and core are essentially combinational,
these can be normalised once again to obtain a new normalised core.
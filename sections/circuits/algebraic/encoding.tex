\section{Encoding equations}

While the core of a circuit in normalised Mealy form is the canonical
representation of that circuit's Mealy function, there is no reason that
circuits with the same behaviour should have the same Mealy function.
Even if the state words are the same, they may be jumbled up in different
orders, or the cores may only have the same behaviour when restricted to a
particular subset of inputs.

The optimistic reader might think that we we might stumble across a way of
translating one circuit into the other through some combination of using the
normalisation equations and sliding components around the trace.
Unfortunately, these is simply \emph{not sufficient} for translating between
circuits with the same semantics.

\begin{example}
    Consider the following circuit in \(\scirc{\belnapsignature}\): \[
        \iltikzfig{circuits/examples/state-change/circuit}
        \quad
        \iltikzfig{circuits/examples/state-change/circuit-simpler}
    \]
    The registers will \emph{always} contain
    \(\belnapfalse\) and \(\belnaptrue\) and both circuits will
    produce a constant \(\belnapfalse\) output, so a complete equational theory
    should be able to translate between them.
    To this end, we assemble these into Mealy forms with the same initial states:
    \[
        \iltikzfig{circuits/examples/state-change/circuit-mealy}
        \quad
        \iltikzfig{circuits/examples/state-change/circuit-simpler-mealy}
    \]
    The combinational cores do \emph{not} have the same semantics!
    They only act the same because they receive certain inputs
    from \(\belnapvalues^{3}\).
\end{example}

We must take \emph{context} into account when defining
equations; unfortunately equations that only deal with the interactions between
individual generators are not enough.
This is why checking equivalence of Mealy machines is usually performed by
constructing a \emph{bisimulation} rather than basic equality.
To bring this notion into the syntactic realm, we must consider the states a
circuit may assume.

\begin{remark}
    Rather than equations between concrete generators, the equations in this
    section will be \emph{families} of equations parameterised by normalised
    combinational cores and initial states.
    While this does lead to infinite equations, we are working with normalised
    cores so there will be exactly one equation for each combination of
    `behaviour' and state.
\end{remark}

\begin{definition}[States]
    Let \(\morph{f}{\valuetuple{\listvar{xm}}}{\valuetuple{\listvar{xn}}}\) be a
    monotone function and let \(\listvar{s} \in  \valuetuple{x}\) be an
    initial state.
    Then the \emph{states of \(f\) from \(\listvar{s}\)}, denoted
    \(S_{f,\listvar{s}}\), is the smallest set containing \(\listvar{s}\) and
    closed under \(
    \listvar{r}
    \mapsto
    \proj{x}\left(\tilde{f}_0(\listvar{r},\listvar{v})\right)
    \) for any \(\listvar{v} \in \valuetuple{\listvar{m}}\).
\end{definition}

A circuit with a state of width \(x\) will not necessarily assume all the states
in \(\valuetuple{x}\); this means that it is sometimes possible to \emph{encode}
a circuit's states into a smaller word without losing data.
To do this we recall the notion of \emph{Mealy homomorphism}
(\cref{def:mealy-homomorphism}): a mapping between states that preserves
transitions and outputs.

\begin{notation}[Restriction]
    For a function \(\morph{f}{A}{B}\) and a set \(C \subseteq A\), let
    the \emph{restriction of \(f\) to \(C\)} be denoted as \(f|C\).
\end{notation}

\begin{definition}
    For a Mealy coalgebra \((S, f)\), two states \(s,t \in S\) are
    \emph{equivalent} if
    \(\mealyfunctionoutput{f}{s} = \mealyfunctionoutput{f}{t}\) and
    \(\mealyfunctiontransition{f}{s} = \mealyfunctiontransition{f}{t}\) are
    equivalent states.
\end{definition}

\begin{definition}[Encoder-decoder pair]\label{def:encoder-decoder}
    For a Mealy coalgebra \((S, f)\) and another set \(T\), two functions
    \(\morph{\mathsf{enc}}{S}{T}\) and \(\morph{\mathsf{dec}}{T}{S}\) are an
    \emph{encoder-decoder pair} if, for all \(s \in S\),
    \(s\) and \(\mathsf{dec}(\mathsf{enc}(s))\) are equivalent states.
\end{definition}

The functions of an encoder-decoder pair can be interpreted syntactically using
the functional completeness map.
Of course, these circuits cannot be inserted arbitrarily into a circuit as they
are not isomorphisms on all inputs, only the states a circuit will assume.

\begin{proposition}[Encoding equation]\label{prop:encoding-equation}
    For a normalised circuit \(
    \iltikzfig{strings/category/f-2-2}[box=|f|,colour=seq,dom1=\listvar{x},dom2=\listvar{m},cod1=\listvar{x},cod2=\listvar{y}]
    \) and initial state \(\listvar{s} \in \valuetuple{\listvar{x}}\), let
    \(\morph{\mathsf{enc}}{S_{f,\listvar{s}}}{\valuetuple{y}}\) and
    \(\morph{\mathsf{enc}}{\valuetuple{y}}{S_{f, \listvar{s}}}\) be an
    encoder-decoder pair as defined above in \cref{def:encoder-decoder}.

    Then the \emph{encoding equation} \((\encodingequation)\) in
    \cref{fig:encoding-equation} is sound, where
    \(\mathsf{enc}_\mathsf{m},\mathsf{dec}_\mathsf{m}\) are monotone completions
    as defined in \cref{def:monotone-completion}.
\end{proposition}
\begin{proof}
    Let \(g\) be the map \(\listvar{r} \mapsto
    \circuittostreami[\iltikzfig{circuits/algebraic/state-encoding}[core=|f|,delay=x,state=\listvar{r}]]
    \); by \cref{prop:mealy-form-image} we know that \(
    \mealyoutput{g(\listvar{t})}{\listvar{v}}
    =
    \proj{1}(f(\mathsf{dec}(\mathsf{enc}(\listvar{t})), \listvar{v}))
    \) and \(
    \mealytransition{g(\listvar{t})}{\listvar{v}}
    =
    g(\proj{0}(f(\mathsf{dec}(\mathsf{enc}(\listvar{t})), \listvar{v})))
    \).
    When \(\listvar{t} \in S_{f, \listvar{s}}\) we have that \(
    \mathsf{dec}(\mathsf{enc}(\listvar{s}))\) is an equivalent state to
    \(\listvar{s}\),
    so
    \(
    \mealyoutput{g(\listvar{t})}{\listvar{v}}
    =
    \proj{1}(f(\listvar{t}), \listvar{v})
    \) and \(
    \mealytransition{g(\listvar{t})}{\listvar{v}}
    \) is equivalent to \(
    g(\proj{0}(f(\listvar{t})), \listvar{v})
    \) by definition of encoders.
    As \(
    \iltikzfig{circuits/algebraic/state-encoding}[core=|f|,delay=x,state=\listvar{s}]
    \coloneqq
    g(\listvar{s})
    \) and \(\listvar{s} \in S_{f,\listvar{s}}\),
    every subsequent stream derivative will also be of the form
    \(g(\listvar{t})\) where \(\listvar{t} \in S_{f,\listvar{s}}\), so the
    equation is sound.
\end{proof}

After applying the encoding equation, the state has not actually changed; we
have just inserted a pair of an encoder and a decoder circuit.
To translate the state we recycle some of the rules from the operational
semantics.
As with the Mealy equations, it is desirable to express these transformations in
terms of smaller components

\begin{lemma}
    The equations on the bottom three rows of \cref{fig:encoding-equation} are
    sound.
\end{lemma}
\begin{proof}
    It is a straightforward exercise to compare the stream functions.
\end{proof}

Before proceeding to show how , we show some intermediate lemmas provable using
the equations in \cref{fig:encoding-equation}.

\begin{lemma}\label{lem:generalised-streaming}
    For a combinational circuit \(
    \iltikzfig{strings/category/f}[box=f,colour=comb]
    \), \(
    \iltikzfig{circuits/axioms/generalised-streaming-lhs}[box=f]
    =
    \iltikzfig{circuits/axioms/generalised-streaming-rhs}[box=f]
    \) by the equations in \cref{fig:encoding-equation}.
\end{lemma}
\begin{proof}
    This is by induction on the structure of \(
    \iltikzfig{strings/category/f}[box=f,colour=comb]
    \).
    First the base cases.
    The case for the gate is immediate by \((\streamingeqn)\).
    For \(\iltikzfig{strings/structure/comonoid/copy}[colour=comb]\) we have
    that \(
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-0}
    \eqaxioms[(\joinforkeqn)]
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-1}
    \eqaxioms[(\delayforkeqn)]
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-2}
    \).
    For \(\iltikzfig{strings/structure/monoid/merge}[colour=comb]\):
    \begin{gather*}
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-2}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-3}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-4}
        \eqaxioms[(\monoidcommeqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-5}
        =
        \\
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-6}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-7}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-8}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-9}
    \end{gather*}
    The case for \(\iltikzfig{strings/structure/comonoid/discard}[colour=comb]\) is
    trivial, and the case for \(\iltikzfig{strings/structure/monoid/init}[colour=comb]\)
    follows by \((\comonoiduniteqnletter)\) and \((\bottomdelayeqn)\).
    The cases for \(\iltikzfig{strings/category/identity}[colour=comb]\) and
    \(\iltikzfig{strings/symmetric/symmetry}[colour=comb]\) follow by axioms of STMCs.
    Since the underlying circuit is combinational, for the inductive cases we just
    need to check composition and tensor, which are also trivial.
\end{proof}

\begin{lemma}\label{lem:unroll-waveform}
    For any value \(v \in \values\), \(
    \iltikzfig{circuits/algebraic/unroll-waveform/step-0}[value=v]
    =
    \iltikzfig{circuits/algebraic/unroll-waveform/step-6}[value=v]
    \) by equations in \cref{fig:encoding-equation}.
\end{lemma}
\begin{proof}
    \begin{gather*}
        \iltikzfig{circuits/algebraic/unroll-waveform/step-0}[value=v]
        \coloneqq
        \iltikzfig{circuits/algebraic/unroll-waveform/step-1}[value=v]
        \eqaxioms[(\joinforkeqn)]
        \iltikzfig{circuits/algebraic/unroll-waveform/step-2}[value=v]
        \eqaxioms[(\forkeqn)]
        \iltikzfig{circuits/algebraic/unroll-waveform/step-3}[value=v]
        \eqaxioms[(\delayforkeqn)]
        \\
        \iltikzfig{circuits/algebraic/unroll-waveform/step-4}[value=v]
        \coloneqq
        \iltikzfig{circuits/algebraic/unroll-waveform/step-5}[value=v]
        =
        \iltikzfig{circuits/algebraic/unroll-waveform/step-6}[value=v]
    \end{gather*}
\end{proof}

With these facts under our belt, we will now show that the equations in
\cref{fig:encoding-equation} allow us to translate a circuit into one
with an encoded state.

\begin{proposition}
    For a normalised circuit \(
    \iltikzfig{strings/category/f-2-2}[box=|f|,colour=seq,dom1=\listvar{x},dom2=\listvar{m},cod1=\listvar{x},cod2=\listvar{y}]
    \) and initial state \(\listvar{s} \in \valuetuple{\listvar{x}}\), the
    equation \(
    \iltikzfig{circuits/productivity/mealy-form}[core=|f|, colour=seq]
    =
    \iltikzfig{circuits/algebraic/state-encoded}[core=|f|,state=\listvar{s}]
    \) is derivable by the equations in \cref{fig:encoding-equation}.
\end{proposition}
\begin{proof}
    By the \((\encodingequation)\) equation we have that \(
    \iltikzfig{circuits/productivity/mealy-form}[core=|f|,delay=x, colour=seq]
    =
    \iltikzfig{circuits/algebraic/state-encoding}[core=|f|,delay=x,state=\listvar{s}]
    \); we need to `push' the encoder \(
    \iltikzfig{circuits/algebraic/encoder}
    \) through the state.
    Although the encoder is sequential, by the definition of \(\lvert-\rvert\),
    it must be of the form \(
    \iltikzfig{circuits/synthesis/normalised-function}[box=g]
    \) by definition of functional completeness; this means we can perform a
    variant of streaming.
    \begin{gather*}
        \iltikzfig{circuits/algebraic/encoding-state/step-0a}[box=g]
        \coloneqq
        \iltikzfig{circuits/algebraic/encoding-state/step-0}[box=g]
        \eqaxioms[\text{\cref{lem:unroll-waveform}}]
        \iltikzfig{circuits/algebraic/encoding-state/step-1}[box=g]
        \eqaxioms[\text{\cref{lem:generalised-streaming}}]
        \\[0.5em]
        \iltikzfig{circuits/algebraic/encoding-state/step-2}[box=g]
        \eqaxioms[\text{\cref{def:encoder}}]
        \iltikzfig{circuits/algebraic/encoding-state/step-3}[box=g]
        \\[0.5em]
        \coloneqq
        \iltikzfig{circuits/algebraic/encoding-state/step-4}[box=g]
        \coloneqq
        \iltikzfig{circuits/algebraic/encoding-state/step-5}[box=g]
    \end{gather*}
    The proof is completed by sliding the encoder around the trace.
\end{proof}

\input{sections/circuits/algebraic/floats/encoding-equation}

If we have the right encoders, we can translate the initial state of a circuit
into a different word, and end up with a new circuit in a `Mealy form' with a
sequential core.
However, since the encoders, decoders, and core are essentially combinational,
these can be normalised once again to obtain a new normalised core.

\todo[inline]{Restriction equation}

\todo[inline]{Segue to bot top thing}

The circuit on the right hand side of the encoding equation has a state
containing just \(\bot\) and \(\top\) values.
This is the `pseudo-normal form' for sequential circuits; depending on the
state order picked there are likely to be multiple circuits of this form.
Fortunately, since these circuits are also in normalised Mealy form, the
encoding equation can be used to translate between pseudo-normal forms as well.

\begin{definition}
    For an interpretation \(\interpretation\), let
    \(\mce_{\interpretation}\) be defined as \(
    \mealyequations +
    \instantfeedbackeqn +
    \cartesianequations +
    \normalisingequations +
    \encodingequation
    \), and let \(\scircsigmae\) be defined as
    \(\scircsigma / \mce_{\interpretation}\).
\end{definition}

\begin{theorem}
    For a functionally complete interpretation \(\interpretation\), \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=\listvar{m},cod=\listvar{n}]
    =
    \iltikzfig{strings/category/f}[box=g,colour=seq,dom=\listvar{m},cod=\listvar{n}]
    \) in \(\scircsigmae\) if and only if \(
    \circuittostreami[
        \iltikzfig{strings/category/f}[box=f,colour=seq,dom=\listvar{m},cod=\listvar{n}]
    ]
    =
    \circuittostreami[
        \iltikzfig{strings/category/f}[box=g,colour=seq,dom=\listvar{m},cod=\listvar{n}]
    ]
    \).
\end{theorem}
\begin{proof}
    All the equations are sound, so we only need to consider the \(\ifdir\)
    direction.
    By \cref{lem:normalised-mealy}, the two circuits can be brought to
    normalised Mealy form using
    \(
    \mealyequations +
    \instantfeedbackeqn +
    \cartesianequations +
    \normalisingequations
    \).
    By \cref{def:mealy-to-circuit} and
    \cref{thm:circuit-stream-correspondence} there must exist a circuit \(
    \iltikzfig{strings/category/f}[box=h,colour=seq]
    \coloneqq
    \iltikzfig{circuits/algebraic/encoding}[transition={h_0},output={h_1},state={\listvar{s}}]
    \) such that \(
    \circuittostream[
        \iltikzfig{strings/category/f}[box=f,colour=seq]
    ]{\interpretation}
    =
    \circuittostream[
        \iltikzfig{strings/category/f}[box=h,colour=seq]
    ]{\interpretation}
    =
    \circuittostream[
        \iltikzfig{strings/category/f}[box=g,colour=seq]
    ]{\interpretation}
    \).
    The circuit \(
    \iltikzfig{strings/category/f}[box=H,colour=seq]
    \) is encoded such that the state words are in the image of
    \(\gamma_\leq\).
    This means that applying the encoding equation with \(\leq\) to the
    normalised Mealy forms obtained above will yield the circuit \(
    \iltikzfig{strings/category/f}[box=h,colour=seq]
    \).
\end{proof}

As always, the soundness and completeness of the algebraic semantics means we
can establish another isomorphism of PROPs.

\begin{corollary}
    \(\scircsigmai \cong \scircsigmae\).
\end{corollary}

This brings our jaunt into algebraic semantics to a close; given a circuit \(
\iltikzfig{strings/category/f}[box=f,colour=seq,dom=\listvar{m},cod=\listvar{n}]
\) we know that we can translate it into another circuit \(
\iltikzfig{strings/category/f}[box=g,colour=seq,dom=\listvar{m},cod=\listvar{n}]
\) with the same behaviour by only using equations in \(\mce_\interpretation\).

Of course, the procedure of using the normalisation equations to translate a
circuit into normalised Mealy form before using the encoding equation (possibly
multiple times depending on how lucky one gets with their orderings) may be
tedious; one might wonder how this is beneficial to the operational approach in
the previous chapter.
But the beauty of the \emph{algebraic} semantics is that we \emph{don't} need to
do this every time!
Equations can be proven as lemmas and then used repeatedly in the future as
`shortcuts', possibly saving many reasoning steps.
In time, the algebraicist will build up a powerful repertoire of equations and
wield them to bend circuits to their will.
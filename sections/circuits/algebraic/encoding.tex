\section{Encoding equations}

A circuit in Mealy form is a syntactic representation of a Mealy machine: it
has a combinational core acting as the Mealy machine. and registers containing
the initial state of the machine.
As we saw in the operational semantics, as a circuit is applied to inputs these
registers are updated with new values as the circuit transitions to new states.
When reasoning algebraically, we cannot evaluate these states as we have no
inputs to compute with.
However, the states a circuit \emph{might} assume will still be important as
they dictate whether an equation is valid.

\begin{definition}[States]
    Let \(\morph{f}{\valuetuple{\listvar{xm}}}{\valuetuple{\listvar{xn}}}\) be a
    monotone function and let \(\listvar{s} \in  \valuetuple{x}\) be an
    initial state.
    Then the \emph{states of \(f\) from \(\listvar{s}\)}, denoted
    \(S_{f,\listvar{s}}\), is the smallest set containing \(\listvar{s}\) and
    closed under \(
    \listvar{r}
    \mapsto
    \proj{x}\left(\tilde{f}_0(\listvar{r},\listvar{v})\right)
    \) for any \(\listvar{v} \in \valuetuple{\listvar{m}}\).
\end{definition}

\begin{example}\label{ex:circuit-states}
    Consider the circuit \(
    \iltikzfig{circuits/examples/bottrue/circuit}
    \).
    The semantics of the combinational core are clearly
    \(sr \mapsto (s \lor r)s(s \lor r)\), where the first two characters are the
    next state and the third is the output.
    The initial state is \(\bot\belnaptrue\), so the subsequent states are
    \((\bot \lor \belnaptrue)\bot = \belnaptrue\bot\) and
    \((\belnaptrue \lor \bot)\belnaptrue = \belnaptrue\belnaptrue\).
    As \((\belnaptrue \lor \belnaptrue)\belnaptrue = \belnaptrue\belnaptrue\),
    there are no more circuit states and the complete set is
    \(\{\bot\belnaptrue,\belnaptrue\bot,\belnaptrue\belnaptrue\}\).

    Note that as the output of the circuit is computed as \(s \lor r\), for each
    circuit state the output is \(\belnaptrue\).
    This means that the circuit is denotationally equivalent to \(
    \iltikzfig{circuits/components/waveforms/infinite-register}[val=\belnaptrue]
    \), but this circuit only has a single state \(\belnaptrue\).
\end{example}

We need to \emph{encode} the states of one circuit as another; we have already
encountered this notion using \emph{Mealy homomorphisms}
(\cref{def:mealy-homomorphism});
functions between the state sets that preserve transitions and outputs.
While two `inverse' homomorphisms may not be isomorphisms, the round
trip will always map to a state with the same behaviour.

\begin{lemma}
    For Mealy homomorphisms \(\morph{h}{(S,f)}{(T,g)}\) and
    \(\morph{h^\prime}{(T,g)}{(S,f)}\), any state \(s \in S\) and input
    \(a \in A\), \(
    \mealyfunctiontransition{f}(s, a)
    =
    \mealyfunctiontransition{f}(h^\prime(h(s)), a)
    \).
\end{lemma}
\begin{proof}
    Immediate as Mealy homomorphisms preserve outputs.
\end{proof}

Pairs of `inverse' Mealy homomorphisms as described above will act as state
encoders and decoders between circuits.
To create circuits representing these homomorphisms, we once again use the
functional completeness map for an interpretation, which assigns a syntactic
circuit to any monotone (combinational) function.

\begin{lemma}
    For partial orders \(S\) and \(T\) and monotone Mealy coalgebra
    \((S,f)\) and \((T,g)\), any Mealy homomorphism \(\morph{h}{(S,f)}{(T,g)}\)
    is monotone.
\end{lemma}
\begin{proof}
    In a monotone Mealy coalgebra, the functions \(f\) and \(g\) are monotone,
    and for \(h\) to be a Mealy homomorphism, \(
    \mealyfunctionoutput{f}(s)
    =
    \mealyfunctionoutput{g}(h(s))
    \).
    Assume states \(s,r \in S\); subsequently we have \(
    \mealyfunctionoutput{g}(h(s), a)
    =
    \mealyfunctionoutput{f}(s, a)
    \leq
    \mealyfunctionoutput{f}(r, a)
    =
    \mealyfunctionoutput{g}(h(r), a)
    \).
    This means that the function \(
    s \mapsto \mealyfunctionoutput{g}(h(s), a)
    \) is monotone; as \(\mealyfunctionoutput{g}\) is monotone, \(h\) must
    also be monotone.
\end{proof}

For two circuits \(
\iltikzfig{circuits/productivity/mealy-form}[core=\mealytofunc[f],state=\listvar{s},colour=seq,dom=\listvar{m},cod=\listvar{n},delay=\listvar{x}]
\) and \(
\iltikzfig{circuits/productivity/mealy-form}[core=|g|,state=\listvar{t},colour=seq,dom=\listvar{m},cod=\listvar{n},delay=\listvar{y}]
\), the encoders and decoders we will use for circuits will be Mealy homomorphisms
\(\morph{h}{(S_{f,\listvar{s}},f)}{(S_{g,\listvar{t}},g)}\)
and
\(\morph{h}{(S_{g,\listvar{t}},g)}{(S_{f,\listvar{s}},f)}\).


\begin{proposition}
    For two denotationally equivalent circuits \(
    \iltikzfig{circuits/productivity/mealy-form}[core=\mealytofunc[f],state=\listvar{s},colour=seq,dom=\listvar{m},cod=\listvar{n},delay=\listvar{x}]
    \) and \(
    \iltikzfig{circuits/productivity/mealy-form}[core=|g|,state=\listvar{t},colour=seq,dom=\listvar{m},cod=\listvar{n},delay=\listvar{y}]
    \), there exists at least one Mealy homomorphism \(
    \morph{h}{(S_{f,\listvar{s}},f)}{(S_{g,\listvar{t}},g)}
    \).
\end{proposition}
\begin{proof}
    As the two circuits are denotationally equivalent, at least one valid
    mapping of states can be obtained by sending states in the former to the
    state in the latter obtained after inputting the same word.
    However, there will be more than one valid homomorphism if the second
    circuit has more states than the first, as there will be multiple states in
    the second that act like a single state in the first.
\end{proof}

Note that these are Mealy homomorphisms on the subset of states that a circuit
can assume, \emph{not} the entire set of words that can fit into the state!
This means that encoding and decoding circuits cannot be inserted arbitrarily
but only in the context of a larger circuit in Mealy form.

\begin{proposition}[Encoding equation]\label{prop:encoding-equation}
    For a normalised circuit \(
    \iltikzfig{strings/category/f-2-2}[box=\mealytofunc[f],colour=seq,dom1=\listvar{x},dom2=\listvar{m},cod1=\listvar{x},cod2=\listvar{y}]
    \) and initial state \(\listvar{s} \in \valuetuple{\listvar{x}}\), let
    \(\morph{\mathsf{enc}}{S_{f,\listvar{s}}}{\valuetuple{y}}\) and
    \(\morph{\mathsf{dec}}{\valuetuple{y}}{S_{f, \listvar{s}}}\) be Mealy
    homomorphisms.
    Then the \emph{encoding equation} \((\encodingequation)\) in
    \cref{fig:encoding-equation} is sound, where
    \(\mathsf{enc}_\mathsf{m},\mathsf{dec}_\mathsf{m}\) are monotone completions
    as defined in \cref{def:monotone-completion}.
\end{proposition}
\begin{proof}
    Let \(g\) be the map \(\listvar{r} \mapsto
    \circuittostreami[\iltikzfig{circuits/algebraic/state-encoding}[core=\mealytofunc[f],delay=x,state=\listvar{r}]]
    \); by \cref{prop:mealy-form-image} we know that \(
    \mealyoutput{g(\listvar{t})}{\listvar{v}}
    =
    \proj{1}(f(\mathsf{dec}(\mathsf{enc}(\listvar{t})), \listvar{v}))
    \) and \(
    \mealytransition{g(\listvar{t})}{\listvar{v}}
    =
    g(\proj{0}(f(\mathsf{dec}(\mathsf{enc}(\listvar{t})), \listvar{v})))
    \).
    When \(\listvar{t} \in S_{f, \listvar{s}}\) we have that \(
    \mathsf{dec}(\mathsf{enc}(\listvar{s}))\) is an equivalent state to
    \(\listvar{s}\),
    so
    \(
    \mealyoutput{g(\listvar{t})}{\listvar{v}}
    =
    \proj{1}(f(\listvar{t}), \listvar{v})
    \) and \(
    \mealytransition{g(\listvar{t})}{\listvar{v}}
    \) is equivalent to \(
    g(\proj{0}(f(\listvar{t})), \listvar{v})
    \) by definition of encoders.
    As \(
    \iltikzfig{circuits/algebraic/state-encoding}[core=\mealytofunc[f],delay=x,state=\listvar{s}]
    \coloneqq
    g(\listvar{s})
    \) and \(\listvar{s} \in S_{f,\listvar{s}}\),
    every subsequent stream derivative will also be of the form
    \(g(\listvar{t})\) where \(\listvar{t} \in S_{f,\listvar{s}}\), so the
    equation is sound.
\end{proof}

\begin{remark}
    The encoding equation is an equation \emph{schema}: this is required because
    the width of a circuit state can be arbitrarily large, and each extra bit
    adds a whole new set of Mealy homomorphisms to consider.
\end{remark}

\input{sections/circuits/algebraic/floats/encoding-equation}

After applying the encoding equation, the state has not actually changed; we
have just inserted a pair of an encoder and a decoder circuit.
To translate the state we recycle some of the rules from the operational
semantics.
As with the Mealy equations, it is desirable to express these transformations in
terms of smaller components

\begin{lemma}
    The equations on the bottom three rows of \cref{fig:encoding-equation} are
    sound.
\end{lemma}
\begin{proof}
    It is a straightforward exercise to compare the stream functions.
\end{proof}

Using the equations in \cref{fig:encoding-equation}, we can derive some larger
equations.

\begin{lemma}\label{lem:generalised-streaming}
    For a combinational circuit \(
    \iltikzfig{strings/category/f}[box=f,colour=comb]
    \), \(
    \iltikzfig{circuits/axioms/generalised-streaming-lhs}[box=f]
    =
    \iltikzfig{circuits/axioms/generalised-streaming-rhs}[box=f]
    \) by the equations in \cref{fig:encoding-equation}.
\end{lemma}
\begin{proof}
    This is by induction on the structure of \(
    \iltikzfig{strings/category/f}[box=f,colour=comb]
    \).
    First the base cases.
    The case for the gate is immediate by \((\streamingeqn)\).
    For \(\iltikzfig{strings/structure/comonoid/copy}[colour=comb]\) we have
    that \(
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-0}
    \eqaxioms[(\joinforkeqn)]
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-1}
    \eqaxioms[(\delayforkeqn)]
    \iltikzfig{circuits/productivity/generalised-streaming/fork-step-2}
    \).
    For \(\iltikzfig{strings/structure/monoid/merge}[colour=comb]\):
    \begin{gather*}
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-2}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-3}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-4}
        \eqaxioms[(\monoidcommeqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-5}
        =
        \\
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-6}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-7}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-8}
        \eqaxioms[(\monoidassoceqnletter)]
        \iltikzfig{circuits/productivity/generalised-streaming/join-step-9}
    \end{gather*}
    The case for \(\iltikzfig{strings/structure/comonoid/discard}[colour=comb]\) is
    trivial, and the case for \(\iltikzfig{strings/structure/monoid/init}[colour=comb]\)
    follows by \((\comonoiduniteqnletter)\) and \((\bottomdelayeqn)\).
    The cases for \(\iltikzfig{strings/category/identity}[colour=comb]\) and
    \(\iltikzfig{strings/symmetric/symmetry}[colour=comb]\) follow by axioms of STMCs.
    Since the underlying circuit is combinational, for the inductive cases we just
    need to check composition and tensor, which are also trivial.
\end{proof}

\begin{lemma}\label{lem:unroll-waveform}
    For any value \(v \in \values\), \(
    \iltikzfig{circuits/algebraic/unroll-waveform/step-0}[value=v]
    =
    \iltikzfig{circuits/algebraic/unroll-waveform/step-6}[value=v]
    \) by equations in \cref{fig:encoding-equation}.
\end{lemma}
\begin{proof}
    \begin{gather*}
        \iltikzfig{circuits/algebraic/unroll-waveform/step-0}[value=v]
        \coloneqq
        \iltikzfig{circuits/algebraic/unroll-waveform/step-1}[value=v]
        \eqaxioms[(\joinforkeqn)]
        \iltikzfig{circuits/algebraic/unroll-waveform/step-2}[value=v]
        \eqaxioms[(\forkeqn)]
        \iltikzfig{circuits/algebraic/unroll-waveform/step-3}[value=v]
        \eqaxioms[(\delayforkeqn)]
        \\
        \iltikzfig{circuits/algebraic/unroll-waveform/step-4}[value=v]
        \coloneqq
        \iltikzfig{circuits/algebraic/unroll-waveform/step-5}[value=v]
        =
        \iltikzfig{circuits/algebraic/unroll-waveform/step-6}[value=v]
    \end{gather*}
\end{proof}

We will now show that the equations in \cref{fig:encoding-equation} allow us to
translate a circuit into one with an encoded state.

\begin{theorem}
    For a normalised circuit \(
    \iltikzfig{strings/category/f-2-2}[box=\mealytofunc[f],colour=seq,dom1=\listvar{x},dom2=\listvar{m},cod1=\listvar{x},cod2=\listvar{y}]
    \) and initial state \(\listvar{s} \in \valuetuple{\listvar{x}}\), the
    equation \(
    \iltikzfig{circuits/productivity/mealy-form}[core=\mealytofunc[f], colour=seq]
    =
    \iltikzfig{circuits/algebraic/state-encoded}[core=\mealytofunc[f],state=\listvar{s}]
    \) is derivable by the equations in \cref{fig:encoding-equation}.
\end{theorem}
\begin{proof}
    By the \((\encodingequation)\) equation we have that \(
    \iltikzfig{circuits/productivity/mealy-form}[core=\mealytofunc[f],delay=x, colour=seq]
    =
    \iltikzfig{circuits/algebraic/state-encoding}[core=\mealytofunc[f],delay=x,state=\listvar{s}]
    \); we need to `push' the encoder \(
    \iltikzfig{circuits/algebraic/encoder}
    \) through the state.
    Although the encoder is sequential, by the definition of \(\lvert-\rvert\),
    it must be of the form \(
    \iltikzfig{circuits/synthesis/normalised-function}[box=g]
    \) by definition of functional completeness; this means we can perform a
    variant of streaming.
    \begin{gather*}
        \iltikzfig{circuits/algebraic/encoding-state/step-0a}[box=g]
        \coloneqq
        \iltikzfig{circuits/algebraic/encoding-state/step-0}[box=g]
        \eqaxioms[\text{\cref{lem:unroll-waveform}}]
        \iltikzfig{circuits/algebraic/encoding-state/step-1}[box=g]
        \eqaxioms[\text{\cref{lem:generalised-streaming}}]
        \\[0.5em]
        \iltikzfig{circuits/algebraic/encoding-state/step-2}[box=g]
        \eqaxioms[\text{\cref{def:encoder}}]
        \iltikzfig{circuits/algebraic/encoding-state/step-3}[box=g]
        \coloneqq
        \\[0.5em]
        \iltikzfig{circuits/algebraic/encoding-state/step-4}[box=g]
        \coloneqq
        \iltikzfig{circuits/algebraic/encoding-state/step-5}[box=g]
    \end{gather*}
    The proof is completed by sliding the encoder around the trace.
\end{proof}

Before proceeding to our next set of equations, we will show how the encoding
equations can be used to encode the states of any circuit as those of a
denotationally equivalent one.
We are now ready to show that the encoding equations allow us to translate the
states of a circuit into those of a denotationally equivalent circuit.

\begin{corollary}
    For denotationally equivalent circuits \(
    \iltikzfig{circuits/productivity/mealy-form}[core=\mealytofunc[f],state=\listvar{s},colour=seq,dom=\listvar{m},cod=\listvar{n},delay=\listvar{x}]
    \) and \(
    \iltikzfig{circuits/productivity/mealy-form}[core=|g|,state=\listvar{t},colour=seq,dom=\listvar{m},cod=\listvar{n},delay=\listvar{y}]
    \), there exists \(
    \iltikzfig{circuits/productivity/mealy-form}[core=|h|,state=\listvar{t},colour=seq,dom=\listvar{m},cod=\listvar{n},delay=\listvar{x}]
    \) such that \(
    \iltikzfig{circuits/productivity/mealy-form}[core=\mealytofunc[f],state=\listvar{s},colour=seq,dom=\listvar{m},cod=\listvar{n},delay=\listvar{x}]
    =
    \iltikzfig{circuits/productivity/mealy-form}[core=|h|,state=\listvar{t},colour=seq,dom=\listvar{m},cod=\listvar{n},delay=\listvar{x}]
    \) by equations in \cref{fig:encoding-equation}.
\end{corollary}

If we have the right encoders, we can translate the initial state of a circuit
into a different word, and end up with a new circuit in a `Mealy form' with a
sequential core.
However, since the encoders, decoders, and core are essentially combinational,
these can be normalised once again to obtain a new normalised core.

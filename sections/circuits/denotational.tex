\chapter{Denotational semantics}

One can have potentially hours of fun making pretty pictures of circuits in
\(\scircsigma\).
Ultimately though, these circuits are still just \emph{syntax}; they have no
\emph{behaviour}, or more formally \emph{semantics}, assigned to them.
At its core, a semantics for digital circuits relates circuits which have `the
same behaviour given some interpretation'.
However, there is not just one way to construct said relation.
In this thesis we will examine three such ways: a \emph{denotational} semantics,
an \emph{operational} semantics and an \emph{algebraic} semantics.
Each approach comes with advantages and drawbacks; skillful use of all three
will lead to a powerful, fully compositional, perspective on sequential
circuits.

Although the construction of the semantic relation is different, each semantics
must relate the \emph{same} circuits; the behaviour of a circuit should not be
different depending on which lens we are viewing it through.
Formally, each form of semantics must be \emph{sound and complete} with respect
to each other; two sequential circuits \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=m,cod=n]
\) and \(
    \iltikzfig{strings/category/f}[box=g,colour=seq,dom=m,cod=n]
\) are related by one semantics if and only if they are related by the others.

First of all we will define the \emph{denotational semantics} of digital
circuits, which will act as the gold standard against which the other
semantics will be compared.
Denotational semantics is the notion of assigning meaning to structures using
values in some \emph{semantic domain}: a partially ordered set with some
extra structure.
The idea is an old one in computer science, going back to the work of Scott and
Strachey~\cite{scott1970outline,scott1971mathematical}.

\begin{example}
    Consider a language of mathematical expressions defined as
    follows:
    \[
        n \in N :\coloneqq \overline{0} \,|\, \overline{1} \,|\, \overline{2} \,|\,
        \cdots
        \qquad
        e \in E :\coloneqq add \, e \, e \,|\, mul \, e \, e \,|\,  n
    \]
    To define a denotational semantics for terms \(E\) in this language, we need
    to pick a \emph{semantic domain} for the denotations of terms to belong to.
    An obvious one here is the natural numbers \(\nat\); given a term
    \(e \in E\), we write \(\llbracket{e}\rrbracket\) for its denotation in
    \(\nat\).
    For each \(\overline{n} \in N\), \(\llbracket{\overline{n}}\rrbracket\) is
    the corresponding natural number, and the operations are interpreted as \(
        \llbracket{add \, e_1 \, e_2}\rrbracket
        = \llbracket{e_1}\rrbracket + \llbracket{e_2}\rrbracket
    \) and \(
        \llbracket{mul \, e_1 \, e_2}\rrbracket
        = \llbracket{e_1}\rrbracket \cdot \llbracket{e_2}\rrbracket
    \) respectively.
\end{example}

The above example illustrates quite nicely how a denotational semantics should
be \emph{compositional}; the denotations of a composite term should be
constructed by combining the denotations of its components.

\begin{remark}
    The content of this section is a refinement and expansion
    of~\cite[Section 3]{ghica2023compositional}.
\end{remark}

\section{Denotational semantics of digital circuits}

With a simple example under our belt, we turn to our true goal: defining a
denotational semantics for digital circuits.

\begin{remark}
    In \cite{mendler2012constructive}, the semantics of digital circuits with
    delays cycles are presented using \emph{timed ternary simulation}, an
    algorithm to compute how a sequence of circuit outputs stabilises over time
    given the inputs and value of the current state.
    This differs from our approach as we assign each circuit a concrete stream
    function describing its behaviour, rather than having to solve a system of
    equations in terms of the nodes inside a circuit in order to determine its
    behaviour.
\end{remark}

\subsection{Interpreting circuit components}

Before diving straight into what the denotation of a particular circuit \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=m,cod=n]
\) might be, we will first decide how to interpret the individual
\emph{components} of a given circuit signature.
This is crucial because a denotational semantics is defined
\emph{compositionally}; eventually we will need to refer to the interpretations
of particular components.

First we consider the interpretation of the \emph{values} that flow through the
wires in our circuits.
Recall that in a circuit signature these are specified by a set \(\values\).
In the denotational semantics, we need a bit more structure than this; values
will need a notion of \emph{order}.

\begin{definition}[Partially ordered set]
    A \emph{partially ordered set}, or \emph{poset} for short, is a set \(A\)
    equipped with a reflexive, antisymmetric, and transitive relation \(\leq\),
    i.e.\
    \begin{itemize}
        \item for all \(a \in A\), \(a \leq a\);
        \item for all \(a, b \in A\), if \(a \leq b\) and \(b \leq a\) then
                \(a = b\); and
        \item for all \(a, b, c \in A\), if \(a \leq b\) and \(b \leq c\) then
                \(a \leq c\).
    \end{itemize}
\end{definition}

To be more specific, values must be ordered by how much \emph{information} they
contain.
At the bottom of the order will be a value representing a complete \emph{lack}
of information; this corresponds to the disconnected wire generator \(
    \iltikzfig{strings/structure/monoid/init}[colour=comb]
\).
At the other end of the order will be a value representing \emph{every possible}
piece of information; a `short circuit'.

Mathematically-inclined readers (or partial order enjoyers) may have noticed
that what we have just described is more than just a vanilla partial order, but
in fact carries the structure of a \emph{lattice}.

\begin{definition}
    Given a poset \((A, \leq)\) and elements \(a, b\in A\), an
    \emph{upper bound} is an element \(c\) such that \(a \leq c\) and
    \(b \leq c\).
    An element \(d \in A\) is called the \emph{least upper bound} (or `join'),
    denoted \(a \vee b\), if it is an upper bound of \(a\) and \(b\), and for
    all other upper bounds \(c\) of \(a\) and \(b\), \(d \leq c\).

    Similarly, a \emph{lower bound} of \(a\) and \(b\) is an element \(c\) such
    that \(c \leq a\) and \(c \leq b\), and an element \(d \in A\) is called the
    \emph{greatest lower bound} (or `meet'), denoted \(a \wedge b\), if \(d\) is
    a lower bound of \(a\) and \(b\) and for all other lower bounds \(c\) of
    \(a\) and \(b\), \(c \leq d\).
\end{definition}

In general, the join and meet of a pair of elements in a poset need not exist.
We are interested in the structures in which they \emph{always} exist.

\begin{definition}[Lattice]
    A \emph{lattice} is a poset \((A, \leq)\) in which each pair of elements
    \(a,b \in A\) has a least upper bound and a greatest lower bound.
\end{definition}

By repeatedly taking the join of elements in a \emph{finite} lattice, one
obtains its \emph{supremum} \(\top\), the greatest element.
Conversely, by repeatedly taking the meet, one obtains its \emph{infimum}
\(\bot\), the least element.

\begin{example}\label{ex:powerset-lattice}
    Let \(A = \{0,1,2\}\), and let \((\mcp A, \subseteq)\) be the poset defined
    as the powerset of \(A\) ordered by subset inclusion.
    This poset can be illustrated by the following \emph{Hasse diagram}, in
    which a line going up from \(a\) to \(b\) indicates that \(a \leq b\).

    \begin{center}
        \begin{tikzcd}
            & \{0,1,2\} & \\
            \{0,1\} \arrow[dash]{ur} &
            \{0,2\} \arrow[dash]{u} &
            \{1,2\} \arrow[dash]{ul} \\
            \{0\} \arrow[dash]{u} \arrow[dash]{ur} &
            \{1\} \arrow[dash]{ul} \arrow[dash]{ur} &
            \{2\} \arrow[dash]{ul} \arrow[dash]{u} \\
            & \{\} \arrow[dash]{ul} \arrow[dash]{u} \arrow[dash]{ur} &
        \end{tikzcd}
    \end{center}

    The diagram clearly illustrates the lattice structure on this poset: the
    join is union and the meet is intersection.
    Subsequently the supremum \(\top\) is the set \(A\) and the
    infimum \(\bot\) is the empty set \(\{\}\).
\end{example}

Values in a circuit signature will be interpreted as elements of a finite
lattice; now the concepts of no information and all information are formalised
as the \(\bot\) and \(\top\) elements respectively.

Next the primitives in the signature must be interpreted.
Clearly they should be interpreted as functions, but no just any functions:
these functions must respect the order on the value lattice.
One should not be able to lose information by performing a computation!

\begin{definition}
    Let \((A, \leq_A)\) and \((B, \leq_B)\) be partial orders.
    A function \(\morph{f}{A}{B}\) is monotone if, for every \(x, y \in A\),
    \(x \leq_A y\) if and only if \(f(x) \leq_B f(y)\).
\end{definition}

One more conditions on functions is that when all the inputs to a primitive are
\(\bot\), then it should produce \(\bot\).
We cannot produce information from nothing!

\begin{definition}
    Let \(A,B\) be finite lattices, where \(\bot_A\) is the infimum of \(A\) and
    \(\bot_B\) is the infimum of \(B\).
    A function \(\morph{f}{A}{B}\) is \(\bot\)-preserving if
    \(f(\bot_A) = \bot_B\).
\end{definition}

Assigning interpretations to the combinational components of a circuit sets the
stage for the entire denotational semantics.

\begin{notation}
    Given a set \(A\) and a word \(\listvar{v} \in \natplus^\star\) of
    length \(n\), we write \(
        A^{\listvar{v}}
        \coloneqq
        A^{\listvar{v}(0)}
        \times
        A^{\listvar{v}(1)}
        \times
        \dots
        \times
        A^{\listvar{v}(n-1)}
    \).
\end{notation}

\begin{remark}
    If \(A\) is a lattice, then for any \(n \in \nat\), \(A^n\) is also a
    lattice by comparing elements pointwise.
    The \(\bot\) is then the word containing \(n\) copies of the \(\bot\)
    element in \(A\), and the same for the \(\top\) element.

    Recall the set \(A \coloneqq \{0,1,2\}\) from
    \cref{ex:powerset-lattice} and the lattice structure on its powerset
    \(\mathcal{P}A\).
    This induces an ordering on \((\mathcal{P}A)^2\):
    \(\{0,1\}\{1\} \leq \{0,1,2\}\{1,2\}\) because \(\{0,1\} \leq \{0,1,2\}\)
    and \(\{1\} \leq \{1,2\}\), and conversely
    \(\{0,1\}\{1\} \not\leq \{0\}\{1,2\}\) because \(\{0,1\} \not\leq \{0\}\).
    The join and meet are computed by taking the join and meet of each
    component: \(
        \{0,1\}\{1\} \vee \{0,1,2\}\{1,2\} = \{0,1,2\}\{1,2\}
    \) and \(
        \{0,1\}\{1\} \vee \{0\}\{1,2\} = \{0,1\}\{1,2\}
    \).

    For a word \(\listvar{n} \in \natplus^\star\), a lattice
    structure on \(A^{\listvar{n}}\) is induced in the same way.
\end{remark}

\begin{definition}[Interpretation]
    For a signature \(
        \signature = (
            \values, \bullet, \circuitsignaturegates, \circuitsignaturearity,
            \circuitsignaturecoarity
    )\), an \emph{interpretation} of
    \(\signature\) is a tuple \((\sqsubseteq, \gateinterpretation)\) where
    \((\values, \sqsubseteq)\) is a lattice with \(\bullet\) as the
    infimum, and \(\gateinterpretation\) maps each
    \(p \in \circuitsignaturegates\) to a \(\bot\)-preserving monotone function
    \(
        \valuetuple{\circuitsignaturearity(p)}
        \to
        \valuetuple{\circuitsignaturecoarity(p)}
    \).
\end{definition}

\begin{example}
    Recall the Belnap signature \(
        \belnapsignature = (
            \belnapvalues, \bot, \belnapgates, \belnaparity, \belnapcoarity
        )
    \) from \cref{ex:belnap-signature}.
    We assign a partial order \(\leq_\mathsf{B}\) to values in
    \(\belnapvalues\) as follows:

    \begin{center}
        \begin{tikzcd}
            & \top & \\
            \belnapfalse \arrow[dash]{ur} & & \belnaptrue \arrow[dash]{ul} \\
            & \bot \arrow[dash]{ul} \arrow[dash]{ur} &
        \end{tikzcd}
    \end{center}

    The gate interpretation \(\belnapgateinterpretation\) has action \(
        \andgate \mapsto \land, \orgate \mapsto \lor, \notgate \mapsto \neg
    \) where \(\land\), \(\lor\) and \(\neg\) are defined by the following
    truth tables~\cite{belnap1977useful}:

    \begin{center}
        \begin{tabular}{|c|cccc|}
            \hline
            \(\land\) & \(\bot\) & \(\belnapfalse\) & \(\belnaptrue\) & \(\top\) \\
            \hline
            \(\bot\)  & \(\bot\) & \(\belnapfalse\) & \(\bot\) & \(\belnapfalse\) \\
            \(\belnapfalse\) & \(\belnapfalse\) & \(\belnapfalse\) & \(\belnapfalse\) & \(\belnapfalse\) \\
            \(\belnaptrue\) & \(\bot\) & \(\belnapfalse\) & \(\belnaptrue\) & \(\top\) \\
            \(\top\) & \(\belnapfalse\) & \(\belnapfalse\) & \(\top\) & \(\top\) \\
            \hline
        \end{tabular}
        \quad
        \begin{tabular}{|c|cccc|}
            \hline
            \(\lor\) & \(\bot\) & \(\belnapfalse\) & \(\belnaptrue\) & \(\top\) \\
            \hline
            \(\bot\)  & \(\bot\) & \(\bot\) & \(\belnaptrue\) & \(\belnaptrue\) \\
            \(\belnapfalse\) & \(\bot\) & \(\belnapfalse\) & \(\belnaptrue\) & \(\top\) \\
            \(\belnaptrue\) & \(\belnaptrue\) & \(\belnaptrue\) & \(\belnaptrue\) & \(\belnaptrue\) \\
            \(\top\) & \(\belnaptrue\) & \(\top\) & \(\belnaptrue\) & \(\top\) \\
            \hline
        \end{tabular}
        \quad
        \begin{tabular}{|c|c|}
            \hline
            \(\neg\) & \\
            \hline
            \(\bot\) & \(\bot\) \\
            \(\belnaptrue\) & \(\belnapfalse\) \\
            \(\belnapfalse\) & \(\belnaptrue\) \\
            \(\top\) & \(\top\) \\
            \hline
        \end{tabular}
    \end{center}

    The Belnap interpretation is then \(
        (\leq_\mathsf{B}, \belnapgateinterpretation)
    \).
\end{example}
\subsection{Denotational semantics of combinational circuits}

The semantic domain for \emph{combinational} circuits is straightforward: each
circuit maps to a monotone function.

\begin{definition}
    Let \(\funci\) be the \(\natplus\)-coloured PROP in which the morphisms
    \(\listvar{m} \to \listvar{n}\) are the monotone \(\bot\)-preserving
    functions \(\valuetuple{\listvar{m}} \to \valuetuple{\listvar{n}}\).
\end{definition}

\begin{definition}
    Let \(\morph{\circuittofunci}{\ccircsigma}{\funci}\) be the coloured PROP
    morphism with action defined as%
    \vspace{-\abovedisplayskip}
    % \vspace{-\parskip}
    \begin{center}
        \begin{minipage}{0.32\textwidth}
            \centering
            \begin{align*}
                \circuittofunci[
                    \iltikzfig{strings/structure/comonoid/copy}
                ]
                &\coloneqq
                (v) \mapsto (v, v)
                \\
                \circuittofunci[
                    \iltikzfig{strings/structure/monoid/merge}
                ]
                &\coloneqq
                (v, w) \mapsto v \sqcup w
            \end{align*}
        \end{minipage}
        \quad
        \begin{minipage}{0.25\textwidth}
            \centering
            \begin{align*}
                \circuittofunci[
                    \iltikzfig{strings/structure/comonoid/discard}
                ]
                &\coloneqq
                (v) \mapsto ()
                \\
                \circuittofunci[
                    \iltikzfig{strings/structure/monoid/init}
                ]
                &\coloneqq
                () \mapsto \bot
            \end{align*}
        \end{minipage}
        \quad
        \begin{minipage}{0.25\textwidth}
            \centering
            \vspace{1.5em}
            \(\circuittofunci[
                \iltikzfig{circuits/components/gates/gate}[gate=p,dom=\listvar{m},cod=\listvar{n}]
            ]
            \coloneqq
            \gateinterpretation[p]
            \)
        \end{minipage}
    \end{center}
\end{definition}

\begin{remark}
    One might wonder why the fork and the join have different semantics, as they
    would be physically realised by the same wiring.
    This is because digital circuits have a notion of \emph{causality}: outputs
    can only connect to inputs.
    This is why the semantics of combinational circuits is \emph{functions} and
    not \emph{relations}.

    In real life one could force together two digital devices, but this might
    lead to undefined behaviour in the digital realm.
    This is reflected in the semantics by the use of the join; for example, in
    the Belnap interpretation if one tries to join together \(\belnaptrue\) and
    \(\belnapfalse\) then the overspecified \(\top\) value is produced.
\end{remark}

\subsection{Denotational semantics of sequential circuits}

As one might expect, sequential circuits are slightly trickier to deal with.
In a combinational circuit, the output only depends on the inputs at the current
cycle, but for sequential circuits inputs can affect outputs many cycles after
they occur.

We therefore have to reason with \emph{streams} (infinite sequences) of inputs
rather than individual values.

\begin{notation}
    Given a set \(A\), we denote the set of streams (infinite sequences) of
    \(A\) by \(\stream{A}\).
    As a stream can equivalently be viewed as a function \(\nat \to A\), we
    write \(\sigma(i) \in A\) for the \(i\)-th element of stream
    \(\sigma \in \stream{A}\).
    Individual streams are written as \(
        \sigma \in \stream{A}
        \coloneqq
        \sigma(0) \streamcons \sigma(1) \streamcons
        \sigma(2) \streamcons \cdots
    \).
\end{notation}

\begin{definition}[Operations on streams]\label{def:stream-operations}
    Given a stream \(\sigma \in \stream{A}\), its \emph{initial value}
    \(\streaminit(\sigma) \in A\) is defined as \(\sigma \mapsto \sigma(0)\)
    and its \emph{stream derivative} \(\streamderv(\sigma) \in \stream{A}\) is
    defined as \(\sigma \mapsto (i \mapsto \sigma(i+1))\).
\end{definition}

\begin{notation}
    For a stream \(\sigma\) with initial value \(a\) and stream derivative
    \(\tau\) we write it as \(\sigma \coloneqq a \streamcons \tau\).
\end{notation}

Streams will serve as our inputs and outputs.
The denotations of sequential circuits themselves will therefore be
\emph{stream functions}, which consume and produce streams.
However, just like with functions we cannot just claim that all streams are the
denotations of sequential circuits!

\begin{definition}[Causal stream function~\cite{rutten2006algebraic}]
    A stream function \(\morph{f}{\stream{A}}{\stream{B}}\) is \emph{causal} if
    for all \(i \in \nat\), \(j \leq i\), and \(\sigma,\tau \in \stream{M}\),
    \(\sigma(j) = \tau(j)\) implies that \(f(\sigma)(i) = f(\tau)(i)\).
\end{definition}

Casuality is a form of continuity; a causal stream function is a stream function
in which the \(i\)-th element of its output stream only depends on elements
\(0\) through \(i\) inclusive of the input stream; it cannot look into the
future!

A neat consequence of causality is that it enables us to lift the stream
operations of initial value and stream derivative to stream \emph{functions}.

\begin{definition}[Initial output~\cite{rutten2006algebraic}]
    For a causal stream function \(\morph{f}{\stream{A}}{\stream{B}}\) and
    \(a \in A\), the \emph{initial output of \(f\) on input \(a\)} is
    \(\initialoutput{f}{a} \coloneqq \streaminit(f(a \streamcons \sigma))\) for an
    arbitrary \(\sigma \in \stream{A}\).
\end{definition}

Since \(f\) is causal, the stream \(\sigma\) in the definition of initial
output truly is arbitrary; the \(\streaminit\) function only depends on the
first element of the stream.

\begin{definition}[Functional stream derivative~\cite{rutten2006algebraic}]
    For a causal stream function \(\morph{f}{\stream{A}}{\stream{B}}\) and
    \(a \in A\), the
    \emph{functional stream derivative of \(f\) on input \(a\)} is the
    stream function \(
        \streamderivative{f}{a}
        \coloneqq
        \sigma \mapsto \streamderv(f(a \streamcons \sigma))
    \).
\end{definition}

The functional stream derivative \(\streamderivative{f}{a}\) is a new stream
function which acts as \(f\) would `had it seen \(a\) first'.

\begin{remark}
    One intuitive way to view stream functions is to think of them as the states
    of some Mealy machine; the initial output is the output given some input,
    and the functional stream derivative is the transition to a new state.
    As with most things in mathematics, this is no coincidence; there is a
    homomorphism from any Mealy machine to a stream function.
    But we're getting ahead of ourselves; more on that later.
\end{remark}

The functional stream derivative, and indeed the above remark, leads us to the
next property of denotations of sequential circuits.
Although they may have infinitely many inputs and outputs, circuits themselves
are built from a finite number of components.
This means they cannot specify infinite \emph{behaviour}.

\begin{notation}
    Given a finite word \(\listvar{a} \in \freemon{A}\), we abuse notation
    somewhat and write \(\streamderivative{f}{\listvar{a}}\) for the repeated
    application of the functional stream derivative for the elements of
    \(\listvar{a}\), i.e.\ \(
        \streamderivative{f}{\varepsilon} \coloneqq f
    \) and \(
        \streamderivative{f}{a \streamcons \listvar{b}} \coloneqq
        \streamderivative{(\streamderivative{f}{a})}{\listvar{b}}
    \).
\end{notation}

\begin{definition}
    Given a stream function \(\morph{f}{\stream{A}}{\stream{B}}\), we say it is
    \emph{finitely specified} if the set \(\{
        \streamderivative{f}{\listvar{a}} \,|\, \listvar{a} \in \freemon{A}
    \}\) is finite.
\end{definition}

The final condition arises since the components of circuits are monotone.
To equip streams with a similar notion, we must set an order on them.

\begin{notation}
    For a poset \(A\) and streams \(\sigma,\tau \in \stream{A}\), we say that
    \(\sigma \leq_{\stream{A}} \tau\) if \(\sigma(i) \leq_A \tau(i)\) for all
    \(i \in \nat\).
\end{notation}

Monotonicity of stream functions is then defined just like monotonity for normal
functions.

This completes the trio of properties we need to express the semantics of
sequential circuits as stream functions.
To this aim, we will now asssemble them into a \(\natplus\)-coloured PROP.

\begin{lemma}\label{lem:causality-preserved}
    Causality is preserved by composition and tensor product.
\end{lemma}
\begin{proof}
    If the \(i\)-th element of two stream functions \(f\) and \(g\) only depends
    on the first \(i+1\) elements of the input, then so will their composition.
\end{proof}

\begin{lemma}\label{lem:finitely-specified-preserved}
    Finite specification is preserved by composition and tensor product.
\end{lemma}
\begin{proof}
    For both the composition and product of two stream functions \(f\) and
    \(g\), the largest the set of stream derivatives could be is the product of
    stream derivatives of \(f\) and \(g\), so this will also be finite.
\end{proof}

\begin{lemma}\label{lem:monotonicity-preserved}
    Monotonicity is preserved by composition and tensor product.
\end{lemma}
\begin{proof}
    The composition and product of any monotone function is monotone.
\end{proof}

Since , then tables

\begin{notation}
    Given stream functions \(\sigma \in A^m\) and \(\tau \in A^n\), we write
    \(\sigma\tau \in A^{m+n}\) for their pointwise concatenation, i.e\
    \((\sigma\tau)(i) = \sigma(i)\tau(i)\).
\end{notation}

\begin{proposition}
    There is a bundled \(\natplus\)-coloured PROP \(\streami\) where morphisms
    \(\listvar{m} \to \listvar{n}\) are the causal, finitely specified and
    monotone stream functions \(
        \valuetuplestream{\listvar{m}} \to \valuetuplestream{\listvar{n}}
    \).
\end{proposition}
\begin{proof}
    Identity is the identity function, the symmetry swaps streams, composition
    is function composition, tensor is product, and the bundlers and splitters
    are the components of the isomorphism \(
        (\stream{\values})^{\listvar{m}}
        \cong
        (\valuetuplestream{\listvar{m}})
    \).

    As these constructs satisfy the categorical axioms, and as composition and
    tensor preserve causality (\cref{lem:causality-preserved}),
    finite specification (\cref{lem:finitely-specified-preserved}),
    and monotonicity (\cref{lem:monotonicity-preserved}), this data defines a
    bundled \(\natplus\)-coloured PROP.
\end{proof}

Modelling sequential circuits as stream functions deals with the temporal
aspects of the former, but what about feedback?
As the assignment of denotations to circuits needs to be compositional, we need
to map the trace on \(\scircsigma\) to a trace on \(\streami\).
For this, we will need a notion of ordering on stream functions themselves.

\begin{definition}\label{def:state-order}
    Let \(A\) and \(B\) be posets and let
    \(\morph{f, g}{\stream{A}}{\stream{B}}\) be stream functions.
    We say \(f \stateorder g\) if \(f(\sigma) \leq_{\stream{B}} g(\sigma)\)
    for all \(\sigma \in \stream{A}\).
\end{definition}

A trace on \(\streami\) can now be defined in terms of a least fixed
point\footnote{The original proof idea for the following is by David Sprunger.}.

\begin{notation}
    For a morphism \(
        \morph{f}{\valuetuplestream{\listvar{xm}}}{\valuetuplestream{\listvar{xn}}}
        \in \streami
    \), and stream \(\sigma \in \valuetuplestream{\listvar{xm}}\), let
    \(\mu_f(\sigma)\) be the least fixed point of the endofunction \(
        \tau \mapsto \proj{0}\left(f(\tau\sigma)\right)
    \).
\end{notation}

\begin{proposition}
    The function \(\sigma \mapsto \proj{1}\left(f(\mu_f(\sigma)\sigma)\right)\)
    is a trace on \(\streami\).
\end{proposition}
\begin{proof}
    To show this, we must first show that
    \(\sigma \mapsto \proj{1}\left(f(\mu_f(\sigma)\sigma)\right)\) is in
    \(\streami\): it is causal, finitely specified, and monotone.

    Since \(
        \morph{f}{\valuetuplestream{\listvar{xm}}}{\valuetuplestream{\listvar{xm}}}
    \) is a morphism of \(\streami\), it has finitely many stream derivatives.
    For each stream derivative \(\streamderivative{f}{\,\listvar{w}}\), let the
    function \(
        \morph{
            \widehat{\streamderivative{f}{\listvar{w}}}
        }{
            \valuetuplestream{\listvar{xm}}
        }{
            \valuetuplestream{\listvar{x}}
        }
    \) to be \(
        \tau\sigma
        \mapsto
        \proj{0}(\streamderivative{f}{\listvar{w}}(\tau\sigma))
    \).
    Note that each of these functions are causal and monotone, because they are
    constructed from pieces that are causal and monotone.

    In particular, \(\mu_f(\sigma)\) is the least fixed point of
    \(\widehat{f_\varepsilon}\left((-)\sigma\right)\).
    Using the Kleene fixed point theorem, the least fixed point of
    \(\widehat{f}((-)\sigma)\) can be obtained by composing
    \(\widehat{f}((-)\sigma)\) repeatedly with itself.
    This means that \(
        \mu_f(\sigma)
        =
        \bigsqcup_{k \in \nat} \widehat{f^k}(\bot^\omega,\sigma)
    \) where \(\widehat{f^k}\) is the \(k\)-fold composition of \(f(-,\sigma)\)
    with itself, i.e.\ \(\widehat{f^0}(\tau\sigma) = \tau\) and \(
        \widehat{f^{k+1}}(\tau\sigma)
        =
        \widehat{f}\left(\left(\widehat{f^{k}}(\sigma, \tau)\right)\sigma\right)
    \).
    That the mapping \(\mu_f\) is causal and monotone is
    straightforward: each of the functions in the join is causal and monotone,
    and join preserves these properties.
    It remains to show this mapping has finitely many stream derivatives.

    When equipped with \(\stateorder\), the set of functions
    \(\valuetuplestream{\listvar{xm}} \to \valuetuplestream{\listvar{x}}\)
    is a poset, of which
    \(\{\widehat{f_w} \,|\, w \in (\valuetuple{\listvar{xm}})^\star\}\)
    is a finite subset.
    Restricting the ordering \(\stateorder\) to this set yields a finite poset.
    Since this poset is finite, the set of strictly increasing sequences in this
    poset is also finite.
    We will now demonstrate a relationship between these sequences and stream
    derivatives of \(\mu_f\).

    Suppose \(
        S = \widehat{f_{\,\listvar{w_0}}} \prec \widehat{f_{\,\listvar{w_1}}} \prec
            \cdots \prec \widehat{f_{\,\listvar{w_{\ell-1}}}}
    \) is a strictly increasing sequence of length \(\ell\) in the set of stream
    functions \(
        \{\widehat{f_w} \,|\, w \in (\valuetuple{\listvar{xm}})^\star\}
    \).
    We define a function \(
        \morph{g_S}{
            \valuetuplestream{\listvar{m}}
        }{
            \valuetuplestream{\listvar{x}}
        }
    \) as \(
        (\sigma) \mapsto \bigsqcup_{k \in \nat} g_k(\sigma)
    \) where \[
        g_k(\sigma) =
        \begin{cases}
            \bot^\omega & \text{ if } k = 0 \\
            \widehat{f_{\,\listvar{w_k}}}(\left(g_{k-1}(\sigma)\right)\sigma) & \text{ if } 1 \leq k \leq \ell \\
            \widehat{f_{\,\listvar{w_{\ell-1}}}}(\left(g_{k-1}(\sigma)\right)\sigma) & \text{ if } \ell < k
        \end{cases}.
    \]
    Let the set \(G \coloneqq \{
        g_S \,|\, S \text{ is a strictly increasing sequence}
    \}\).
    When \(S\) is set to the one-item sequence \(\widehat{f}\), \(g_S\) is
    \(\mu_f\), so \(\mu_f \in G\).
    As \(G\) is finite, this means that if \(G\) is closed under stream
    derivative, \(\mu_f\) has finitely many stream derivatives.
    Any element of \(G\) is either \(\bot^\omega\) or has the form \(
        \sigma
        \mapsto
        \widehat{\streamderivative{f}{\,\listvar{w}}}(g_k(\sigma)\sigma)
    \) for some \(\sigma \in \valuetuplestream{\listvar{m}}\) and
    \(k > 0\).
    As \(\bot^\omega\) is its own stream derivative, we need to show that
    applying stream derivative to the latter produces another element of \(G\).
    \begin{align*}
        \streamderivative{\sigma \mapsto \left(\widehat{\streamderivative{f}{\, \listvar{w}}}(\left(g_{k-1}(\sigma)\right)\sigma)\right)}{ab}
            &= \sigma \mapsto \streamderv\left(\widehat{\streamderivative{f}{\, \listvar{w}}}(ab \streamcons \left(g_{k-1}(\sigma)\right)\sigma)\right) \\
            &= \sigma \mapsto \streamderv\left(\proj{0}\left(\streamderivative{f}{\, \listvar{w}}(ab \streamcons \left(g_{k-1}(\sigma)\right)\sigma)\right)\right) \\
            &= \sigma \mapsto \proj{0}\left(\streamderv\left(\streamderivative{f}{\, \listvar{w}}(ab \streamcons \left(g_{k-1}(\sigma)\right)\sigma)\right)\right) \\
            &= \sigma \mapsto \proj{0}\left(\streamderivative{\left(\streamderivative{f}{\, \listvar{w}}(\left(g_{k-1}(\sigma)\right)\sigma)\right)}{ab}\right) \\
            &= \sigma \mapsto \proj{0}\left(\streamderivative{f}{\, ab \streamcons \listvar{w}}(\left(g_{k-1}(\sigma)\right)\sigma)\right) \\
            &= \sigma \mapsto \widehat{\streamderivative{f}{\, ab \streamcons \listvar{w}}}(\left(g_{k-1}(\sigma)\right)\sigma)
        \end{align*}
    As \(\proj{0}\left(\streamderivative{f}{ab \streamcons \listvar{w}}\right)\)
    is in \(G\), the latter  is closed under stream derivative.
    Subsequently, \(\mu_f\) has finitely many stream derivatives.

    This means that all the components of
    \(\sigma \mapsto \proj{1}(f(\mu_f(\sigma)\sigma))\) are causal, monotone and
    finitely specified, and as these properties are preserved by composition,
    the composite must also have them, so
    \(\sigma \mapsto \proj{1}(f(\mu_f(\sigma)\sigma))\) is in \(\streami\).
    To show that this is a trace, it remains to check the axioms of STMCs,
    which can all be shown to hold fairly easily.
\end{proof}

\begin{remark}
    Using the least fixpoint as a trace operator is a common idea in the
    denotational semantics of programming languages, where it is often used to
    model \emph{recursion}.
\end{remark}

We now have two traced PROPs: a \emph{syntactic} category of sequential circuit
terms \(\scircsigma\) and a \emph{semantic} category of causal, finitely
specified, monotone stream functions \(\streami\).
To assign semantics in the latter to terms in the former, we use a traced PROP
morphism.
First we establish candidates for the semantics of the sequential generators.

\begin{definition}\label{def:state-stream-functions}
    For each \(v \in \values\), let \(
        \morph{\valstream{v}}{\valuetuplestream{0}}{\valuestream}
    \) be defined as \(
        \mealyoutput{(\valstream{v})}{()} := v
    \) and \(
        \mealytransition{(\valstream{v})}{()} := \valstream{\bot}
    \).
    Let \(
        \morph{\shiftstream{v}}{\valuestream}{\valuestream}
    \) be defined as \(
        \mealyoutput{(\shiftstream{v})}{\sigma}
        :=
        v
    \) and \(
        \mealytransition{(\shiftstream{v})}{a \streamcons \sigma}
        :=
        \shiftstream{a}
    \).
\end{definition}

\begin{lemma}
    The stream functions in \cref{def:state-stream-functions} are causal,
    monotone and finitely specified.
\end{lemma}
\iftoggle{proofs}{
    \begin{proof}
        \input{sections/semantics/proofs/example-streams}
    \end{proof}
}{}

With those out of the way, we can move onto the complete translation.

\begin{definition}\label{def:circuit-to-stream}
    Let \(
        \morph{\circuittostream{\interpretation}}{\scircsigma}{\streami}
    \) be the traced PROP morphism defined as \begin{gather*}
        \circuittostream[
            \iltikzfig{strings/category/f}[box=F,colour=comb]
        ]{\interpretation}(\sigma)(k)
        :=
        \circuittofunc[
            \iltikzfig{strings/category/f}[box=F,colour=comb]
        ]{\interpretation}(\sigma(k))
        \\
        \circuittostream[
            \iltikzfig{circuits/components/values/vs}[val=v]
        ]{\interpretation}
        :=
        \valstream{v}
        \quad
        \circuittostream[
            \iltikzfig{circuits/components/waveforms/delay}
        ]{\interpretation}
        :=
        \shiftstream{\bot}
    \end{gather*}

    Given a sequential circuit \(
        \iltikzfig{strings/category/f}[box=F,colour=seq]
    \), we say that the stream function \(
        \circuittostream[\iltikzfig{strings/category/f}[box=F,colour=seq]]{\interpretation}
    \) is its \emph{behaviour under} \(\interpretation\).
\end{definition}

If we were less invested in this, we could stop here.
Each circuit in \(\scircsigma\) now has a denotation in \(\scircsigma\): what
more could we want?
But we are not content with this, for we are mathematicians.
We need to show that this is a \emph{complete} denotational semantics: every
stream function in \(\streami\) must also correspond to at least one
circuit in \(\scircsigma\).
\chapter{Monoidal categories and theories}

\section{Terms}

Processes are modelled as \emph{terms}.
Before we can begin, the components that make up processes in a given system
must be sepcified.

\begin{notation}[Words]
    Given a set \(X\), the set of words of elements of \(X\) is denoted
    \(\freemon{X}\).
    Arbitrary words are written with an overline \(
        \overline{x}, \overline{y}, \overline{z}... \in \freemon{X}
    \); given two words \(\overline{x}, \overline{y}\), their concatenation is
    denoted \(\overline{x}\overline{y}\).
\end{notation}

\begin{definition}
    Let \(\natplus\) be the set of non-zero natural numbers.
\end{definition}

\begin{definition}[Generators]
    A set of \emph{generators} is a set \(\generators\) equipped with two
    functions \(\morph{\dom,\cod}{\generators}{\natplus^\star}\).
\end{definition}

Generators are the primitive building blocks of terms: their domains and
codomains specify the widths of their input and output wires respectively.
Terms are defined by combining these primitives together.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of generators.
    A \(\generators\)-term is written \(\morph{f}{\overline{m}}{\overline{n}}\)
    where \(\overline{m}, \overline{n} \in \natplus^\star\).
    The set of \(\generators\)-terms, denoted \(\sigmaterms\), is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\dom[\phi]}{\cod[\phi]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[n]}{[n]}{[n]} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(
                \morph{\swap{m}{n}}{[m,n]}{[n,m]} \in \sigmaterms
            \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{n}}{\overline{p}} \in \sigmaterms\)}
            \BinaryInfC{\(\morph{f \seq g}{\overline{m}}{\overline{p}} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{p}}{\overline{q}} \in \sigmaterms\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{\overline{m} \concat \overline{p}}{\overline{n} \concat \overline{q}} \in \sigmaterms
            \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms are constructed recursively.
There are three base cases: a generator from \(\generators\) with appropriate
inputs and outputs;
an \emph{identity} for empty wires with no generators;
and a \emph{symmetry} for swapping over two wires.
The two inductive cases are called \emph{composition} and \emph{tensor}
respectively.
Intuitively, these can be thought of generating larger terms by sequencing
subterms in sequence or parallel.

\(\Sigma\)-terms will be abbreviated to `terms' when the signature is clear from
context.

\section{Structural equations}

So far, terms are purely syntax, and terms are only equal if they are
constructed in precisely the same way.
Even without considering the interaction of generators with each other, there
are numerous `structural equations' which need to hold to be useful for
modelling processes.

\begin{example}
    Consider the term \(f \seq \id[n]\), which can be read as `run \(f\) and
    then do nothing'.
    Since we are only concerned with the \emph{input-output} behaviour of
    processes, this morally should be the same as just \(f\).
    However, as it stands \(f \seq \id[n]\) and \(f\) are not equal.
\end{example}

One could just add all the `right' equations manually, but what are the `right'
equations?
It turns out that an elegant mathematical formalism exists in the form of
\emph{symmetric monoidal categories}.

\begin{definition}[Categories]
    \label{def:category}
    A \emph{category} \(\mcc\) consists of a class of \emph{objects}
    \(\ob{\mcc}\); a class of \emph{morphisms} \(\mor{\mcc}{A}{B}\)
    for every pair of objects \(A, B \in \ob{\mcc}\); and a \emph{composition}
    operation \(
        \morph{
            {-} \circ {=}
        }{
            \mor{\mcc}{B}{C} \times \mor{\mcc}{A}{B}
        }{
            \mor{\mcc}{A}{C}
        }
    \) such that
    \begin{itemize}
        \item composition is \emph{unital}: for every \(
                    A \in \ob{\mcc}
                \) there exists an \emph{identity morphism} \(
                    \id[A] \in \mor{\mcc}{A}{A}
                \) satisfying \(
                    f \circ \id[A] = f = \id[B] \circ f
                \) for any \(
                    f \in \mor{\mcc}{A}{B}
                \); and
        \item composition is \emph{associative}: for any morphisms \(
                    f \in \mor{\mcc}{A}{B}
                \), \(
                    g \in \mor{\mcc}{B}{C}
                \) and \(h \in \mor{\mcc}{C}{D}\), \(
                    (h \circ g) \circ f = h \circ (g \circ f).
                \)
    \end{itemize}
\end{definition}

A morphism \(f \in \mor{\mcc}{A}{B}\) is also called an \emph{arrow}, and will
often be written \(\morph{f}{A}{B}\) accordingly.
The subscripts on the object and morphism classes are also often omitted.
Equations in category theory can be expressed using \emph{commutative diagrams}.
For example, the unitality and associativity of composition can be illustrated
as follows:

\begin{center}
    \includestandalone{figures/category/coherences/unitality}
    \quad
    \includestandalone{figures/category/coherences/associativity}
\end{center}

We say that the above two diagrams \emph{commute} precisely because \(
    \id[B] \circ f = f \circ \id[A]
\): no matter which path one takes, the results are equal.

\begin{example}[Preorder]
    A \emph{preorder} is a binary relation \(\leq\) on a set \(X\) which is
    reflexive and transitive.
    Any preorder generates a category \(\mcc_\leq\): the objects are the
    elements of \(X\) and \(\mcc_\leq(x, y)\) contains exactly one morphism if
    \(x \leq y\) and none otherwise.
\end{example}

\begin{example}[Category of sets]
    The category \(\set\) has sets as objects and functions as morphisms.
    Composition is then just function composition.
\end{example}

\section{Monoidal categories}

It is easy to see how processes can be viewed as morphisms: a morphism
\(\morph{f}{A}{B}\) is a process that transforms some input of type \(A\) into
an output of type \(B\).
Composition allows us to string together multiple processes \(f, g, h\) in
sequence to create a composite process \(f \seq g \seq h\), where we use
\emph{diagrammatic order} composition \(f \seq g := g \circ f\).

However, these processes are not particularly interesting: the inputs and
outputs can only be single types of and there is no notion of parallelism.
These issues can be allayed by adding structure to elevate a category into a
\emph{monoidal} category, which has a notion of \emph{parallel} composition in
addition to the already defined \emph{sequential} composition.
The parallel composition structure can be added to a regular category by using
another notion from category theory: that of a \emph{functor}.

\begin{definition}[Functor]
    Given two categories \(\mcc\) and \(\mcd\), a \emph{functor} \(
        \morph{F}{\mcc}{\mcd}
    \) maps objects and morphisms in \(\mcc\) to objects and morphisms in
    \(\mcd\) such that
    \begin{itemize}
        \item \(F(\id[A]) = \id[FA]\) for every \(A \in \ob{\mcc})\); and
        \item \(F(g \circ f) = F(g) \circ F(f)\) for every \(\morph{f}{A}{B}\)
        and \(\morph{g}{B}{C}\).
    \end{itemize}
\end{definition}

A functor \(F\) is a mapping between categories: it maps an object \(X\) in one
category to an object \(FX\) in another, and morphisms \(\morph{f}{X}{Y}\) to
\(\morph{Ff}{FX}{FY}\).

\begin{definition}[Endofunctor]
    An \emph{endofunctor} is a functor from a category to itself.
\end{definition}

\begin{definition}[Natural transformation]
    Given two functors \(\morph{F, G}{\mcc}{\mcd}\), a
    \emph{natural transformation} \(\morph{\eta}{F}{G}\) is a family of
    morphisms \(
        \eta_A \in \mor{\mcd}{FA}{GA}
    \) called \emph{components} for each \(A \in \ob{\mcc}\) such that \(
        \eta_B \circ Ff = Gf \circ \eta_A
    \), i.e.\ the following diagram commutes:
    \begin{center}
        \includestandalone{figures/category/coherences/natural}
    \end{center}
\end{definition}

The key point to take is that for functors \(\morph{F,G}{\mcc}{\mcd}\), a
natural transformation \(\morph{\eta}{F}{G}\) is a \emph{family} of morphisms
\(\morph{\eta_A}{FA}{GA} \in \mcd\) for each object \(A \in \mcd\).



\begin{definition}[Product category]
    Given two categories \(\mcc\) and \(\mcd\), their \emph{product category}
    \(\mcc \times \mcd\) is the category with objects are defined as \(
        \ob{(\mcc \times \mcd)} := \ob{\mcc} \times \ob{\mcd}
    \) and the morphisms as \[
        \mor{(\mcc \times \mcd)}{(A, A^\prime)}{(B, B^\prime)}
        :=
        \{
            (f, f^\prime)
            \,|\,
            f \in \mor{\mcc}{A}{B},
            f^\prime \in \mor{\mcd}{A^\prime}{B^\prime}
        \}
    \]
\end{definition}

\begin{definition}[Bifunctor]
    A \emph{bifunctor} is a functor with a product category as its domain, i.e.\
    a functor of the form \(\mcc \times \mcd \to \mce\).
\end{definition}

\begin{definition}[Isomorphism]
    A morphism \(\morph{f}{A}{B} \in \mcc\) is called an \emph{isomorphism} (or
    simply \emph{iso} for short) if there also exists a morphism \(
        \morph{\inverse{f}}{B}{A} \in \mcc
    \) such that \(
        \inverse{f} \circ f = \id[A]
    \) and \(
        f \circ \inverse{f} = \id[B]
    \).
\end{definition}

\begin{example}
    A morphism in \(\set\) is an iso if and only if it is a bijection.
\end{example}

\begin{definition}[Natural isomorphism]
    A natural transformation is called a \emph{natural isomorphism} if every
    component is an isomorphism.
\end{definition}

We now have all the components necessary in order to define a monoidal category,
a category with notions of both sequential and parallel composition.

\begin{definition}[Monoidal category]
    \label{def:monoidal-category}
    A \emph{monoidal category} is a category \(\mcc\) equipped with a
    bifunctor \(\morph{{-} \tensor {=}}{\mcc \times \mcc}{\mcc}\) called the
    \emph{tensor product} and an additional object \(I\) called the
    \emph{monoidal unit},
    along with natural isomorphisms
    \begin{itemize}
        \item \(
            \associator{A}{B}{C}
            \colon
            A \tensor (B \tensor C)
            \cong
            (A \tensor B) \tensor C
            \) called the \emph{associator};
        \item \(
            \leftunitor{A}
            \colon
            I \tensor A
            \cong
            A
            \) called the \emph{left unitor}; and
        \item \(
            \rightunitor{A}
            \colon
            A \tensor I
            \cong
            A
            \) called the \emph{right unitor}
    \end{itemize}
    such that the \emph{pentagon} and the \emph{triangle} diagrams below
    commute:
    \begin{center}
        \includestandalone{figures/category/coherences/pentagon}

        \vspace{1em}

        \includestandalone{figures/category/coherences/triangle}
    \end{center}
\end{definition}

We adopt the convention that \(f \tensor g \seq h \tensor k\) should be
bracketed as \((f \tensor g) \seq (h \tensor k)\), i.e.\ \(\tensor\) binds
more strongly than \(\seq\).
Later in this chapter we will provide an alternative notation for terms
in monoidal categories which will make this distinction redundant.

\begin{example}
    \(\set\) is a monoidal category, with the tensor product defined as the
    Cartesian product (\(A \tensor B := A \times B\)) and the unit as the
    singleton set (\(I := \mathbbm{1}\)).
    The natural isomorphisms are identities.
\end{example}

This situation where the natural isomorphisms are identities arises frequently,
so it has its own name.

\begin{definition}[Strict monoidal category]
    A monoidal category is called \emph{strict} if the natural isomorphisms \(
        \associator{A}{B}{C}
    \), \(
        \leftunitor{A}
    \) and \(
        \rightunitor{B}
    \) are identities.
\end{definition}

We are generally only concerned with strict categories in this thesis.

\section{Symmetric monoidal categories}

We can now construct morphisms by composing them in sequence and in parallel.
However, there is one more facet of processes that needs modelling: recall that
we have the \emph{symmetries} for crossing over wires.

\begin{definition}[Symmetric monoidal category]
    \label{def:symmetric-monoidal-category}
    A \emph{symmetric monoidal category} (SMC) is a monoidal category \(\mcc\)
    equipped with natural isomorphisms \(
        \swap{A}{B} \colon A \tensor B \cong B \tensor A
    \) such that the following diagrams commute:
    \begin{center}
        \includestandalone{figures/category/coherences/symmetry-unit}
        \includestandalone{figures/category/coherences/symmetry-inverse}

        \vspace{1em}

        \includestandalone[scale=0.95]{figures/category/coherences/hexagon}
    \end{center}
\end{definition}

\begin{example}
    \(\set\) is a symmetric monoidal category, with \(
        \morph{\swap{A}{B}}{A \times B}{B \times A}
    \) defined as the function that swaps elements of a pair.
\end{example}

\section{PROPs}

We have described the categorical structure required to interpret the
constructors for \(\generators\)-terms.
Now we will describe the precise categorical setting in which we can model
terms.

\begin{definition}[Multi-sorted PROP~\cite{maclane1965categorical}]
    Given a set of \emph{sorts} \(\mcc\), a \(\mcc\)-sorted \emph{PROP}
    (category of \emph{PRO}ducts and \emph{P}ermutations) is a strict symmetric
    monoidal category with the objects as words in \(\freemon{\mcc}\) and tensor
    product as concatenation.
\end{definition}

Note that this definition means that the empty word \(\epsilon\) is the unit
object in any \(\mcc\)-sorted PROP.
As the domain and codomains of generators in \(\generators\) are words of
natural numbers, it is clear to see how a multi-sorted PROP can be used for our
scenario.

\begin{definition}
    Given a set of generators \(\generators\), let \(\smc{\generators}\) be the
    \(\natplus\)-sorted PROP where \(
        \smc{\generators}(\overline{m}, \overline{n})
    \) is the set of \(\Sigma\)-terms of type \(\overline{m} \to \overline{n}\).
\end{definition}

The symmetric monoidal structure of \(\smc{\generators}\) means that
\(\generators\)-terms are now subject to equations which show how the identity,
symmetry, composition and tensor interact with each other and the generators in
\(\generators\).
These equations can be derived from the diagrams in
\cref{def:category,def:monoidal-category,def:symmetric-monoidal-category}, and
are explicitly listed in \cref{fig:structural-equations}.

\begin{figure}
    \centering
    \begin{gather*}
        \id[m] \seq  f = f
        \quad
        f = f \seq \id[n]
        \quad
        (f \seq g) \seq h = f \seq (g \seq h)
        \\[0.5em]
        \id[0] \tensor f = f
        \quad
        f \tensor \id[0] = f
        \quad
        (f \tensor g) \tensor h = f \tensor (g \tensor h)
        \\[0.5em]
        \id[m] \tensor \id[n] = \id[m+n]
        \quad
        (f \tensor g) \seq (h \tensor k) = (f \seq h) \tensor (g \seq k)
        \\[0.5em]
        (f \tensor g) \seq \swap{n}{q} = \swap{m}{p} \seq (g \tensor f)
        \quad
        (\swap{m}{n} \tensor \id[p]) \seq (\id[n] \tensor \swap{m}{p}) = \swap{m}{[n,p]}
        \\[0.5em]
        \swap{0}{n} = \id[n]
        \quad
        \swap{m}{0} = \id[m]
        \quad
        \swap{m}{n} \seq \swap{n}{m} = \id[m+n]
    \end{gather*}
    \caption{Summary of `structural' axioms that hold in \(\smc{\generators}\).}
    \label{fig:structural-equations}
\end{figure}

\section{String diagrams}

One could reason exclusively with the one-dimensional terms detailed in the
previous section, but this quickly becomes unwieldy.
Although the structural axioms make sense, they are tedious to apply and
obfuscate the interesting equations between generators.

Fortunately there is an alternative: the graphical calculus of
\emph{string diagrams}~\cite{joyal1991geometry}.


Generators are drawn as boxes, with wires on the left and right representing
each element of their input and output lists respectively.
For example, a generator \(\morph{\phi}{[m]}{[n]}\) is drawn as \(
    \iltikzfig{strings/category/generator}[\phi][white][m][n]
\) and a generator \(\morph{\psi}{[m,n]}{[p]}\) is drawn \(
    \iltikzfig{strings/category/generator-2-1}[\psi][white][m][n][p]
\).
The identity on \(n\) is drawn as \(
    \iltikzfig{strings/category/identity}[white][n]
\) and the symmetry on \([m, n]\) is drawn as \(
    \iltikzfig{strings/symmetric/symmetry}[white][m][n]
\).
The special case of the identity on \(0\) is drawn as empty space \(
    \iltikzfig{strings/monoidal/empty}
\).
Sometimes for clarity it will be advantageous to merge multiple wires into one,
so \(\psi\) above can also be drawn as \(
    \iltikzfig{strings/category/generator}[\psi][white][[m,n]][p]
\).

Composite terms are drawn as wider boxes \(
    \iltikzfig{strings/category/f}[f][white][\overline{m}][\overline{n}]
\).
Composition is then drawn as \emph{horizontal juxtaposition} \(
    \iltikzfig{strings/category/composition}[f][g][white][\overline{m}][\overline{n}][\overline{p}]
\) and tensor as \emph{vertical juxtaposition} \(
    \iltikzfig{strings/monoidal/tensor}[f][g][white][\overline{m}][\overline{n}][\overline{p}][\overline{q}]
\).

\begin{definition}[String diagram]
    A \emph{string diagram} is an equivalence class of \(\Sigma\)-terms
    quotiented by the equations in \cref{fig:structural-equations}.
\end{definition}

The beauty of using string diagrams is that we no longer have to concern
ourselves with the structural equations: they are taken care of by the notation.
This means we can concentrate on the more important equations.

\begin{figure}
    \centering
    \begin{gather*}
        \iltikzfig{strings/category/identity}[white]
        \seq
        \iltikzfig{strings/category/f}[f][white]
        =
        \iltikzfig{strings/category/f}[f][white]
        \quad
        \iltikzfig{strings/category/f}[f][white]
        \seq
        \iltikzfig{strings/category/identity}[white]
        =
        \iltikzfig{strings/category/f}[f][white]
        \quad
        \iltikzfig{strings/category/f}[f][white]
        \seq
        \iltikzfig{strings/category/composition}[g][h][white]
        =
        \iltikzfig{strings/category/composition}[f][g][white]
        \seq
        \iltikzfig{strings/category/f}[h][white]
        \\[0.5em]
        \begin{array}{cc}
            \iltikzfig{strings/monoidal/empty} \\
            \tensor \\
            \iltikzfig{strings/category/f}[f][white]
        \end{array}
        =
        \iltikzfig{strings/category/f}[f][white]
        \quad
        \begin{array}{cc}
            \iltikzfig{strings/category/f}[f][white] \\
            \tensor \\
            \iltikzfig{strings/monoidal/empty}
        \end{array}
        =
        \iltikzfig{strings/category/f}[f][white]
        \quad
        \begin{array}{cc}
            \iltikzfig{strings/category/f}[f][white] \\
            \tensor \\
            \iltikzfig{strings/monoidal/tensor}[g][h][white]
        \end{array}
        =
        \begin{array}{cc}
            \iltikzfig{strings/monoidal/tensor}[f][g][white] \\
            \tensor \\
            \iltikzfig{strings/category/f}[h][white]
        \end{array}
        \quad
        \begin{array}{cc}
            \iltikzfig{strings/category/identity}[white][m] \\
            \tensor \\
            \iltikzfig{strings/category/identity}[white][n]
        \end{array}
        =
        \iltikzfig{strings/category/identity}[white][[m,n]]
        \\[0.5em]
        \begin{array}{cc}
            \iltikzfig{strings/category/f}[f][white] \\
            \tensor \\
            \iltikzfig{strings/category/f}[g][white]
        \end{array}
        \seq
        \begin{array}{cc}
            \iltikzfig{strings/category/f}[h][white] \\
            \tensor \\
            \iltikzfig{strings/category/f}[k][white]
        \end{array}
        =
        \begin{array}{cc}
            \iltikzfig{strings/category/f}[f][white]
            \seq
            \iltikzfig{strings/category/f}[h][white] \\
            \tensor \\
            \iltikzfig{strings/category/f}[g][white]
            \seq
            \iltikzfig{strings/category/f}[k][white]
        \end{array}
        \\[0.5em]
        \iltikzfig{strings/monoidal/tensor}[f][g][white]
        \seq
        \iltikzfig{strings/symmetric/symmetry}[white]
        =
        \iltikzfig{strings/symmetric/symmetry}[white]
        \seq
        \iltikzfig{strings/monoidal/tensor}[g][f][white]
        \quad
        \begin{array}{cc}
            \iltikzfig{strings/symmetric/symmetry}[white][m][n] \\
            \tensor \\
            \iltikzfig{strings/category/identity}[white][p]
        \end{array}
        \seq
        \begin{array}{cc}
            \iltikzfig{strings/category/identity}[white][n] \\
            \tensor \\
            \iltikzfig{strings/symmetric/symmetry}[white][m][p]
        \end{array}
        =
        \iltikzfig{strings/symmetric/symmetry}[white][m][[n,p]]
        \\[0.5em]
        \swap{0}{n} = \id[n]
        \quad
        \swap{m}{0} = \id[m]
        \quad
        \swap{m}{n} \seq \swap{n}{m} = \id[[m,n]]
    \end{gather*}
    \caption{
        The structural equations from \cref{fig:structural-equations}
        represented in string diagram notation.
    }
    \label{fig:structural-equations-strings}
\end{figure}

\begin{example}
    A common issue that arises when reasoning with textual term strings is
    having to repeatedly apply the \emph{interchange law} (\(
        (f \tensor g) \seq (h \tensor k) = (f \seq h) \tensor (g \seq k)
    \) from \cref{fig:structural-equations}) in order to reorder the
    applications of composition and tensor.
    However, in the string diagram syntax these are both drawn as \(
        \iltikzfig{strings/monoidal/interchange}[f][g][h][k][white]
    \): it does not matter which order we apply the operations!
\end{example}

Another advantage of the graphical notation is that, as long as the connectivity
of boxes remains unchanged, we can deform diagrams as we please without altering
the underlying term.

\section{Monoidal theories}

However, these equations do not illustrate how the generators in \(\generators\)
interact with each other, which is crucial for modelling and evaluating
processes.
We need to
These equations are provided by a \emph{monoidal theory}.

\begin{definition}[Monoidal theory]
    A \emph{monoidal theory} is a tuple \((\generators, \equations)\) where
    \(\generators\) is a set of generators and \(\equations\) is a set of
    equations.
\end{definition}

An equation \(f = g\) in a monoidal theory \emph{identifies} the two morphisms
\(f\) and \(g\).
When reasoning with a monoidal theory, we therefore need to work in a category
in which all of the equations are identified in this way.

\begin{definition}[Quotient category]
    Given a category \(\mathbf{C}\) and a set of equations \(\mce\) between
    morphisms in \(\mathbf{C}\) with the same source and target, the
    \emph{quotient category} \(\mathbf{C} / \mce\) is the category in which
    \(\ob{(\mathbf{C} / \mce)} := \ob{\mathbf{C}}\) and \(
            \mor{(\mathbf{C} / \mce)}{X}{Y}
            :=
            \mor{\mathbf{C}}{X}{Y} / \mce
    \): i.e.\ morphisms are the \emph{equivalence classes} of morphisms
    modulo \(\mce\).
\end{definition}

\begin{definition}
    Given a monoidal theory \((\generators, \equations)\), let
    \(\smc{\generators, \equations} := \smc{\generators} / \equations\).
\end{definition}

Note that when \(\equations\) is empty,
\(\smc{\generators, \emptyset} = \smc{\generators}\).

\begin{example}\label{ex:frobenius}
    The monoidal theory of
    \emph{special commutative Frobenius algebras} is defined as \(
        (\generators[\frob], \equations[\frob])
    \) where \(
        \generators[\frob] := \{
            \iltikzfig{strings/structure/monoid/merge}[white],
            \iltikzfig{strings/structure/monoid/init}[white]
            \iltikzfig{strings/structure/comonoid/copy}[white],
            \iltikzfig{strings/structure/comonoid/discard}[white]
        \}
    \) and the equations of \(\equations[\frob]\) are listed in
    \cref{fig:monoid-equations,fig:comonoid-equations,fig:frobenius-equations}.
    We write \(\frob := \smc{\generators[\frob], \equations[\frob]}\).
\end{example}

\input{floats/monoids}
\input{floats/comonoids}
\input{floats/frobenius}



\section{Symmetric traced monoidal categories}



\section{Related work}

There has recently been an explosion in the use of symmetric monoidal categories
for modelling of processes, such as for quantum
protocols~\cite{abramsky2004categorical}, signal flow
diagrams~\cite{bonchi2014categorical,bonchi2015full}, linear
algebra~\cite{bonchi2017interacting,zanasi2015interacting,bonchi2019graphical,boisseau2022graphical},
dynamical systems~\cite{baez2015categories,fong2016categorical}, electrical
circuits~\cite{boisseau2022string} and automatic
differentiation~\cite{alvarez-picallo2023functorial}.
\chapter{Monoidal categories and theories}

\section{Terms}

Processes are modelled as \emph{terms}.
Before terms, their components must be specified.

\begin{notation}[Words]
    Given a set \(X\), the set of words of elements of \(X\) is denoted
    \(\freemon{X}\).
    Arbitrary words are written with an overline \(
        \overline{x}, \overline{y}, \overline{z}... \in \freemon{X}
    \); given two words \(\overline{x}, \overline{y}\), their concatenation is
    denoted \(\overline{x}\overline{y}\).
\end{notation}

\begin{definition}[Generators]
    A set of \emph{generators} is a set \(\generators\) equipped with two
    functions \(\morph{\dom,\cod}{\generators}{\freemon{\nat}}\).
\end{definition}

Generators are the primitive building blocks of terms: their domains and
codomains specify the widths of their input and output wires respectively.
Terms are then defined by combining these primitive generators together.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of generators.
    A \(\generators\)-term is written \(\morph{f}{\overline{m}}{\overline{n}}\)
    where \(\overline{m}, \overline{n} \in \freemon{\nat}\).
    The set of \(\generators\)-terms, denoted \(\sigmaterms\), is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\dom[\phi]}{\cod[\phi]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[n]}{[n]}{[n]} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(
                \morph{\swap{m}{n}}{[m,n]}{[n,m]} \in \sigmaterms
            \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{n}}{\overline{p}} \in \sigmaterms\)}
            \BinaryInfC{\(\morph{f \seq g}{\overline{m}}{\overline{p}} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{p}}{\overline{q}} \in \sigmaterms\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{\overline{m} \concat \overline{p}}{\overline{n} \concat \overline{q}} \in \sigmaterms
            \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms are constructed inductively.
There are three base cases: a generator from \(\generators\) with appropriate
inputs and outputs;
an \emph{identity} for empty wires with no generators;
and a \emph{symmetry} for swapping over two wires.
The two inductive cases are called \emph{composition} and \emph{tensor}
respectively.
Intuitively, these can be thought of generating larger terms by sequencing
subterms in sequence or parallel.

\(\Sigma\)-terms will be abbreviated to `terms' when the signature is clear from
context.

\section{Structural equations}

So far, terms are purely syntax, and terms are only equal if they are
constructed in the same way.
Even without considering the interaction of generators with each other, there
are numerous `structural equations' which need to hold to be useful for
modelling processes.

For example, the term \(\id \seq \phi\) (`doing nothing followed by \(\phi\)'),
and \(\phi \seq \id\) (`\(\phi\) followed by doing nothing') should be equal
from the point of view of processes, but currently they are not.

These `structural equations' are the laws of
\emph{symmetric monoidal categories}, which will now be introduced.

\begin{definition}[Categories]
    \label{def:category}
    A \emph{category} \(\mcc\) consists of a class of \emph{objects}
    \(\ob{\mcc}\); a class of \emph{morphisms} \(\mor{\mcc}{A}{B}\)
    for every pair of objects \(A, B \in \ob{\mcc}\); and a \emph{composition}
    operation \(
        \morph{
            {-} \circ {=}
        }{
            \mor{\mcc}{B}{C} \times \mor{\mcc}{A}{B}
        }{
            \mor{\mcc}{A}{C}
        }
    \) such that
    \begin{itemize}
        \item composition is \emph{unital}: for every \(
                    A \in \ob{\mcc}
                \) there exists an \emph{identity morphism} \(
                    \id[A] \in \mor{\mcc}{A}{A}
                \) satisfying \(
                    f \circ \id[A] = f = \id[B] \circ f
                \) for any \(
                    f \in \mor{\mcc}{A}{B}
                \); and
        \item composition is \emph{associative}: for any morphisms \(
                    f \in \mor{\mcc}{A}{B}
                \), \(
                    g \in \mor{\mcc}{B}{C}
                \) and \(h \in \mor{\mcc}{C}{D}\), \(
                    (h \circ g) \circ f = h \circ (g \circ f).
                \)
    \end{itemize}
\end{definition}

A morphism \(f \in \mor{\mcc}{A}{B}\) is also called an \emph{arrow}, and will
often be written \(\morph{f}{A}{B}\) accordingly.
The subscripts on the object and morphism classes are also often omitted.
Equations in category theory can be expressed using \emph{commutative diagrams}.
For example, the unitality and associativity of composition can be illustrated
as follows:

\begin{center}
    \includestandalone{figures/category/coherences/unitality}
    \quad
    \includestandalone{figures/category/coherences/associativity}
\end{center}

We say that the above two diagrams \emph{commute} precisely because \(
    \id[B] \circ f = f \circ \id[A]
\): no matter which path one takes, the results are equal.

\begin{example}[Preorder]
    A \emph{preorder} is a binary relation \(\leq\) on a set \(X\) which is
    reflexive and transitive.
    Any preorder generates a category \(\mcc_\leq\): the objects are the
    elements of \(X\) and \(\mcc_\leq(x, y)\) contains exactly one morphism if
    \(x \leq y\) and none otherwise.
\end{example}

\begin{example}[Category of sets]
    The category \(\set\) has sets as objects and functions as morphisms.
    Composition is then just function composition.
\end{example}

\section{Monoidal categories}

It is easy to see how processes can be viewed as morphisms: a morphism
\(\morph{f}{A}{B}\) is a process that transforms some input of type \(A\) into
an output of type \(B\).
Composition allows us to string together multiple processes \(f, g, h\) in
sequence to create a composite process \(f \seq g \seq h\), where we use
\emph{diagrammatic order} composition \(f \seq g := g \circ f\).

However, these processes are not particularly interesting: the inputs and
outputs can only be single types of and there is no notion of parallelism.
These issues can be allayed by adding structure to elevate a category into a
\emph{monoidal} category, which has a notion of \emph{parallel} composition in
addition to the already defined \emph{sequential} composition.
The parallel composition structure can be added to a regular category by using
another notion from category theory: that of a \emph{functor}.

\begin{definition}[Functor]
    Given two categories \(\mcc\) and \(\mcd\), a \emph{functor} \(
        \morph{F}{\mcc}{\mcd}
    \) maps objects and morphisms in \(\mcc\) to objects and morphisms in
    \(\mcd\) such that
    \begin{itemize}
        \item \(F(\id[A]) = \id[FA]\) for every \(A \in \ob{\mcc})\); and
        \item \(F(g \circ f) = F(g) \circ F(f)\) for every \(\morph{f}{A}{B}\)
        and \(\morph{g}{B}{C}\).
    \end{itemize}
\end{definition}

A functor \(F\) is a mapping between categories: it maps an object \(X\) in one
category to an object \(FX\) in another, and morphisms \(\morph{f}{X}{Y}\) to
\(\morph{Ff}{FX}{FY}\).

\begin{definition}[Endofunctor]
    An \emph{endofunctor} is a functor from a category to itself.
\end{definition}

\begin{definition}[Natural transformation]
    Given two functors \(\morph{F, G}{\mcc}{\mcd}\), a
    \emph{natural transformation} \(\morph{\eta}{F}{G}\) is a family of
    morphisms \(
        \eta_A \in \mor{\mcd}{FA}{GA}
    \) called \emph{components} for each \(A \in \ob{\mcc}\) such that \(
        \eta_B \circ Ff = Gf \circ \eta_A
    \), i.e.\ the following diagram commutes:
    \begin{center}
        \includestandalone{figures/category/coherences/natural}
    \end{center}
\end{definition}

The key point to take is that for functors \(\morph{F,G}{\mcc}{\mcd}\), a
natural transformation \(\morph{\eta}{F}{G}\) is a \emph{family} of morphisms
\(\morph{\eta_A}{FA}{GA} \in \mcd\) for each object \(A \in \mcd\).



\begin{definition}[Product category]
    Given two categories \(\mcc\) and \(\mcd\), their \emph{product category}
    \(\mcc \times \mcd\) is the category with objects are defined as \(
        \ob{(\mcc \times \mcd)} := \ob{\mcc} \times \ob{\mcd}
    \) and the morphisms as \[
        \mor{(\mcc \times \mcd)}{(A, A^\prime)}{(B, B^\prime)}
        :=
        \{
            (f, f^\prime)
            \,|\,
            f \in \mor{\mcc}{A}{B},
            f^\prime \in \mor{\mcd}{A^\prime}{B^\prime}
        \}
    \]
\end{definition}

\begin{definition}[Bifunctor]
    A \emph{bifunctor} is a functor with a product category as its domain, i.e.\
    a functor of the form \(\mcc \times \mcd \to \mce\).
\end{definition}

\begin{definition}[Isomorphism]
    A morphism \(\morph{f}{A}{B} \in \mcc\) is called an \emph{isomorphism} (or
    simply \emph{iso} for short) if there also exists a morphism \(
        \morph{\inverse{f}}{B}{A} \in \mcc
    \) such that \(
        \inverse{f} \circ f = \id[A]
    \) and \(
        f \circ \inverse{f} = \id[B]
    \).
\end{definition}

\begin{example}
    A morphism in \(\set\) is an iso if and only if it is a bijection.
\end{example}

\begin{definition}[Natural isomorphism]
    A natural transformation is called a \emph{natural isomorphism} if every
    component is an isomorphism.
\end{definition}

We now have all the components necessary in order to define a monoidal category,
a category with notions of both sequential and parallel composition.

\begin{definition}[Monoidal category]
    \label{def:monoidal-category}
    A \emph{monoidal category} is a category \(\mcc\) equipped with a
    bifunctor \(\morph{{-} \tensor {=}}{\mcc \times \mcc}{\mcc}\) called the
    \emph{tensor product} and an additional object \(I\) called the
    \emph{monoidal unit},
    along with natural isomorphisms
    \begin{itemize}
        \item \(
            \associator{A}{B}{C}
            \colon
            A \tensor (B \tensor C)
            \cong
            (A \tensor B) \tensor C
            \) called the \emph{associator};
        \item \(
            \leftunitor{A}
            \colon
            I \tensor A
            \cong
            A
            \) called the \emph{left unitor}; and
        \item \(
            \rightunitor{A}
            \colon
            A \tensor I
            \cong
            A
            \) called the \emph{right unitor}
    \end{itemize}
    such that the \emph{pentagon} and the \emph{triangle} diagrams below
    commute:
    \begin{center}
        \includestandalone{figures/category/coherences/pentagon}

        \vspace{1em}

        \includestandalone{figures/category/coherences/triangle}
    \end{center}
\end{definition}

We adopt the convention that \(f \tensor g \seq h \tensor k\) should be
bracketed as \((f \tensor g) \seq (h \tensor k)\), i.e.\ \(\tensor\) binds
more strongly than \(\seq\).
Later in this chapter we will provide an alternative notation for terms
in monoidal categories which will make this distinction redundant.

\begin{example}
    \(\set\) is a monoidal category, with the tensor product defined as the
    Cartesian product (\(A \tensor B := A \times B\)) and the unit as the
    singleton set (\(I := \mathbbm{1}\)).
    The natural isomorphisms are identities.
\end{example}

This situation where the natural isomorphisms are identities arises frequently,
so it has its own name.

\begin{definition}[Strict monoidal category]
    A monoidal category is called \emph{strict} if the natural isomorphisms \(
        \associator{A}{B}{C}
    \), \(
        \leftunitor{A}
    \) and \(
        \rightunitor{B}
    \) are identities.
\end{definition}

We are generally only concerned with strict categories in this thesis.

\section{Symmetric monoidal categories}

We can now construct morphisms by composing them in sequence and in parallel.
However, there is one more facet of processes that needs modelling: recall that
we have the \emph{symmetries} for crossing over wires.

\begin{definition}[Symmetric monoidal category]
    \label{def:symmetric-monoidal-category}
    A \emph{symmetric monoidal category} (SMC) is a monoidal category \(\mcc\)
    equipped with natural isomorphisms \(
        \swap{A}{B} \colon A \tensor B \cong B \tensor A
    \) such that the following diagrams commute:
    \begin{center}
        \includestandalone{figures/category/coherences/symmetry-unit}
        \includestandalone{figures/category/coherences/symmetry-inverse}

        \vspace{1em}

        \includestandalone[scale=0.95]{figures/category/coherences/hexagon}
    \end{center}
\end{definition}

\begin{example}
    \(\set\) is a symmetric monoidal category, with \(
        \morph{\swap{A}{B}}{A \times B}{B \times A}
    \) defined as the function that swaps elements of a pair.
\end{example}

\section{Syntactic categories}


We will now formally describe how to specify terms as morphisms in a symmetric
There is a particular subclass of SMCs in which this is especially natural.

\begin{definition}[Multi-sorted PROP~\cite{maclane1965categorical}]
    Given a set of \emph{sorts} \(\mcc\), a \(\mcc\)-sorted \emph{PROP}
    (category of \emph{PRO}ducts and \emph{P}ermutations) is a strict symmetric
    monoidal category with the objects as words in \(\freemon{\mcc}\) and tensor
    product as concatenation.
\end{definition}

Note that this definition means that the empty word \(\epsilon\) is the unit
object in any \(\mcc\)-sorted PROP.

\begin{definition}
    Given a set of generators \(\generators\), let \(\smc{\generators}\) be the
    \(\natplus\)-sorted PROP where \(
        \smc{\generators}(\overline{m}, \overline{n})
    \) is the set of \(\Sigma\)-terms of type \(\overline{m} \to \overline{n}\).
\end{definition}

The symmetric monoidal structure of \(\smc{\generators}\) means that
\(\generators\)-terms are now subject to equations which show how the identity,
symmetry, composition and tensor interact with each other and the generators in
\(\generators\).
These equations can be derived from the diagrams in
\cref{def:category,def:monoidal-category,def:symmetric-monoidal-category}, and
are explicitly listed in \cref{fig:structural-equations}.

\begin{figure}
    \centering
    \begin{gather*}
        \id[m] \seq  f = f
        \quad
        f = f \seq \id[n]
        \quad
        (f \seq g) \seq h = f \seq (g \seq h)
        \\[0.5em]
        \id[0] \tensor f = f
        \quad
        f \tensor \id[0] = f
        \quad
        (f \tensor g) \tensor h = f \tensor (g \tensor h)
        \\[0.5em]
        \id[m] \tensor \id[n] = \id[m+n]
        \quad
        (f \tensor g) \seq (h \tensor k) = (f \seq h) \tensor (g \seq k)
        \\[0.5em]
        (f \tensor g) \seq \swap{n}{q} = \swap{m}{p} \seq (g \tensor f)
        \quad
        (\swap{m}{n} \tensor \id[p]) \seq (\id[n] \tensor \swap{m}{p}) = \swap{m}{n+p}
        \\[0.5em]
        \swap{0}{n} = \id[n]
        \quad
        \swap{m}{0} = \id[m]
        \quad
        \swap{m}{n} \seq \swap{n}{m} = \id[m+n]
    \end{gather*}
    \caption{Summary of `structural' axioms that hold in \(\smc{\generators}\).}
    \label{fig:structural-equations}
\end{figure}

\section{String diagrams}

One could reason exclusively with the one-dimensional terms detailed in the
previous section, but this quickly becomes unwieldy.
Although the structural axioms make sense, they are tedious to apply and
obfuscate the interesting equations between generators.

Fortunately there is an alternative: the graphical calculus of
\emph{string diagrams}~\cite{joyal1991geometry}.


Generators are drawn as boxes, with wires on the left and right representing
each element of their input and output lists respectively.
For example, a generator \(\morph{\phi}{[m]}{[n]}\) is drawn as \(
    \iltikzfig{strings/category/generator}[\phi][white][m][n]
\) and a generator \(\morph{\psi}{[m,n]}{[p]}\) is drawn \(
    \iltikzfig{strings/category/generator-2-1}[\psi][white][m][n][p]
\).
The identity on \(n\) is drawn as \(
    \iltikzfig{strings/category/identity}[white][n]
\) and the symmetry on \([m, n]\) is drawn as \(
    \iltikzfig{strings/symmetric/symmetry}[white][m][n]
\).
The special case of the identity on \(0\) is drawn as empty space \(
    \iltikzfig{strings/monoidal/empty}
\).
Sometimes for clarity it will be advantageous to merge multiple wires into one,
so \(\psi\) above can also be drawn as \(
    \iltikzfig{strings/category/generator}[\psi][white][[m,n]][p]
\).

Composite terms are drawn as wider boxes \(
    \iltikzfig{strings/category/f}[f][white][\overline{m}][\overline{n}]
\).
Composition is then drawn as \emph{horizontal juxtaposition} \(
    \iltikzfig{strings/category/composition}[f][g][white][\overline{m}][\overline{n}][\overline{p}]
\) and tensor as \emph{vertical juxtaposition} \(
    \iltikzfig{strings/monoidal/tensor}[f][g][white][\overline{m}][\overline{n}][\overline{p}][\overline{q}]
\).

\begin{definition}[String diagram]
    A \emph{string diagram} is an equivalence class of \(\Sigma\)-terms
    quotiented by the equations in \cref{fig:structural-equations}.
\end{definition}

\begin{example}
    One of the more common issues that arises when reasoning with text-based
    term strings is having to incorporate repeated uses of the
    \emph{interchange law} (\(
        (f \tensor g) \seq (h \tensor k) = (f \seq h) \tensor (g \seq k)
    \) from \cref{fig:structural-equations}) in order to reorder the
    applications of composition and tensor.
    In the string diagram syntax, these are both drawn as \(
        \iltikzfig{strings/monoidal/interchange}[f][g][h][k][white]
    \).
\end{example}

\section{Monoidal theories}

However, these equations do not illustrate how the generators in \(\generators\)
interact with each other, which is crucial for modelling and evaluating
processes.
We need to
These equations are provided by a \emph{monoidal theory}.

\begin{definition}[Monoidal theory]
    A \emph{monoidal theory} is a tuple \((\generators, \equations)\) where
    \(\generators\) is a set of generators and \(\equations\) is a set of
    equations.
\end{definition}

An equation \(f = g\) in a monoidal theory \emph{identifies} the two morphisms
\(f\) and \(g\).
When reasoning with a monoidal theory, we therefore need to work in a category
in which all of the equations are identified in this way.

\begin{definition}[Quotient category]
    Given a category \(\mathbf{C}\) and a set of equations \(\mce\) between
    morphisms in \(\mathbf{C}\) with the same source and target, the
    \emph{quotient category} \(\mathbf{C} / \mce\) is the category in which
    \(\ob{(\mathbf{C} / \mce)} := \ob{\mathbf{C}}\) and \(
            \mor{(\mathbf{C} / \mce)}{X}{Y}
            :=
            \mor{\mathbf{C}}{X}{Y} / \mce
    \): i.e.\ morphisms are the \emph{equivalence classes} of morphisms
    modulo \(\mce\).
\end{definition}

\begin{definition}
    Given a monoidal theory \((\generators, \equations)\), let
    \(\smc{\generators, \equations} := \smc{\generators} / \equations\).
\end{definition}

Note that when \(\equations\) is empty,
\(\smc{\generators, \emptyset} = \smc{\generators}\).

\begin{example}\label{ex:frobenius}
    The monoidal theory of
    \emph{special commutative Frobenius algebras} is defined as \(
        (\generators[\frob], \equations[\frob])
    \) where \(
        \generators[\frob] := \{
            \iltikzfig{strings/structure/monoid/merge}[white],
            \iltikzfig{strings/structure/monoid/init}[white]
            \iltikzfig{strings/structure/comonoid/copy}[white],
            \iltikzfig{strings/structure/comonoid/discard}[white]
        \}
    \) and the equations of \(\equations[\frob]\) are listed in
    \cref{fig:monoid-equations,fig:comonoid-equations,fig:frobenius-equations}.
    We write \(\frob := \smc{\generators[\frob], \equations[\frob]}\).
\end{example}

\input{floats/monoids}
\input{floats/comonoids}
\input{floats/frobenius}



\section{Symmetric traced monoidal categories}
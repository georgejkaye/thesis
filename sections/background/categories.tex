\chapter{Monoidal categories and theories}

\section{Terms}

Processes are modelled as \emph{terms}.
Before we can begin, the components that make up processes in a given system
must be sepcified.

\begin{notation}[Word, word sum]
    Given a set \(X\), the set of words of elements of \(X\) is denoted
    \(\freemon{X}\).
    Words are written \([x_0, x_1, x_2, \cdots, x_{n-1}]\); variables
    representing arbitrary words are generally written with an overline \(
        \overline{x}, \overline{y}, \overline{z}... \in \freemon{X}
    \).
    Given two words \(\overline{x}, \overline{y}\), their concatenation is
    denoted \(\overline{x}\overline{y}\).
    Given a word \(\overline{x}\), its \emph{length} is denoted
    \(\wordlen{\overline{x}}\); for \(i < \wordlen{\overline{x}}\), its
    \(i\)\emph{th element} is denoted \(\overline{x}(i)\); and its
    \emph{word sum}, denoted \(\wordsum{\overline{x}}\), is computed as
    \(\Sigma_{i < |\overline{m}|}\overline{m}(i)\).
\end{notation}

\begin{notation}
    Let \(\natplus\) be the set of non-zero natural numbers.
\end{notation}

\begin{definition}[Generators]
    A set of \emph{generators} is a set \(\generators\) equipped with two
    functions \(\morph{\domw,\codw}{\generators}{\natplus^\star}\).
\end{definition}

Generators are the primitive building blocks of terms: their domains and
codomains specify the widths of their input and output wires respectively.
Terms are defined by combining these primitives together.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of generators.
    A \(\generators\)-term is written \(\morph{f}{\overline{m}}{\overline{n}}\)
    where \(\overline{m}, \overline{n} \in \natplus^\star\).
    The set of \(\generators\)-terms, denoted \(\sigmaterms\), is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\domw[\phi]}{\codw[\phi]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[n]}{[n]}{[n]} \in \sigmaterms\)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(
                \morph{\swap{m}{n}}{[m,n]}{[n,m]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\wordsum{\overline{m}} = \wordsum{\overline{n}}\)}
            \UnaryInfC{\(
                \morph{\bundle{\overline{m}}{\overline{n}}}{\overline{m}}{\overline{n}} \in \sigmaterms
            \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{n}}{\overline{p}} \in \sigmaterms\)}
            \BinaryInfC{\(\morph{f \seq g}{\overline{m}}{\overline{p}} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{p}}{\overline{q}} \in \sigmaterms\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{\overline{mp}}{\overline{nq}} \in \sigmaterms
            \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms are constructed recursively.
There are four base cases: a generator from \(\generators\) with appropriate
inputs and outputs;
an \emph{identity} for empty wires with no generators;
a \emph{symmetry} for swapping over two wires;
and a \emph{bundler} for reorganising lists of wires.
The two inductive cases are called \emph{composition} and \emph{tensor}
respectively.
Intuitively, these can be thought of generating larger terms by sequencing
subterms in sequence or parallel.

\(\Sigma\)-terms will be abbreviated to `terms' when the signature is clear from
context.

\section{Structural equations}

So far, terms are purely syntax, and terms are only equal if they are
constructed in precisely the same way.
Even without considering the interaction of generators with each other, there
are numerous `structural equations' which need to hold to be useful for
modelling processes.

\begin{example}
    Consider the term \(f \seq \id[n]\), which can be read as `run \(f\) and
    then do nothing'.
    Since we are only concerned with the \emph{input-output} behaviour of
    processes, this should be the same as just \(f\).
    However, as it stands \(f \seq \id[n]\) and \(f\) are not equal.
\end{example}

One could just add all the `right' equations manually, but what are the `right'
equations?
It turns out that an elegant mathematical formalism exists in the form of
\emph{symmetric monoidal categories}.

\begin{definition}[Categories]
    \label{def:category}
    A \emph{category} \(\mcc\) consists of a class of \emph{objects}
    \(\ob{\mcc}\); a class of \emph{morphisms} \(\mor{\mcc}{A}{B}\)
    for every pair of objects \(A, B \in \ob{\mcc}\); and a \emph{composition}
    operation \(
        \morph{
            {-} \circ {=}
        }{
            \mor{\mcc}{B}{C} \times \mor{\mcc}{A}{B}
        }{
            \mor{\mcc}{A}{C}
        }
    \) such that
    \begin{itemize}
        \item composition is \emph{unital}: for every \(
                    A \in \ob{\mcc}
                \) there exists an \emph{identity morphism} \(
                    \id[A] \in \mor{\mcc}{A}{A}
                \) satisfying \(
                    f \circ \id[A] = f = \id[B] \circ f
                \) for any \(
                    f \in \mor{\mcc}{A}{B}
                \); and
        \item composition is \emph{associative}: for any morphisms \(
                    f \in \mor{\mcc}{A}{B}
                \), \(
                    g \in \mor{\mcc}{B}{C}
                \) and \(h \in \mor{\mcc}{C}{D}\), \(
                    (h \circ g) \circ f = h \circ (g \circ f).
                \)
    \end{itemize}
\end{definition}

A morphism \(f \in \mor{\mcc}{A}{B}\) is also called an \emph{arrow}, and will
often be written \(\morph{f}{A}{B}\) accordingly.
The subscripts on the object and morphism classes are also often omitted.
Equations in category theory can be expressed using \emph{commutative diagrams}.
For example, the unitality and associativity of composition can be illustrated
as follows:

\begin{center}
    \includestandalone{figures/category/coherences/unitality}
    \quad
    \includestandalone{figures/category/coherences/associativity}
\end{center}

We say that the above two diagrams \emph{commute} precisely because \(
    \id[B] \circ f = f \circ \id[A]
\): no matter which path one takes, the results are equal.

Categories generalise a plethora of mathematical structures: some examples will
now be provided.

\begin{example}[Preorder]
    A \emph{preorder} is a binary relation \(\leq\) on a set \(X\) which is
    reflexive and transitive.
    Any preorder generates a category \(\mcc_\leq\): the objects are the
    elements of \(X\) and \(\mcc_\leq(x, y)\) contains exactly one morphism if
    \(x \leq y\) and none otherwise.
\end{example}

\begin{example}[Category of sets]
    The category \(\set\) has sets as objects and functions as morphisms.
    Composition is then just function composition.
\end{example}

\section{Monoidal categories}

It is easy to see how processes can be viewed as morphisms: a morphism
\(\morph{f}{A}{B}\) is a process that transforms some input of type \(A\) into
an output of type \(B\).
Composition allows us to string together multiple processes \(f, g, h\) in
sequence to create a composite process \(f \seq g \seq h\), where we use
\emph{diagrammatic order} composition \(f \seq g := g \circ f\).

However, these processes are not particularly interesting: the inputs and
outputs can only be single types of and there is no notion of parallelism.
These issues can be allayed by adding structure to elevate a category into a
\emph{monoidal} category, which has a notion of \emph{parallel} composition in
addition to the already defined \emph{sequential} composition.
The parallel composition structure can be added to a regular category by using
another notion from category theory: that of a \emph{functor}.

\begin{definition}[Functor]
    Given two categories \(\mcc\) and \(\mcd\), a \emph{functor} \(
        \morph{F}{\mcc}{\mcd}
    \) maps objects and morphisms in \(\mcc\) to objects and morphisms in
    \(\mcd\) such that
    \begin{itemize}
        \item \(F(\id[A]) = \id[FA]\) for every \(A \in \ob{\mcc})\); and
        \item \(F(g \circ f) = F(g) \circ F(f)\) for every \(\morph{f}{A}{B}\)
        and \(\morph{g}{B}{C}\).
    \end{itemize}
\end{definition}

A functor \(F\) is a mapping between categories: it maps an object \(X\) in one
category to an object \(FX\) in another, and morphisms \(\morph{f}{X}{Y}\) to
\(\morph{Ff}{FX}{FY}\).

\begin{definition}[Endofunctor]
    An \emph{endofunctor} is a functor from a category to itself.
\end{definition}

\begin{definition}[Natural transformation]
    Given two functors \(\morph{F, G}{\mcc}{\mcd}\), a
    \emph{natural transformation} \(\morph{\eta}{F}{G}\) is a family of
    morphisms \(
        \eta_A \in \mor{\mcd}{FA}{GA}
    \) called \emph{components} for each \(A \in \ob{\mcc}\) such that \(
        \eta_B \circ Ff = Gf \circ \eta_A
    \), i.e.\ the following diagram commutes:
    \begin{center}
        \includestandalone{figures/category/coherences/natural}
    \end{center}
\end{definition}

The key point to take is that for functors \(\morph{F,G}{\mcc}{\mcd}\), a
natural transformation \(\morph{\eta}{F}{G}\) is a \emph{family} of morphisms
\(\morph{\eta_A}{FA}{GA} \in \mcd\) for each object \(A \in \mcd\).



\begin{definition}[Product category]
    Given two categories \(\mcc\) and \(\mcd\), their \emph{product category}
    \(\mcc \times \mcd\) is the category with objects are defined as \(
        \ob{(\mcc \times \mcd)} := \ob{\mcc} \times \ob{\mcd}
    \) and the morphisms as \[
        \mor{(\mcc \times \mcd)}{(A, A^\prime)}{(B, B^\prime)}
        :=
        \{
            (f, f^\prime)
            \,|\,
            f \in \mor{\mcc}{A}{B},
            f^\prime \in \mor{\mcd}{A^\prime}{B^\prime}
        \}
    \]
\end{definition}

\begin{definition}[Bifunctor]
    A \emph{bifunctor} is a functor with a product category as its domain, i.e.\
    a functor of the form \(\mcc \times \mcd \to \mce\).
\end{definition}

\begin{definition}[Isomorphism]
    A morphism \(\morph{f}{A}{B} \in \mcc\) is called an \emph{isomorphism} (or
    simply \emph{iso} for short) if there also exists a morphism \(
        \morph{\inverse{f}}{B}{A} \in \mcc
    \) such that \(
        \inverse{f} \circ f = \id[A]
    \) and \(
        f \circ \inverse{f} = \id[B]
    \).
\end{definition}

\begin{example}
    A morphism in \(\set\) is an iso if and only if it is a bijection.
\end{example}

\begin{definition}[Natural isomorphism]
    A natural transformation is called a \emph{natural isomorphism} if every
    component is an isomorphism.
\end{definition}

We now have all the components necessary in order to define a monoidal category,
a category with notions of both sequential and parallel composition.

\begin{definition}[Monoidal category]
    \label{def:monoidal-category}
    A \emph{monoidal category} is a category \(\mcc\) equipped with a
    bifunctor \(\morph{{-} \tensor {=}}{\mcc \times \mcc}{\mcc}\) called the
    \emph{tensor product} and an additional object \(I\) called the
    \emph{monoidal unit},
    along with natural isomorphisms
    \begin{itemize}
        \item \(
            \associator{A}{B}{C}
            \colon
            A \tensor (B \tensor C)
            \cong
            (A \tensor B) \tensor C
            \) called the \emph{associator};
        \item \(
            \leftunitor{A}
            \colon
            I \tensor A
            \cong
            A
            \) called the \emph{left unitor}; and
        \item \(
            \rightunitor{A}
            \colon
            A \tensor I
            \cong
            A
            \) called the \emph{right unitor}
    \end{itemize}
    such that the \emph{pentagon} and the \emph{triangle} diagrams below
    commute:
    \begin{center}
        \includestandalone{figures/category/coherences/pentagon}

        \vspace{1em}

        \includestandalone{figures/category/coherences/triangle}
    \end{center}
\end{definition}

We adopt the convention that \(f \tensor g \seq h \tensor k\) should be
bracketed as \((f \tensor g) \seq (h \tensor k)\), i.e.\ \(\tensor\) binds
more strongly than \(\seq\).
Later in this chapter we will provide an alternative notation for terms
in monoidal categories which will make this distinction redundant.

\begin{example}
    \(\set\) is a monoidal category, with the tensor product defined as the
    Cartesian product (\(A \tensor B := A \times B\)) and the unit as the
    singleton set (\(I := \mathbbm{1}\)).
    The natural isomorphisms are identities.
\end{example}

This situation where the natural isomorphisms are identities arises frequently,
so it has its own name.

\begin{definition}[Strict monoidal category]
    A monoidal category is called \emph{strict} if the natural isomorphisms \(
        \associator{A}{B}{C}
    \), \(
        \leftunitor{A}
    \) and \(
        \rightunitor{B}
    \) are identities.
\end{definition}

We are generally only concerned with strict categories in this thesis.

\section{Symmetric monoidal categories}

We can now construct morphisms by composing them in sequence and in parallel.
However, there is one more facet of processes that needs modelling: recall that
we have the \emph{symmetries} for crossing over wires.

\begin{definition}[Symmetric monoidal category]
    \label{def:symmetric-monoidal-category}
    A \emph{symmetric monoidal category} (SMC) is a monoidal category \(\mcc\)
    equipped with natural isomorphisms \(
        \swap{A}{B} \colon A \tensor B \cong B \tensor A
    \) such that the following diagrams commute:
    \begin{center}
        \includestandalone{figures/category/coherences/symmetry-unit}
        \includestandalone{figures/category/coherences/symmetry-inverse}

        \vspace{1em}

        \includestandalone[scale=0.95]{figures/category/coherences/hexagon}
    \end{center}
\end{definition}

\begin{example}
    \(\set\) is a symmetric monoidal category, with \(
        \morph{\swap{A}{B}}{A \times B}{B \times A}
    \) defined as the function that swaps elements of a pair.
\end{example}

\section{PROPs}

We have described the categorical structure required to interpret five of the
constructors listed in \cref{def:terms}; only the `bundlers'
\(\bundle{\overline{m}}{\overline{n}}\) remain.
However, to give these meaning we must consider a slightly

\begin{definition}[Multi-sorted PROP~\cite{maclane1965categorical}]
    Given a set of \emph{sorts} \(\mcc\), a \(\mcc\)-sorted \emph{PROP}
    (category of \emph{PRO}ducts and \emph{P}ermutations) is a strict symmetric
    monoidal category with the objects as words in \(\freemon{\mcc}\) and tensor
    product as concatenation.
\end{definition}

Note that this definition means that the empty word \(\varepsilon\) is the unit
object in any \(\mcc\)-sorted PROP.
As the domain and codomains of generators in \(\generators\) are words of
natural numbers, it is clear to see how a multi-sorted PROP can be used for our
scenario.

\begin{definition}\label{def:freely-generated-prop}
    Given a set of generators \(\generators\), let \(\smc{\generators}\) be the
    \(\natplus\)-sorted PROP where \(
        \smc{\generators}(\overline{m}, \overline{n})
    \) is the set of \(\Sigma\)-terms of type \(\overline{m} \to \overline{n}\).
\end{definition}

The symmetric monoidal structure of \(\smc{\generators}\) means that
\(\generators\)-terms are now subject to equations which show how the identity,
symmetry, composition and tensor interact with each other and the generators in
\(\generators\).
These equations can be derived from the diagrams in
\cref{def:category,def:monoidal-category,def:symmetric-monoidal-category}, and
are explicitly listed in \cref{fig:structural-equations}.

\input{floats/structural-equations}

\section{Interpreting the bundlers}

In the context of PROPs, the bundler generators
\(\bundle{\overline{m}}{\overline{n}}\) have a

This framework was first proposed under the name \emph{strictifiers} in , however it can also be used in our strict case to translate be

\begin{definition}[Bundled completion]
    Given a multi-sorted PROP \(\mcc\), its \emph{bundled completion} is
    a multi-sorted PROP \(\bundled{\mcc}\) with the same objects as \(\mcc\)
    but equipped with additional natural isomorphisms \(
        \bundleexpand{\overline{m}}{\overline{np}}
        \colon \overline{m} \cong \overline{np}
    \) and \(
        \bundlecontract{\overline{m}}{\overline{np}}
        \colon \overline{np} \cong \overline{p}
    \),
    for every \(\overline{m}, \overline{n}, \overline{p} \in \ob{\mcc}\) where
    \(\wordsum{\overline{m}} = \wordsum{\overline{n}} + \wordsum{\overline{p}}\),
    such that the following diagrams commute:
\end{definition}

\section{String diagrams}

One could reason exclusively with the one-dimensional terms detailed in the
previous section, but this quickly becomes unwieldy.
Although the structural axioms make sense, they are tedious to apply and
obfuscate the interesting equations between generators.

Fortunately there is an alternative: the calculus of \emph{string diagrams}.
Originally introduced by Joyal and Street in \cite{joyal1991geometry}, the use
of string diagrams has exploded recently for use in a whole host of categorical
settings~\cite{selinger2011survey}.

Generators are drawn as boxes, with wires on the left and right representing
each element of their input and output lists respectively.
For example, a generator \(\morph{\phi}{[m]}{[n]}\) is drawn as \(
    \iltikzfig{strings/category/generator}[\phi][white][m][n]
\) and a generator \(\morph{\psi}{[m,n]}{[p]}\) is drawn \(
    \iltikzfig{strings/category/generator-2-1}[\psi][white][m][n][p]
\).
The identity on \(n\) is drawn as \(
    \iltikzfig{strings/category/identity}[white][n]
\) and the symmetry on \([m, n]\) is drawn as \(
    \iltikzfig{strings/symmetric/symmetry}[white][m][n]
\).
The special case of the identity on \(\varepsilon\) is usually drawn as empty space
\(
    \iltikzfig{strings/monoidal/empty}
\); when it is necessary to indicate that a unit is being used in an equation
then it will be drawn as a faded wire \(
    \iltikzfig{strings/monoidal/unit-wire}[white][\varepsilon]
\).
Sometimes for clarity it will be advantageous to merge multiple wires into one,
so \(\psi\) above can also be drawn as \(
    \iltikzfig{strings/category/generator}[\psi][white][[m,n]][p]
\).

Of course, this is just syntax; instead of writing symbols we are drawing boxes.
The power of string diagrams comes from the representation of composition as
\emph{juxtaposition} rather than using \(\seq\) or \(\tensor\).
Given two composite terms, drawn as wider boxes \(
    \iltikzfig{strings/category/f}[f][white][\overline{m}][\overline{n}]
\), composition and tensor are drawn as \emph{horizontal} and \emph{vertical}
juxtaposition respectively. \[
    \iltikzfig{strings/category/f}[f][white][\overline{m}][\overline{n}]
    \seq
    \iltikzfig{strings/category/f}[g][white][\overline{n}][\overline{p}] :=
    \iltikzfig{strings/category/composition}[f][g][white][\overline{m}][\overline{n}][\overline{p}]
    \qquad
    \iltikzfig{strings/category/f}[f][white][\overline{m}][\overline{n}]
    \tensor
    \iltikzfig{strings/category/f}[g][white][\overline{p}][\overline{q}] :=
    \iltikzfig{strings/monoidal/tensor}[f][g][white][\overline{m}][\overline{n}][\overline{p}][\overline{q}].
\]

When drawing out the structural equations from \cref{fig:structural-equations}
as string diagrams in \cref{fig:structural-equations-strings}, it is clear to
see that applying these equations is reduced to manipulating diagrams while
retaining their connectivity.
This leads us to a formal definition of a string diagram.

\begin{definition}[String diagram]
    A \emph{string diagram} is an equivalence class of \(\Sigma\)-terms
    quotiented by the equations in \cref{fig:structural-equations}.
\end{definition}

\input{floats/structural-equations-strings}

\section{Monoidal theories}

So far we have only concerned ourselves with \emph{structural} equations:
equations that show how the same term can be constructed using different
combinations of composition, tensor, the identity and symmetry.
However, these only serve as a form of housekeeping: the true `computational
content' of processes comes from equations that show how the generators interact
with \emph{each other}.
These equations are provided by a \emph{monoidal theory}.

\begin{definition}[Monoidal theory]
    A \emph{monoidal theory} is a tuple \((\generators, \equations)\) where
    \(\generators\) is a set of generators and \(\equations\) is a set of
    equations.
\end{definition}

An equation \(f = g\) in a monoidal theory \emph{identifies} the two morphisms
\(f\) and \(g\).
When reasoning with a monoidal theory, we therefore need to work in a category
in which all of the equations are identified in this way.

\begin{definition}[Quotient category]
    Given a category \(\mathbf{C}\) and a set of equations \(\mce\) between
    morphisms in \(\mathbf{C}\) with the same source and target, the
    \emph{quotient category} \(\mathbf{C} / \mce\) is the category in which
    \(\ob{(\mathbf{C} / \mce)} := \ob{\mathbf{C}}\) and \(
            \mor{(\mathbf{C} / \mce)}{X}{Y}
            :=
            \mor{\mathbf{C}}{X}{Y} / \mce
    \): i.e.\ morphisms are the \emph{equivalence classes} of morphisms
    modulo \(\mce\).
\end{definition}

\begin{definition}
    Given a monoidal theory \((\generators, \equations)\), let
    \(\smc{\generators, \equations} := \smc{\generators} / \equations\).
\end{definition}

Note that when \(\equations\) is empty,
\(\smc{\generators, \emptyset} = \smc{\generators}\).

\subsection{Case study: commutative monoids}

Monoidal theories can be used to reason with many structures in mathematics.
One such structure is that of \emph{commutative monoids}.

\begin{definition}[Commutative monoids]\label{def:commutative-monoid}
    The monoidal theory of
    \emph{commutative monoids} is \(
        (\generators[\cmon], \equations[\cmon])
    \), where \(
        \generators[\cmon] := \{
            \iltikzfig{strings/structure/monoid/merge}[white],
            \iltikzfig{strings/structure/monoid/init}[white]
        \}
    \) representing the \emph{multiplication} and the \emph{unit} respectively,
    and \(\equations[\frob]\) comprises the equations
    \begin{center}
        \iltikzfig{strings/structure/monoid/unitality-l-lhs}
        \(=\)
        \iltikzfig{strings/structure/monoid/unitality-l-rhs}
        \quad
        \iltikzfig{strings/structure/monoid/associativity-lhs}
        \(=\)
        \iltikzfig{strings/structure/monoid/associativity-rhs}
        \quad
        \iltikzfig{strings/structure/monoid/commutativity-lhs}
        \(=\)
        \iltikzfig{strings/structure/monoid/commutativity-rhs}
    \end{center}
    We write \(\cmon := \smc{\generators[\cmon], \equations[\cmon]}\).
\end{definition}

The two generators of the theory are a \emph{multiplication} and a \emph{unit}.
The equations describe the properties of the multiplication: it is unital with
respect to the unit; it is associative; and it is commutative.
These equations could be described textually, but the string diagrams provide
intuitive visual interpretations; often it is insightful to reason
\emph{diagrammatically}.

\begin{example}[Right unitality]
    \(
        \iltikzfig{strings/structure/monoid/unitality-r-lhs}
        =
        \iltikzfig{strings/structure/monoid/unitality-r-rhs}
    \) is a valid equation in \(\cmon\).
\end{example}
\begin{proof}
    \(
        \iltikzfig{strings/structure/monoid/unitality-r-lhs}
        \eqaxioms[(\dagger)]
        \iltikzfig{strings/structure/monoid/right-unitality/step-1}
        =
        \iltikzfig{strings/structure/monoid/unitality-l-lhs}
        =
        \iltikzfig{strings/structure/monoid/unitality-l-rhs}
    \)
\end{proof}

Note that the first step \((\dagger)\) of the proof is performed solely by
deforming the string diagram; recall that as connectivity is preserved this is
still valid.
While this proof was fairly simple, the same principles apply to reasoning about
more complex terms.

\begin{example}
    \(
        \iltikzfig{strings/structure/monoid/example/step-0}
        =
        \iltikzfig{strings/structure/monoid/example/step-7}
    \)
    is a valid equation in \(\cmon\).
\end{example}
\begin{proof}
    \(
        \iltikzfig{strings/structure/monoid/example/step-0}
        =
        \iltikzfig{strings/structure/monoid/example/step-1}
        =
        \iltikzfig{strings/structure/monoid/example/step-2}
        =
        \iltikzfig{strings/structure/monoid/example/step-3}
        =
        \\[1em]
        \iltikzfig{strings/structure/monoid/example/step-4}
        =
        \iltikzfig{strings/structure/monoid/example/step-5}
        =
        \iltikzfig{strings/structure/monoid/example/step-6}
        =
        \iltikzfig{strings/structure/monoid/example/step-7}
    \)
\end{proof}

\section{Related work}

There has recently been an explosion in the use of symmetric monoidal categories
for modelling of processes, such as for quantum
protocols~\cite{abramsky2004categorical}, signal flow
diagrams~\cite{bonchi2014categorical,bonchi2015full}, linear
algebra~\cite{bonchi2017interacting,zanasi2015interacting,bonchi2019graphical,boisseau2022graphical},
dynamical systems~\cite{baez2015categories,fong2016categorical}, electrical
circuits~\cite{boisseau2022string} and automatic
differentiation~\cite{alvarez-picallo2023functorial}.
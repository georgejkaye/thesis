\chapter{Monoidal categories and theories}

We begin with a meander through the categorical definitions and notation
required for our framework of sequential circuits.
While a similar outline can be found in any category theory textbook,
inspiration was taken in particular from the opening of
\cite{ghica2023hierarchical}.

\section{Terms}

Processes are modelled as \emph{terms}.
Before we can begin, the components that make up processes in a given system
must be sepcified.

\begin{notation}[List, sum]
    Given a set \(X\), the set of lists of elements of \(X\) is denoted
    \(\freemon{X}\).
    Words are written \([x_0, x_1, x_2, \cdots, x_{n-1}]\); the brackets around
    single element lists may be dropped when clear from context \(x := [x]\);
    and variables representing arbitrary lists are generally written with an
    overline \(
        \overline{x}, \overline{y}, \overline{z}... \in \freemon{X}
    \).
    Given two words \(\overline{x}, \overline{y}\), their concatenation is
    denoted \(\overline{x}\overline{y}\).
    The list of length \(n\) containing just element \(x\) is written \(x^n\).
    Given a list \(\overline{x}\), its \emph{length} is denoted
    \(\wordlen{\overline{x}}\); for \(i < \wordlen{\overline{x}}\), its
    \(i\)\emph{th element} is denoted \(\overline{x}(i)\); and its
    \emph{sum}, denoted \(\wordsum{\overline{x}}\), is computed as
    \(\Sigma_{i < |\overline{m}|}\overline{m}(i)\).
\end{notation}

\begin{notation}
    Let \(\natplus\) be the set of non-zero natural numbers.
\end{notation}

\begin{definition}[Generators]
    A set of \emph{generators} is a set \(\generators\) equipped with two
    functions \(\morph{\domw,\codw}{\generators}{\natplus^\star}\).
\end{definition}

Generators are the primitive building blocks of terms: their domains and
codomains specify the widths of their input and output wires respectively.
Terms are defined by combining these primitives together.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of generators.
    A \(\generators\)-term is written \(\morph{f}{\overline{m}}{\overline{n}}\)
    where \(\overline{m}, \overline{n} \in \natplus^\star\).
    The set of \(\generators\)-terms, denoted \(\sigmaterms\), is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\domw[\phi]}{\codw[\phi]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[n]}{[n]}{[n]} \in \sigmaterms\)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(
                \morph{\swap{m}{n}}{[m,n]}{[n,m]} \in \sigmaterms
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\wordsum{\overline{m}} = \wordsum{\overline{n}}\)}
            \UnaryInfC{\(
                \morph{\bundle{\overline{m}}{\overline{n}}}{\overline{m}}{\overline{n}} \in \sigmaterms
            \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{n}}{\overline{p}} \in \sigmaterms\)}
            \BinaryInfC{\(\morph{f \seq g}{\overline{m}}{\overline{p}} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{\overline{m}}{\overline{n}} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{\overline{p}}{\overline{q}} \in \sigmaterms\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{\overline{mp}}{\overline{nq}} \in \sigmaterms
            \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms are constructed recursively.
There are four base cases: a generator from \(\generators\) with appropriate
inputs and outputs;
an \emph{identity} for empty wires with no generators;
a \emph{symmetry} for swapping over two wires;
and a \emph{bundler} for reorganising lists of wires.
The two inductive cases are called \emph{composition} and \emph{tensor}
respectively.
Intuitively, these can be thought of generating larger terms by sequencing
subterms in sequence or parallel.

\(\Sigma\)-terms will be abbreviated to `terms' when the signature is clear from
context.

\section{Symmetric monoidal categories}

So far, terms are purely syntax, and terms are only equal if they are
constructed in precisely the same way.
Even without considering the interaction of generators with each other, there
are numerous `structural equations' which need to hold to be useful for
modelling processes.

\begin{example}
    Consider the term \(f \seq \id[n]\), which can be read as `run \(f\) and
    then do nothing'.
    Since we are only concerned with the \emph{input-output} behaviour of
    processes, this should be the same as just \(f\).
    However, as it stands \(f \seq \id[n]\) and \(f\) are not equal.
\end{example}

One could just add all the `right' equations manually, but what are the `right'
equations?
It turns out that an elegant mathematical formalism exists in the form of
\emph{symmetric monoidal categories}.

\subsection{Category}

We begin by defining the structure underlying much of the work to come; that of
a \emph{category}.

\begin{definition}[Categories]
    \label{def:category}
    A \emph{category} \(\mcc\) consists of a class of \emph{objects}
    \(\ob{\mcc}\); a class of \emph{morphisms} \(\mor{\mcc}{A}{B}\)
    for every pair of objects \(A, B \in \ob{\mcc}\); and a \emph{composition}
    operation \(
        \morph{
            {-} \circ {=}
        }{
            \mor{\mcc}{B}{C} \times \mor{\mcc}{A}{B}
        }{
            \mor{\mcc}{A}{C}
        }
    \) such that
    \begin{itemize}
        \item composition is \emph{unital}: for every \(
                    A \in \ob{\mcc}
                \) there exists an \emph{identity morphism} \(
                    \id[A] \in \mor{\mcc}{A}{A}
                \) satisfying \(
                    f \circ \id[A] = f = \id[B] \circ f
                \) for any \(
                    f \in \mor{\mcc}{A}{B}
                \); and
        \item composition is \emph{associative}: for any morphisms \(
                    f \in \mor{\mcc}{A}{B}
                \), \(
                    g \in \mor{\mcc}{B}{C}
                \) and \(h \in \mor{\mcc}{C}{D}\), \(
                    (h \circ g) \circ f = h \circ (g \circ f).
                \)
    \end{itemize}
\end{definition}

A morphism \(f \in \mor{\mcc}{A}{B}\) is also called an \emph{arrow}, and will
often be written \(\morph{f}{A}{B}\) accordingly.
The subscripts on the object and morphism classes are also often omitted.

\subsubsection{Commutative diagrams}

Equations in category theory can be expressed using \emph{commutative diagrams}.
For example, the unitality and associativity of composition can be illustrated
as follows:

\begin{center}
    \includestandalone{figures/category/coherences/unitality}
    \quad
    \includestandalone{figures/category/coherences/associativity}
\end{center}

We say that the above two diagrams \emph{commute} precisely because \(
    \id[B] \circ f = f = f \circ \id[A]
\) and \((h \circ g) \circ f = h \circ (g \circ f)\): no matter which path one
takes, the results are equal.
Using commutative diagrams suggests another notation for composition.

\begin{notation}
    \emph{Diagrammtic order} composition is written as
    \(f \seq g := g \circ f\).
\end{notation}

\subsubsection{Examples of categories}

Categories generalise a plethora of mathematical structures: some examples will
now be provided.

\begin{example}[Preorder]
    A \emph{preorder} is a binary relation \(\leq\) on a set \(X\) which is
    reflexive and transitive.
    Any preorder generates a category \(\mcc_\leq\): the objects are the
    elements of \(X\) and \(\mcc_\leq(x, y)\) contains exactly one morphism if
    \(x \leq y\) and none otherwise.
\end{example}

\begin{example}[Sets]
    The category \(\set\) has sets as objects and functions as morphisms.
    Composition is then just function composition.
    Note that the monomorphisms of \(\set\) are the injective functions and the
    isomorphisms the bijective functions.
    Compare this with the category \(\rel\), which has sets as objects and
    \emph{relations} as morphisms.
\end{example}

\begin{example}[Posets]
    A \emph{partial order} on a set \(X\) is a reflexive, antisymmetric and
    transitive relation \(\leq \subseteq X \times X\).
    A set equipped with a partial order is called a
    \emph{partially ordered set}, or \emph{poset} for short.
    A function \(\morph{f}{X}{Y}\) between posets is called \emph{monotone} if
    \(x \leq y\) implies that \(f(x) \leq f(y)\).

    Much like how sets form a category, posets form the category \(\pos\), where
    \(\ob{\pos}\) are sets and \(\hom{\pos}{X}{Y}\) are the monotone functions
    \(X \to Y\).
\end{example}

\begin{example}[Monoids]
    A \emph{monoid} is a tuple \((X, *, \bullet)\) where \(X\) is a set called
    the \emph{carrier}, \(\morph{*}{X \times X}{X}\) is a binary operation
    called the \emph{multiplication}, and \(\bullet \in X\) is an element called
    the \emph{unit}, such that \(x * \bullet = x = \bullet * x\) for any
    \(x \in X\).
    A \emph{monoid homomorphism} between two monoids \((X, *, e_X)\) and
    \((Y, +, e_Y)\) is a map \(\morph{h}{X}{Y}\) such that
    \(h(x * y) = h(x) + h(y)\) and \(h(e_X) = e_Y\).
    There is a category \(\mon\) with the objects as monoids and morphisms as
    their homomorphisms.
\end{example}

\begin{example}[Product category]
    Given two categories \(\mcc\) and \(\mcd\), their \emph{product category}
    \(\mcc \times \mcd\) is the category with objects are defined as \(
        \ob{(\mcc \times \mcd)} := \ob{\mcc} \times \ob{\mcd}
    \) and the morphisms as \[
        \mor{(\mcc \times \mcd)}{(A, A^\prime)}{(B, B^\prime)}
        :=
        \{
            (f, f^\prime)
            \,|\,
            f \in \mor{\mcc}{A}{B},
            f^\prime \in \mor{\mcd}{A^\prime}{B^\prime}
        \}
    \]
\end{example}

\subsubsection{Properties of morphisms}

When using category theory as a tool for reasoning, often the objects are not
particular interesting: it is the \emph{morphisms} that hold the useful
information.
There are many properties that morphsims can hold; we will detail two which will
be useful in this thesis.

\begin{definition}[Monomorphism]
    A morphism \(\morph{f}{A}{B} \in \mcc\) is called a \emph{monomorphism} (or
    simply \emph{mono} for short) if for any two morphisms
    \(\morph{g_1,g_2}{C}{A}\), if \(f \circ g_1 = f \circ g_2\), then
    \(g_1 = g_2\).
\end{definition}

One can think of monomorphisms are \emph{left-cancellative} morphisms.
There is also a categorical generalisation of \emph{invertible} morphisms.

\begin{definition}[Isomorphism]
    A morphism \(\morph{f}{A}{B} \in \mcc\) is called an \emph{isomorphism} (or
    simply \emph{iso} for short) if there also exists a morphism \(
        \morph{\inverse{f}}{B}{A} \in \mcc
    \) such that \(
        \inverse{f} \circ f = \id[A]
    \) and \(
        f \circ \inverse{f} = \id[B]
    \).
\end{definition}

\begin{example}
    In \(\set\), the monomorphisms are the injective functions and the
    isomorphisms are the surjective functions.
\end{example}

\subsection{String diagrams}

Since composition is associative in a category, we can drop any brackets around
terms like \(
    f \seq ((g \seq h) \seq k)
\) and simply write them as \(
    f \seq g \seq h \seq k
\), which is much easier to read.
However, as we add more structure in the upcoming sections the textual
descriptions will quickly become indecipherable.
Therefore, it is useful to consider an alternative \emph{graphical} notation
known as \emph{string diagrams}~\cite{joyal1991geometry}.
In a string diagram, a morphism \(\morph{f}{A}{B}\) is drawn as a box \(
    \iltikzfig{strings/category/f}[f][white][A][B]
\), and the identity \(\morph{\id[A]}{A}{A}\) is drawn as a wire \(
    \iltikzfig{strings/category/identity}[white][A]
\).
Composition is depicted as \emph{horizontal juxtaposition}. \[
    \iltikzfig{strings/category/f}[f][white][A][B]
    \seq
    \iltikzfig{strings/category/f}[g][white][B][C] :=
    \iltikzfig{strings/category/composition}[f][g][white][A][B][C]
\]
The power of string diagrams comes from how they `absorb' the equations of a
category, as shown in \cref{fig:c-equations}.

\input{floats/c-equations}

Aside from being convenient from a notational point of view, the diagrams are
also far more intuitive!
The extra structure we will introduce later also has an elegant graphical
interpretation in the string diagram notation.

\begin{remark}
    The direction that the `flow' of string diagrams travels from inputs to
    outputs is a hotly-debated topic; in this thesis we adopt the left-to-right
    approach.
    If you prefer another, you could rotate the document by ninety degrees or
    use a mirror.
\end{remark}

\subsection{Functors}

It is actually quite rare that we are only making use of one category at a time.
In order to compare categories, we need a notion of \emph{mapping between} them.
A class of maps that enjoy some useful properties are known as \emph{functors}.

\begin{definition}[Functor]
    Given two categories \(\mcc\) and \(\mcd\), a \emph{functor} \(
        \morph{F}{\mcc}{\mcd}
    \) maps objects and morphisms in \(\mcc\) to objects and morphisms in
    \(\mcd\) such that
    \begin{itemize}
        \item \(F(\id[A]) = \id[FA]\) for every \(A \in \ob{\mcc})\); and
        \item \(F(g \circ f) = F(g) \circ F(f)\) for every \(\morph{f}{A}{B}\)
        and \(\morph{g}{B}{C}\).
    \end{itemize}
\end{definition}

A functor \(F\) maps an object \(X\) in one category to an object \(FX\) in
another, and morphisms \(\morph{f}{X}{Y}\) to \(\morph{Ff}{FX}{FY}\).
The two equations are known as the \emph{functoriality} equations; if a map
satisfies these it is \emph{functorial} i.e.\ it is a functor.

Functors have a graphical representation as `functorial
boxes'~\cite{mellies2006functorial}; applying a functor \(\morph{F}{\mcc}{\mcd}\)
to a morphism \(\morph{f}{X}{Y}\) is drawn as
\[
    \iltikzfig{strings/category/functors/f}[f][F][white][X][Y]
\]
As always, the wire labels are optional and will be omitted if unambious.
The functoriality equations are represented as in
\cref{fig:functoriality-equations}.

\input{floats/functoriality-equations}

\begin{definition}[Endofunctor]
    An \emph{endofunctor} on a category \(\mcc\) is a functor \(\mcc \to \mcc\).
\end{definition}

\subsubsection{Examples of functors}

\begin{example}[Identity functor]
    A trivial endofunctor for any category \(\mcc\) is the
    \emph{identity functor} \(\morph{\idf}{\mcc}{\mcc}\) which acts as the
    identity on objects and morphisms.
\end{example}

\begin{example}[Powerset functor]
    The notion of powerset can be interpreted as an endofunctor \(
        \morph{\powerset}{\set}{\set}
    \), mapping a set \(X\) to its powerset \(\powerset(X)\) and a morphism
    \(\morph{f}{X}{Y}\) to the function \(\powerset(X) \to \powerset(Y)\) which
    applies \(f\) pointwise.
\end{example}

\begin{example}[List functor]\label{ex:list-functor}
    A functor that crops up frequently in computer science is the
    \emph{list functor} \(\morph{\listf}{\set}{\set}\), which sends a set
    \(X\) to its set of lists \(\freemon{X}\), and sends a function
    \(\morph{f}{X}{Y}\) to the function
    \(\morph{\freemon{f}}{\freemon{X}}{\freemon{Y}}\): which applies \(f\)
    to each element of a list.
\end{example}

\begin{example}[Free monoid]\label{ex:free-monoid}
    When talking about a mathematical structure \(S\), there is often a notion
    of the \emph{free \(S\)}, which can be viewed as the most `bare-bones'
    version of \(S\).
    For example, the set of lists \(\freemon{X}\) is the carrier of the
    \emph{free monoid} on \(X\).
    This means there is a functor \(\morph{F}{\set}{\mon}\) (the
    \emph{free functor}) that acts on objects as \(
        X \mapsto (\freemon{X}, \concat, [])
    \) and sends morphisms \(X \to Y\) to the corresponding monoid homomorphism
    \(\freemon{X} \to \freemon{Y}\).

    There is also a \emph{forgetful} or \emph{underlying} functor
    \(\morph{U}{\mon}{\set}\) which sends a monoid \((X, *, e)\) to its carrier
    set \(X\) and `forgets' the monoid structure.
    These functors form a relationship known as an \emph{adjunction}, but this
    is beyond the scope of this thesis.
\end{example}

\subsection{Natural transformations}

As we have seen, functors are useful for mapping objects and morphisms from one
category to another in a way that respects the underlying compositional
structure.
Of course, there may be many such functors \(\mcc \to \mcd\); the logical next
step is to consider maps between functors themselves.
These maps are known as \emph{natural transformations}.

\begin{definition}[Natural transformation]
    Given two functors \(\morph{F, G}{\mcc}{\mcd}\), a
    \emph{natural transformation} \(\morph{\eta}{F}{G}\) is a family of
    morphisms \(
        \eta_A \in \mor{\mcd}{FA}{GA}
    \) for each \(A \in \ob{\mcc}\), called the \emph{components} of \(\eta\),
    such that \(
        \eta_B \circ Ff = Gf \circ \eta_A
    \), i.e.\ the following diagram commutes:
    \begin{center}
        \includestandalone{figures/category/coherences/natural}
    \end{center}
\end{definition}

The key point to take is that for functors \(\morph{F,G}{\mcc}{\mcd}\), a
natural transformation \(\morph{\eta}{F}{G}\) is a \emph{family} of morphisms
\(\morph{\eta_A}{FA}{GA} \in \mcd\) for each object \(A \in \mcd\).
Subsequently, one can think of a natural transformation as a way of inducing
morphisms of a certain structure across an \emph{entire category}.

Graphically, the naturality equation can be seen as how a natural transformation
can be `pushed through' morphisms, as shown in \cref{fig:naturality-equations}.

\input{floats/naturality-equations}

\begin{example}[Singleton]
    Recall the \(\listf\) functor from \cref{ex:list-functor}.
    An example of a natural transformation is the
    \emph{singleton transformation} \(\morph{[-]}{\idf}{\listf}\), which
    induces a function \(\morph{[-]}{X}{\freemon{X}}\) for each set \(X\),
    defined as \(x \mapsto [x]\).
\end{example}

\begin{example}[Reduce]
    Recall the functors \(\morph{F}{\set}{\mon}\) and \(\morph{U}{\mon}{\set}\)
    from \cref{ex:free-monoid}.
    Functors can be composed just like morphisms, so \(F \circ U\) is a
    functor \(\mon \to \mon\): such a functor has action \(
        (X, *, e) \mapsto (\freemon{X}, \concat, [])
    \).
    Subsequently, the component of a natural transformation \(
        F \circ U \to \idf
    \) at object \((X, *, e)\) is a monoid homomorphism \(
        (\freemon{X}, \concat, []) \to (X, *, e)
    \), i.e.\ a function \(\freemon{X} \to X\).

    One example of such a natural transformation is the \emph{reduce} or
    \emph{fold} operation, which takes a list in \(\freemon{X}\) and reduces it
    to an element of \(X\) by starting with the unit \(e\) and multiplying it
    with each element of the list in turn.
\end{example}

As natural transformations are defined in terms of families of morphisms, they
can inherit properties of the components.

\begin{definition}[Natural isomorphism]
    A natural transformation is called a \emph{natural isomorphism} if every
    component is an isomorphism.
\end{definition}

\subsection{Monoidal categories}

We will now apply the concepts of functors and natural transformations in order
to interpret \emph{parallel} composition \(\tensor\).
A setting with both sequential and parallel composition can be modelled by a
\emph{monoidal category}.

\begin{definition}[Bifunctor]
    A \emph{bifunctor} is a functor with a product category as its domain, i.e.\
    a functor of the form \(\mcc \times \mcd \to \mce\).
\end{definition}

We adapt the notation of functorial boxes to show how bifunctors map from two
categories into one.
\[
    \iltikzfig{strings/category/functors/bif}[f][g][white][F][X][Y][Z][W]
\]
The diagrammatic notation suggests that a bifunctor is exactly what we need to
model parallel composition!

\begin{definition}[Monoidal category]
    \label{def:monoidal-category}
    A \emph{monoidal category} is a category \(\mcc\) equipped with a
    bifunctor \(\morph{{-} \tensor {=}}{\mcc \times \mcc}{\mcc}\) called the
    \emph{tensor product} and an additional object \(I\) called the
    \emph{monoidal unit},
    along with natural isomorphisms
    \begin{itemize}
        \item \(
            \associator{A}{B}{C}
            \colon
            A \tensor (B \tensor C)
            \cong
            (A \tensor B) \tensor C
            \) called the \emph{associator};
        \item \(
            \leftunitor{A}
            \colon
            I \tensor A
            \cong
            A
            \) called the \emph{left unitor}; and
        \item \(
            \rightunitor{A}
            \colon
            A \tensor I
            \cong
            A
            \) called the \emph{right unitor}
    \end{itemize}
    such that the \emph{pentagon} and the \emph{triangle} diagrams below
    commute:
    \begin{center}
        \includestandalone{figures/category/coherences/pentagon}

        \vspace{1em}

        \includestandalone{figures/category/coherences/triangle}
    \end{center}
\end{definition}

\begin{example}
    \(\set\) is a monoidal category, with the tensor product defined as the
    Cartesian product (\(A \tensor B := A \times B\)) and the unit as the
    singleton set (\(I := \mathbbm{1}\)).
\end{example}


We adopt the convention that \(f \tensor g \seq h \tensor k\) should be
bracketed as \((f \tensor g) \seq (h \tensor k)\), i.e.\ \(\tensor\) binds
more strongly than \(\seq\).
As with the case of regular categories, using a string diagrammatic notation
will make this distinction irrelevant.

The definition of monoidal category we have presented is quite general,
particularly with regards to the natural isomorphisms for unitors and
associators.
Most of the time, it is sufficient for these isomorphisms to hold `on the nose'.

\begin{definition}[Strict monoidal category]
    A monoidal category is \emph{strict} if \(\lambda\), \(\rho\) and \(\alpha\)
    are identities.
\end{definition}

In a strict monoidal category, the unitality and associativity of the tensor
hold as equations, as they do for regular composition in a category.
With this in mind, it can be instructive to view the coherences of a monoidal
category in terms of equations.

\input{floats/mc-equations}

\begin{example}
    \(\set\) is a monoidal category, with the tensor product defined as the
    Cartesian product (\(A \tensor B := A \times B\)) and the unit as the
    singleton set (\(I := \mathbbm{1}\)).
\end{example}


We can now construct morphisms by composing them in sequence and in parallel.
The next construct to consider are the \emph{symmetries}.

\begin{definition}[Symmetric monoidal category]
    \label{def:symmetric-monoidal-category}
    A \emph{symmetric monoidal category} (SMC) is a monoidal category \(\mcc\)
    equipped with natural isomorphisms \(
        \swap{A}{B} \colon A \tensor B \cong B \tensor A
    \) such that the following diagrams commute:
    \begin{center}
        \includestandalone{figures/category/coherences/symmetry-unit}
        \includestandalone{figures/category/coherences/symmetry-inverse}

        \vspace{1em}

        \includestandalone[scale=0.95]{figures/category/coherences/hexagon}
    \end{center}
\end{definition}

\begin{example}
    \(\set\) is a symmetric monoidal category, with \(
        \morph{\swap{A}{B}}{A \times B}{B \times A}
    \) defined as the function that swaps elements of a pair.
\end{example}

As with monoidal categories, it is natural to consider \emph{strict} symmetric
monoidal categories and view them in terms of their equations.

\input{floats/smc-equations}

\subsection{PROPs}

We have described the categorical structure required to interpret five of the
constructors listed in \cref{def:terms}; only the `bundlers'
\(\bundle{\overline{m}}{\overline{n}}\) remain.
However, to give these meaning we must consider a slightly more specialised
setting; a subclass of symmetric monoidal categories known as \emph{PROPs}.

\begin{definition}[Multi-sorted PROP~\cite{maclane1965categorical}]
    Given a set of \emph{sorts} \(\mcc\), a \(\mcc\)-sorted \emph{PROP}
    (category of \emph{PRO}ducts and \emph{P}ermutations) is a strict symmetric
    monoidal category with the objects as words in \(\freemon{\mcc}\) and tensor
    product as concatenation.
\end{definition}

Note that this definition means that the empty word \(\varepsilon\) is the unit
object in any \(\mcc\)-sorted PROP.
As the domain and codomains of generators in \(\generators\) are words of
natural numbers, it is clear to see how a multi-sorted PROP can be used for our
scenario.

\begin{definition}\label{def:freely-generated-prop}
    Given a set of generators \(\generators\), let \(\smc{\generators}\) be the
    \(\natplus\)-sorted PROP where \(
        \smc{\generators}(\overline{m}, \overline{n})
    \) is the set of \(\Sigma\)-terms of type \(\overline{m} \to \overline{n}\).
\end{definition}

The symmetric monoidal structure of \(\smc{\generators}\) means that
\(\generators\)-terms are now subject to the equations listed in
\cref{fig:structural-equations-strings}

\input{floats/structural-equations-strings}

\section{Interpreting the bundlers}

In the context of \(\natplus\)-sorted PROPs, the bundler generators
\(\bundle{\overline{m}}{\overline{n}}\) have an interpretation as morphisms
\(\overline{m} \to \overline{n}\) where the source and target words have the
same sum, but constructed in a different way, such as \([1,2] \to [2,1]\).
These constructs were first proposed by Wilson et al in~\cite{wilson2023string}
as a notation for \emph{non-strict categories}.
However, it is also noted that it could be used in the strict case as a way of
grouping and splitting wires.
We present a slight variation of their construction specialised for
\(\natplus\)-sorted PROPs.

\begin{definition}[Bundled PROP]
    Given a \(\natplus\)-sorted PROP \(\mcc\), its \emph{bundled PROP} is
    a \(\natplus\)-sorted PROP \(\bundled{\mcc}\) with the same objects as
    \(\mcc\) but equipped with additional generators \(
        \morph{\bundleexpand{n}}{n}{1^n}
    \) and \(
        \morph{\bundlecontract{n}}{1^n}{n}
    \),
    for every \(n \in \natplus\), such that \(\bundleexpand{n}\) and
    \(\bundlecontract{n}\) are inverses, i.e.\ \(
        \bundleexpand{n} \seq \bundlecontract{n} = \id[n]
    \) and \(
        \bundlecontract{n} \seq \bundleexpand{n} = \id[1^n]
    \).
\end{definition}

From these primitive generators, we can inductively define bundlers for
larger lists of wires.

\begin{definition}[Composite bundlers]
    For a list \(\overline{m} \in \natplus^\star\), the \emph{composite bundles}
    are defined as follows:
    \begin{gather*}
        \morph{
            \bundleexpand{\overline{m}}
        }{
            \overline{m}
        }{
            1^{\wordsum{\overline{m}}}
        }
        :=
        \bigtensor_{n \in \overline{m}} \bundleexpand{n}
        \quad
        \morph{
            \bundlecontract{\overline{m}}
        }{
            1^{\wordsum{\overline{m}}}
        }{
            \overline{m}
        }
        :=
        \bigtensor_{n \in \overline{m}} \bundlecontract{n}
        \quad
        \morph{
            \bundle{\overline{m}}{\overline{n}}
        }{
            \overline{m}
        }{
            \overline{n}
        }
        :=
        \bundleexpand{\overline{m}} \seq \bundlecontract{\overline{n}}
    \end{gather*}
\end{definition}

\section{Monoidal theories}

So far we have only concerned ourselves with \emph{structural} equations:
equations that show how the same term can be constructed using different
combinations of composition, tensor, the identity and symmetry.
However, these only serve as a form of housekeeping: the true `computational
content' of processes comes from equations that show how the generators interact
with \emph{each other}.
These equations are provided by a \emph{monoidal theory}.

\begin{definition}[Monoidal theory]
    A \emph{monoidal theory} is a tuple \((\generators, \equations)\) where
    \(\generators\) is a set of generators and \(\equations\) is a set of
    equations.
\end{definition}

An equation \(f = g\) in a monoidal theory \emph{identifies} the two morphisms
\(f\) and \(g\).
When reasoning with a monoidal theory, we therefore need to work in a category
in which all of the equations are identified in this way.

\begin{definition}[Quotient category]
    Given a category \(\mathbf{C}\) and a set of equations \(\mce\) between
    morphisms in \(\mathbf{C}\) with the same source and target, the
    \emph{quotient category} \(\mathbf{C} / \mce\) is the category in which
    \(\ob{(\mathbf{C} / \mce)} := \ob{\mathbf{C}}\) and \(
            \mor{(\mathbf{C} / \mce)}{X}{Y}
            :=
            \mor{\mathbf{C}}{X}{Y} / \mce
    \): i.e.\ morphisms are the \emph{equivalence classes} of morphisms
    modulo \(\mce\).
\end{definition}

\begin{definition}
    Given a monoidal theory \((\generators, \equations)\), let
    \(\smc{\generators, \equations} := \smc{\generators} / \equations\).
\end{definition}

Note that when \(\equations\) is empty,
\(\smc{\generators, \emptyset} = \smc{\generators}\).

\subsection{Case study: commutative monoids}

Monoidal theories can be used to reason with many structures in mathematics.
One such structure is that of \emph{commutative monoids}.

\begin{definition}[Commutative monoids]\label{def:commutative-monoid}
    The monoidal theory of
    \emph{commutative monoids} is \(
        (\generators[\cmon], \equations[\cmon])
    \), where \(
        \generators[\cmon] := \{
            \iltikzfig{strings/structure/monoid/merge}[white],
            \iltikzfig{strings/structure/monoid/init}[white]
        \}
    \) representing the \emph{multiplication} and the \emph{unit} respectively,
    and \(\equations[\frob]\) comprises the equations
    \begin{center}
        \iltikzfig{strings/structure/monoid/unitality-l-lhs}
        \(=\)
        \iltikzfig{strings/structure/monoid/unitality-l-rhs}
        \quad
        \iltikzfig{strings/structure/monoid/associativity-lhs}
        \(=\)
        \iltikzfig{strings/structure/monoid/associativity-rhs}
        \quad
        \iltikzfig{strings/structure/monoid/commutativity-lhs}
        \(=\)
        \iltikzfig{strings/structure/monoid/commutativity-rhs}
    \end{center}
    We write \(\cmon := \smc{\generators[\cmon], \equations[\cmon]}\).
\end{definition}

The two generators of the theory are a \emph{multiplication} and a \emph{unit}.
The equations describe the properties of the multiplication: it is unital with
respect to the unit; it is associative; and it is commutative.
These equations could be described textually, but the string diagrams provide
intuitive visual interpretations; often it is insightful to reason
\emph{diagrammatically}.

\begin{example}[Right unitality]
    \(
        \iltikzfig{strings/structure/monoid/unitality-r-lhs}
        =
        \iltikzfig{strings/structure/monoid/unitality-r-rhs}
    \) is a valid equation in \(\cmon\).
\end{example}
\begin{proof}
    \(
        \iltikzfig{strings/structure/monoid/unitality-r-lhs}
        \eqaxioms[(\dagger)]
        \iltikzfig{strings/structure/monoid/right-unitality/step-1}
        =
        \iltikzfig{strings/structure/monoid/unitality-l-lhs}
        =
        \iltikzfig{strings/structure/monoid/unitality-l-rhs}
    \)
\end{proof}

Note that the first step \((\dagger)\) of the proof is performed solely by
deforming the string diagram; recall that as connectivity is preserved this is
still valid.
While this proof was fairly simple, the same principles apply to reasoning about
more complex terms.

\begin{example}
    \(
        \iltikzfig{strings/structure/monoid/example/step-0}
        =
        \iltikzfig{strings/structure/monoid/example/step-7}
    \)
    is a valid equation in \(\cmon\).
\end{example}
\begin{proof}
    \(
        \iltikzfig{strings/structure/monoid/example/step-0}
        =
        \iltikzfig{strings/structure/monoid/example/step-1}
        =
        \iltikzfig{strings/structure/monoid/example/step-2}
        =
        \iltikzfig{strings/structure/monoid/example/step-3}
        =
        \\[1em]
        \iltikzfig{strings/structure/monoid/example/step-4}
        =
        \iltikzfig{strings/structure/monoid/example/step-5}
        =
        \iltikzfig{strings/structure/monoid/example/step-6}
        =
        \iltikzfig{strings/structure/monoid/example/step-7}
    \)
\end{proof}

\section{Semantics}

\section{Related work}

There has recently been an explosion in the use of symmetric monoidal categories
for modelling of processes, such as for quantum
protocols~\cite{abramsky2004categorical}, signal flow
diagrams~\cite{bonchi2014categorical,bonchi2015full}, linear
algebra~\cite{bonchi2017interacting,zanasi2015interacting,bonchi2019graphical,boisseau2022graphical},
dynamical systems~\cite{baez2015categories,fong2016categorical}, electrical
circuits~\cite{boisseau2022string} and automatic
differentiation~\cite{alvarez-picallo2023functorial}.
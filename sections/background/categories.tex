\chapter{Monoidal categories and theories}

\section{Category}

We begin by recalling some basic notions from category theory.

\begin{definition}[Category]
    \label{def:category}
    A \emph{category} \(\mcc\) consists of a class of \emph{objects}
    \(\ob{\mcc}\); a class of \emph{morphisms} \(\mor{\mcc}{A}{B}\)
    for every pair of objects \(A, B \in \ob{\mcc}\); and a \emph{composition}
    operation \(
        \morph{
            {-} \circ {=}
        }{
            \mor{\mcc}{B}{C} \times \mor{\mcc}{A}{B}
        }{
            \mor{\mcc}{A}{C}
        }
    \) such that
    \begin{itemize}
        \item composition is \emph{unital}: for every \(
                    A \in \ob{\mcc}
                \) there exists an \emph{identity morphism} \(
                    \id[A] \in \mor{\mcc}{A}{A}
                \) satisfying \(
                    f \circ \id[A] = f = \id[B] \circ f
                \) for any \(
                    f \in \mor{\mcc}{A}{B}
                \); and
        \item composition is \emph{associative}: for any morphisms \(
                    f \in \mor{\mcc}{A}{B}
                \), \(
                    g \in \mor{\mcc}{B}{C}
                \) and \(h \in \mor{\mcc}{C}{D}\), \(
                    (h \circ g) \circ f = h \circ (g \circ f).
                \)
    \end{itemize}
\end{definition}

A morphism \(f \in \mor{\mcc}{A}{B}\) is also called an \emph{arrow}, and will
often be written \(\morph{f}{A}{B}\) accordingly.
The subscripts on the object and morphism classes are also often omitted.
Equations in category theory can be expressed using \emph{commutative diagrams}.
For example, the unitality and associativity of composition can be illustrated
as follows:

\begin{center}
    \includestandalone{figures/category/coherences/unitality}
    \quad
    \includestandalone{figures/category/coherences/associativity}
\end{center}

We say that the above two diagrams \emph{commute} precisely because \(
    \id[B] \circ f = f \circ \id[A]
\): no matter which path one takes, the results are equal.
When expressing conditions using commutative diagrams, it becomes natural to
also consider an alternative notation for composition.

\begin{notation}
    \emph{Diagrammatic-order} composition is defined as
    \(f \seq g := g \circ f\).
\end{notation}

\begin{example}[Preorder]
    A \emph{preorder} is a binary relation \(\leq\) on a set \(X\) which is
    reflexive and transitive.
    Any preorder generates a category \(\mcc_\leq\): the objects are the
    elements of \(X\) and \(\mcc_\leq(x, y)\) contains exactly one morphism if
    \(x \leq y\) and none otherwise.
\end{example}

\begin{example}[Category of sets]
    The category \(\set\) has sets as objects and functions as morphisms.
    Composition is then just function composition.
\end{example}

Considering the category of sets is useful, as many concepts in category theory
are generalisations of more familiar notions from set theory.
Firstly, we consider the categorical view on \emph{injective} functions.

\begin{definition}[Monomorphism]
    A morphism \(\morph{f}{A}{B}\) is a called a \emph{monomorphism} (or simply
    \emph{mono} for short) if for all morphisms \(\morph{g,h}{C}{A}\), \(
        f \circ g = f \circ h \Rightarrow g = h
    \).
\end{definition}

\begin{example}
    A morphism in \(\set\) is mono if and only if it is an injection.
\end{example}

Morphisms can also be \emph{invertible}.

\begin{definition}[Isomorphism]
    A morphism \(\morph{f}{A}{B} \in \mcc\) is called an \emph{isomorphism} (or
    simply \emph{iso} for short) if there also exists a morphism \(
        \morph{\inverse{f}}{B}{A} \in \mcc
    \) such that \(
        \inverse{f} \circ f = \id[A]
    \) and \(
        f \circ \inverse{f} = \id[B]
    \).
\end{definition}

\begin{example}
    A morphism in \(\set\) is an iso if and only if it is a bijection.
\end{example}

\begin{remark}
    There is also a categorical parallel to the \emph{surjective} functions
    known as an \emph{epimorphism} (or \emph{epi}), but we do not need to
    consider these in our work.
\end{remark}

\section{Functors}

It is rare that one only ever works with a single category at a time.
Consequently we require a way to map between them.

\begin{definition}[Functor]
    Given two categories \(\mcc\) and \(\mcd\), a \emph{functor} \(
        \morph{F}{\mcc}{\mcd}
    \) maps objects and morphisms in \(\mcc\) to objects and morphisms in
    \(\mcd\) such that
    \begin{itemize}
        \item \(F(\id[A]) = \id[FA]\) for every \(A \in \ob{\mcc})\); and
        \item \(F(g \circ f) = F(g) \circ F(f)\) for every \(\morph{f}{A}{B}\)
        and \(\morph{g}{B}{C}\).
    \end{itemize}
\end{definition}

Functors map between two categories.
It is natural to also consider maps between functors themselves.

\begin{definition}[Natural transformation]
    Given two functors \(\morph{F, G}{\mcc}{\mcd}\), a
    \emph{natural transformation} \(\morph{\eta}{F}{G}\) is a family of
    morphisms \(
        \eta_A \in \mor{\mcd}{FA}{GA}
    \) called \emph{components} for each \(A \in \ob{\mcc}\) such that \(
        \eta_B \circ Ff = Gf \circ \eta_A
    \), i.e.\ the following diagram commutes:
    \begin{center}
        \includestandalone{figures/category/coherences/natural}
    \end{center}
    A natural transformation is called a \emph{natural isomorphism} if
    every component is an isomorphism.
\end{definition}

The key point to take here is that for functors \(\morph{F,G}{\mcc}{\mcd}\), a
natural transformation \(\morph{\eta}{F}{G}\) is a \emph{family} of morphisms
\(\morph{\eta_A}{FA}{GA} \in \mcd\) for each object \(A \in \mcd\).

\begin{remark}
    There exists a category \(\cat\) in which `small' categories are the objects
    and functors are the morphisms.
    As natural transformations are morphisms between functors, in \(\cat\) they
    are morphisms between morphisms!
    A category with this structure is known as a \(2\)-category in higher
    category lingo, but will keep our feet firmly in the realm of
    \(1\)-categories in this thesis.
\end{remark}

\section{Monoidal categories}

Our interest in categories stems from modelling compositional \emph{processes}.
Processes can be viewed as morphisms: a morphism \(\morph{f}{A}{B}\) is a
process that transforms some input of type \(A\) into an output of type \(B\).
Composition allows us to string together multiple processes \(f, g, h\) in
sequence to create a composite process \(f \seq g \seq h\).

However, these processes are not particularly interesting: the inputs and
outputs can only be single types of and there is no notion of parallelism.
These issues can be allayed by adding structure to elevate a category into a
\emph{monoidal} category, which has a notion of \emph{parallel} composition in
addition to the already defined \emph{sequential} composition.
The parallel composition structure can be added to a regular category by using
a special kind of functor.

\begin{definition}[Product category]
    Given two categories \(\mcc\) and \(\mcd\), their \emph{product category}
    \(\mcc \times \mcd\) is the category in which the objects are defined as \(
        \ob{(\mcc \times \mcd)} := \ob{\mcc} \times \ob{\mcd}
    \) and the morphisms as \[
        \mor{(\mcc \times \mcd)}{(A, A^\prime)}{(A, A^\prime)}
        :=
        \{
            (f, f^\prime)
            \,|\,
            f \in \mor{\mcc}{A}{B},
            f^\prime \in \mor{\mcd}{A^\prime}{B^\prime}
        \}
    \]
\end{definition}

\begin{definition}[Bifunctor]
    A \emph{bifunctor} is a functor with a product category as its domain, i.e.\
    a functor of the form \(\mcc \times \mcd \to \mce\).
\end{definition}

\begin{definition}[Monoidal category]
    \label{def:monoidal-category}
    A \emph{monoidal category} is a category \(\mcc\) equipped with a
    bifunctor \(\morph{{-} \tensor {=}}{\mcc \times \mcc}{\mcc}\) called the
    \emph{tensor product} and an additional object \(I\) called the
    \emph{monoidal unit},
    along with natural isomorphisms
    \begin{itemize}
        \item \(
            \associator{A}{B}{C}
            \colon
            A \tensor (B \tensor C)
            \cong
            (A \tensor B) \tensor C
            \) called the \emph{associator};
        \item \(
            \leftunitor{A}
            \colon
            I \tensor A
            \cong
            A
            \) called the \emph{left unitor}; and
        \item \(
            \rightunitor{A}
            \colon
            A \tensor I
            \cong
            A
            \) called the \emph{right unitor}
    \end{itemize}
    such that the \emph{pentagon} and the \emph{triangle} diagrams below
    commute:
    \begin{center}
        \includestandalone{figures/category/coherences/pentagon}

        \vspace{1em}

        \includestandalone{figures/category/coherences/triangle}
    \end{center}
\end{definition}

We adopt the convention that \(f \tensor g \seq h \tensor k\) should be
bracketed as \((f \tensor g) \seq (h \tensor k)\), i.e.\ \(\tensor\) binds
more strongly than \(\seq\).
However, later in this chapter we will provide an alternative notation for terms
in monoidal categories which will make this distinction redundant.

\begin{example}
    \(\set\) is a monoidal category, with the tensor product defined as the
    Cartesian product (\(A \tensor B := A \times B\)) and the unit as the
    singleton set (\(I := \mathbbm{1}\)).
    The natural isomorphisms are identities.
\end{example}

This situation where the natural isomorphisms are identities arises frequently,
so it has its own name.

\begin{definition}[Strict monoidal category]
    A monoidal category is called \emph{strict} if the natural isomorphisms \(
        \associator{A}{B}{C}
    \), \(
        \leftunitor{A}
    \) and \(
        \rightunitor{B}
    \) are identities.
\end{definition}

We are generally only concerned with strict categories in this thesis.

\section{Symmetric monoidal categories}

We can now construct morphisms by composing them in sequence and in parallel.
However, there is one more facet of processes that needs modelling.
Imagine we have a process with output \(A \tensor B\) and another with inputs
\(B \tensor A\): it is often desirable to connect these together by swapping
over the outputs of the former.

\begin{definition}[Symmetric monoidal category]
    \label{def:symmetric-monoidal-category}
    A \emph{symmetric monoidal category} (SMC) is a monoidal category \(\mcc\)
    equipped with natural isomorphisms \(
        \swap{A}{B} \colon A \tensor B \cong B \tensor A
    \) such that the following diagrams commute:
    \begin{center}
        \includestandalone{figures/category/coherences/symmetry-unit}
        \includestandalone{figures/category/coherences/symmetry-inverse}

        \vspace{1em}

        \includestandalone[scale=0.95]{figures/category/coherences/hexagon}
    \end{center}
\end{definition}

\begin{example}
    \(\set\) is a symmetric monoidal category, with \(
        \morph{\swap{A}{B}}{A \times B}{B \times A}
    \) defined as the function that swaps elements of a pair.
\end{example}

\section{Symmetric monoidal theories}

As we have mentioned previously, the syntax of symmetric monoidal categories is
a good fit for modelling compositional processes.
We will now formally describe how to specify such a category of processes.
There is a particular subclass of SMCs in which this is especially natural.

\begin{definition}[PROP~\cite{maclane1965categorical}]
    A \emph{PROP} (category of \emph{PRO}ducts and \emph{P}ermutations) is a
    symmetric monoidal category with the objects as natural numbers as objects
    and tensor product as addition.
\end{definition}

Note that this definition means that \(0\) is the unit object in any PROP.
A morphism \(m \to n\) in a PROP can be thought of as a process with \(m\)
inputs and \(n\) outputs.

We will now construct a monoidal category of processes constructed from some
primitive \emph{generators}.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of \emph{generators} with functions \(
        \morph{\dom,\cod}{\generators}{\nat}
    \) for their \emph{arities} and \emph{coarities}.
    Then the set \(\generators_\mathsf{t}\) of \(\generators\)-\emph{terms} is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\dom[\phi]}{\cod[\phi]} \in \generators_\mathsf{t}
            \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[n]}{n}{n} \in \generators_\mathsf{t}\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(
                \morph{\swap{m}{n}}{m+n}{n+m} \in \generators_\mathsf{t}
            \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{m}{n} \in \generators_\mathsf{t}\)}
            \AxiomC{\(\morph{g}{n}{p} \in \generators_\mathsf{t}\)}
            \BinaryInfC{\(\morph{f \seq g}{m}{p}  \in \generators_\mathsf{t}\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{m}{n} \in \generators_\mathsf{t}\)}
            \AxiomC{\(\morph{g}{p}{q} \in \generators_\mathsf{t}\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{m+p}{n+q} \in \generators_\mathsf{t}
            \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms may be abbreviated to simply `terms' when the signature is
clear from context.

\begin{definition}[Freely generated PROP]
    For a set of generators \(\generators\), let \(\smc{\generators}\) be the
    PROP with the set of \(\Sigma\)-terms as the morphisms.
\end{definition}

The symmetric monoidal structure means that \(\smc{\generators}\) is subject to
numerous `structural' equations which show how the identity, symmetry,
composition and tensor interact with each other and the generators in
\(\generators\).
These equations can be derived from the diagrams in
\cref{def:category,def:monoidal-category,def:symmetric-monoidal-category}, and
are explicitly listed in \cref{fig:prop-axioms}.

\begin{figure}
    \centering
    \begin{gather*}
        \id[m] \seq  f = f
        \quad
        f = f \seq \id[n]
        \quad
        (f \seq g) \seq h = f \seq (g \seq h)
        \\[0.5em]
        \id[0] \tensor f = f
        \quad
        f \tensor \id[0] = f
        \quad
        (f \tensor g) \tensor h = f \tensor (g \tensor h)
        \\[0.5em]
        \id[m] \tensor \id[n] = \id[m+n]
        \quad
        (f \tensor g) \seq (h \tensor k) = (f \seq h) \tensor (g \seq k)
        \\[0.5em]
        (f \tensor g) \seq \swap{n}{q} = \swap{m}{p} \seq (g \tensor f)
        \quad
        (\swap{m}{n} \tensor \id[p]) \seq (\id[n] \tensor \swap{m}{p}) = \swap{m}{n+p}
        \\[0.5em]
        \swap{0}{n} = \id[n]
        \quad
        \swap{m}{0} = \id[m]
        \quad
        \swap{m}{n} \seq \swap{n}{m} = \id[m+n]
    \end{gather*}
    \caption{Summary of `structural' axioms that hold in \(\smc{\generators}\).}
    \label{fig:prop-axioms}
\end{figure}

However, these structural equations do not illustrate how the generators in
\(\generators\) interact with each other, which is crucial for modelling and
evaluating processes.
These equations are provided by a \emph{monoidal theory}.

\begin{definition}[Monoidal theory~\cite{bonchi2022string}]
    A single-sorted symmetric monoidal theory (SMT) is a tuple \(
        (\generators, \equations)
    \) where \(\generators\) is a set of generators as in \cref{def:terms} and
    \(\equations\) is a set of \emph{equations}: pairs \(\langle l, r\rangle\)
    where \(\morph{l, r}{m}{n}\) are \(\generators\)-terms with the same arity
    and coarity.
\end{definition}

\section{String diagrams}

One could reason exclusively with the one-dimensional terms detailed in the
previous section, but this quickly becomes unwieldy.
Although the structural axioms make sense, they are tedious to apply and
obfuscate the interesting equations between generators.

Fortunately there is an alternative: the graphical calculus of
\emph{string diagrams}~\cite{joyal1991geometry}.

\section{Symmetric traced monoidal categories}
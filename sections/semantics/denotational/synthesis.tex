\section{Between circuits and Mealy machines}

We have now established the close links between \(\streami\) and \(\mealyi\).
These results are nice to have but hardly ground-breaking; the main contribution
of this chapter is to introduce \(\scircsigma\) to the mix.

\subsection{Circuits to monotone Mealy machines}

Circuits have a very natural interpretation as Mealy machines, so the action
of a PROP morphism from \(\scircsigma\) to \(\mealyi\) is fairly intuitive.

\begin{definition}
    Let \(\morph{\circuittomealyi}{\scircsigma}{\mealyi}\) be the traced PROP
    morphism defined on generators as
    \begin{align*}
        \circuittomealy[
            \iltikzfig{circuits/components/gates/gate}[colour=comb]
        ]{\interpretation}
         & \coloneqq \left(
        \{s\},
        \left(s, \listvar{v}\right) \mapsto
        \left\langle{s, \gateinterpretation[g](\listvar{v})}\right\rangle,
        s
        \right)
        \\
        \circuittomealy[
            \iltikzfig{strings/structure/comonoid/copy}[colour=comb]
        ]{\interpretation}
         & \coloneqq \left(
        \{s\},
        (s, v) \mapsto \left\langle{s, (v, v)}\right\rangle,
        s
        \right)
        \\
        \circuittomealy[
            \iltikzfig{strings/structure/monoid/merge}[colour=comb]
        ]{\interpretation}
         & \coloneqq \left(
        \{s\},
        (s, (v, w)) \mapsto
        \left\langle{s, (v \ljoin w)}\right\rangle,
        s
        \right)
        \\
        \circuittomealy[
            \iltikzfig{strings/structure/comonoid/discard}[colour=comb]
        ]{\interpretation}
         & \coloneqq \left(
        \{s\},
        (s, v) \mapsto
        \left\langle{s, ()}\right\rangle,
        s
        \right)
        \\
        \circuittomealy[
            \iltikzfig{circuits/components/values/vs}[val=v]
        ]{\interpretation}
         & \coloneqq
        \left(
        \{s_v, s_\bot\},
        \{
        s_v \mapsto \left\langle{s_\bot,v}\right\rangle,
        s_\bot \mapsto \left\langle{s_\bot,\bot}\right\rangle
        \},
        s_v
        \right)
        \\
        \circuittomealy[
            \iltikzfig{circuits/components/waveforms/delay}
        ]{\interpretation}
         & \coloneqq
        \left(
        \{ s_v \,|\, v \in \values\},
        (s_v, a) \mapsto \left\langle{v,s_a}\right\rangle,
        s_\bot
        \right)
    \end{align*}
\end{definition}

\begin{example}
    The action of \(\circuittomealy{\belnapinterpretation}\) on values and
    delays in \(\scirc{\belnapsignature}\) is illustrated in
    \cref{fig:belnap-machines}.
\end{example}

\input{sections/semantics/denotational/floats/belnap-machines}

\begin{example}\label{ex:mealy-translation}
    Applying \(\circuittomealy{\belnapinterpretation}\) to the SR NOR latch from
    \cref{ex:latch} produces the monotone Mealy machine in
    \cref{ex:trace-mealy}.
\end{example}

Mealy machines are a reasonable semantics for sequential circuits, but the
image of \(\circuittomealyi\) does not always lead to minimal Mealy machines,
and there are many Mealy machines that may correspond to the same behaviour.
The `purest' semantics of a sequential circuit, and the one that we will as use
as the \emph{de facto} denotation, is a stream function in \(\streami\).

\begin{definition}
    Let \(\morph{\circuittostreami}{\scircsigma}{\streami}\) be defined as
    \(\mealytostreami \circ \circuittostreami\).
\end{definition}

We have now finally established the \emph{denotation} of a sequential circuit \(
\iltikzfig{strings/category/f}[box=f,colour=seq,dom=m,cod=n]
\): it is the stream function \(
\morph{\circuittostreami[\iltikzfig{strings/category/f}[box=f,colour=seq]]}{\valuetuplestream{m}}{\valuetuplestream{n}}
\).
The existence of the PROP morphism \(\circuittostreami\) confirms that causal,
finitely specified and monotone stream functions are a \emph{sound} denotational
semantics for sequential circuits, as every circuit in \(\scircsigma\) has a
corresponding stream function in \(\streami\).

It is useful to verify that this denotational semantics of sequential circuits
agrees with the denotational semantics we defined earlier for
\emph{combinational} circuits in \cref{sec:intepretating-components}.

\begin{lemma}\label{lem:sequential-combinational-semantics}
    Let \(\iltikzfig{strings/category/f}[box=f,colour=comb,dom=m,cod=n]\) be
    a combinational circuit; for \(\sigma \in \valuetuplestream{m}\) and
    \(i \in \nat\), \(
    \circuittostreami[\iltikzfig{strings/category/f}[box=f,colour=comb]](\sigma)(i)
    =
    \circuittofunci[\iltikzfig{strings/category/f}[box=f,colour=comb]](\sigma(i))
    \).
\end{lemma}
\begin{proof}
    Since \(\iltikzfig{strings/category/f}[box=f,colour=comb,dom=m,cod=n]\) is
    combinational, \(
    \circuittomealyi[
        \iltikzfig{strings/category/f}[box=f,colour=comb,dom=m,cod=n]
    ]
    \) is a Mealy machine with a single state \(s\), i.e.\ there is a function
    \(\morph{g}{\valuetuple{m}}{\valuetuple{n}}\) such that  \(
    \circuittomealyi[
        \iltikzfig{strings/category/f}[box=f,colour=comb,dom=m,cod=n]
    ] = (
    \{s\},
    (s, \listvar{v}) \mapsto \left\langle{s, g(\listvar{v})}\right\rangle,
    s
    )\).
    By definition of \(\mealytostreami\), we have that \(\mealytocircuiti[
        \circuittomealyi[
            \iltikzfig{strings/category/f}[box=f,colour=comb,dom=m,cod=n]
        ]
    ](\sigma)(i) = g(\sigma(i))\).

    To complete the proof, we need to show that \(
    g(\sigma)(i) =
    \circuittofunci[\iltikzfig{strings/category/f}[box=f,colour=comb]](\sigma(i))
    \); this holds because \(\circuittomealyi\) and \(\circuittofunci\) freely
    build functions using exactly the same constructs.
\end{proof}

\subsection{Monotone Mealy machines to circuits}

It is usually the case that soundness is easy while completeness is a bit more
fiddly, and who are we to interfere with tradition?
We now need a way to retrieve a circuit morphism from a stream
function \(f\).
Moreover, to prevent us from cheating and picking an arbitrary circuit, the
denotation of the circuit must also be \(f\).

We already know by \cref{cor:minimal-mealy} that given a stream function
\(f\) we can retrieve a monotone Mealy machine \(\streamtomealyi[f]\).
All that remains is to translate this into a circuit morphism.
For regular Mealy machines, there is a standard procedure in circuit
design~\cite{kohavi2009switching} in which each state of a Mealy machine is
\emph{encoded} as a power of values, and combinational logic used to transform
inputs into appropriate outputs.

\begin{example}
    Consider the following Mealy machine operating on Boolean values.
    \begin{center}
        \includestandalone{figures/mealy/boolean-example}
    \end{center}
    \vspace{-\belowdisplayskip}
    To convert this machine to a circuit, we assign each state a boolean value:
    in this case \(s_0 \mapsto \belnapfalse, s_1 \mapsto \belnaptrue\).
    We can now construct a truth table to show how a state and an input map to
    a transition and an output:
    \begin{center}
        \begin{tabular}{cc|cc}
            \(\belnapfalse\) & \(\belnapfalse\) & \(\belnaptrue\)  & \(\belnaptrue\)  \\
            \(\belnapfalse\) & \(\belnaptrue\)  & \(\belnapfalse\) & \(\belnapfalse\) \\
            \(\belnaptrue\)  & \(\belnapfalse\) & \(\belnaptrue\)  & \(\belnapfalse\) \\
            \(\belnaptrue\)  & \(\belnaptrue\)  & \(\belnapfalse\) & \(\belnaptrue\)  \\
        \end{tabular}
    \end{center}
    It is possible to describe these truth tables as logical expressions: in
    this case the expression for the next state is \(
    (v_0, v_1)
    \mapsto
    (\neg v_0 \land \neg v_1) \lor (v_0 \land \neg v_1)
    \) and the expression for the output is \(
    (v_0, v_1)
    \mapsto
    (\neg v_0 \land \neg v_1) \lor (v_0 \land v_1)
    \).
    These expressions can clearly be constructed as combinational circuits using
    \(\andgate\), \(\orgate\) and \(\notgate\) gates; the entire circuit
    corresponding to the Mealy machine is constructed by combining the
    combinational logic with registers to hold the state.
    \[\iltikzfig{mealy/synthesis}\]
\end{example}

We will use a variation of this procedure to map from \(\mealyi\) to
\(\scircsigma\).
However, when considering \emph{monotone} Mealy machines, this procedure must
additionally respect monotonicity as the combinational logic is constructed
using monotone components.
This means that an arbitrary encoding cannot be used; we will now show how to
select a suitable encoding.

\begin{definition}[Encoding]\label{def:encoding}
    Let \(S\) be a set equipped with a partial order \(\stateorder\) and a total
    order \(\leq\) such that \(s_0 \leq s_1 \leq \dots s_{k-1}\).
    The \emph{\(\leq\)-encoding} for this assignment is a function
    \(\morph{\gamma_\leq}{S}{\valuetuple{k}}\) defined as
    \(\gamma_\leq(s)(i) \coloneqq \top\) if \(s_i \stateorder s\) and
    \(\gamma_\leq(s)(i) \coloneqq \bot\) otherwise.
\end{definition}

\begin{example}
    Recall the monotone Mealy machine from \cref{ex:mealy-translation}, which
    has state set \(
    \belnapvalues \coloneqq \{\bot,\belnapfalse,\belnaptrue,\top\}
    \).
    We choose the total order on \(\belnapvalues\) as
    \(\bot \leq \belnapfalse \leq \belnaptrue \leq \top\); subsequently, the
    \(\leq\)-encoding is defined as \(
    \bot \mapsto \top\bot\bot\bot, \belnapfalse \mapsto \top\top\bot\bot,
    \belnaptrue \mapsto \top\bot\top\bot, \top \mapsto \top\top\top\top
    \).
\end{example}

It is essential that a \(\leq\)-encoding respects the original ordering of the
states.

\begin{lemma}
    For an ordered state space \((S,\stateorder)\) and a \(\leq\)-encoding
    \(\gamma_\leq\), \(s \stateorder s^\prime\) if and only if
    \(\gamma_\leq(s) \sqsubseteq \gamma_\leq(s^\prime)\).
\end{lemma}
\begin{proof}
    First the \(\onlyifdir\) direction.
    Let \(s_i \stateorder s_j\); we need to show that for every \(l < k\),
    \(s_i(l) \sqsubseteq s_j(l)\).
    The only way this can be violated is if \(s_i(l) = \top\) and
    \(s_j(l) = \bot\).
    But since \(s_i \stateorder s_j\), if \(s_l \stateorder s_i\) then
    \(s_l \stateorder s_j\) also holds.

    Now the \(\ifdir\) direction.
    Assume that \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\); we need to
    show that \(s_i \stateorder s_j\); i.e.\ that \(\gamma_\leq(s_j)(i) = \top\)
    If \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\), then for each
    \(l < k\) then \(\gamma_\leq(s_i)(l) \sqsubseteq \gamma_\leq(s_j)(l)\);
    in particular \(\gamma_\leq(s_i)(i) \sqsubseteq \gamma_\leq(s_j)(i)\)
    By definition of \(\gamma_\leq\), \(\gamma_\leq(s_i)(i) = \top\), so if
    \(\gamma_\leq(s_i) \sqsubseteq \gamma_\leq(s_j)\) then
    \(\gamma_\leq(s_j)(i)\) is also \(\top\).
\end{proof}

Using this encoding, we will construct a combinational circuit morphism that,
when interpreted as a function, implements the output and transition function
of the Mealy machine.
There is no reason for such a morphism to exist for an arbitrary interpretation:
why should we expect some collection of gates to be able to model every
function?
The useful interpretations are those that \emph{can} model every function.

\begin{definition}[Functional completeness]\label{def:functional-completeness}
    An interpretation \(\interpretation\) of a signature \(\signature\) is
    \emph{functionally complete} if there exists a map \(
    \morph{\mealytofunc}{\funci}{\scircsigma}
    \) which sends functions \(
    \morph{f}{\valuetuple{m}}{\valuetuple{n}}
    \), to circuits of the form \(
    \iltikzfig{circuits/synthesis/normalised-function}[box=f]
    \) for some word \(\listvar{v} \in \freemon{\values}\) such that
    \(\circuittostreami[\mealytofunc[f]](\sigma)(i) = f(\sigma(i))\).
\end{definition}

For a particular interpretation there may well be many such maps from functions
to circuits, but for convenience we will assume there is a fixed procedure
\(\mealytofunc\) amd refer to a circuit \(\mealytofunc[f]\) as the
\emph{normalised circuit for \(f\)}.\

\begin{remark}
    Even though \(\mealytofunc\) concerns combinational functions, it maps into
    the category of \emph{sequential} circuits \(\scircsigma\).
    This is because sometimes instantaneous values must be used to create the
    normalised circuit.
    However, the loop enforces that the state is \emph{constant}: it will always
    produce the word \(\listvar{v}\).
    This means the circuit has combinational behaviour despite using sequential
    components; often this is the only way to ensure every function can be
    modelled.

    Note also that this sequential component is by no means mandatory: the
    functional completeness map may actually map only to combinational circuits,
    in which case the width of the sequential component would be \(0\).
\end{remark}

\begin{example}
    The Belnap interpretation from \cref{ex:belnap-interpretation} is
    functionally complete; for interests of space we postpone the proof for
    \cref{sec:denotational-belnap}.
    This is due to a variation of the standard functional
    completeness method for Boolean values.
\end{example}

With the knowledge that any monotone function has a corresponding circuit
in \(\scircsigma\), we set about encoding the Mealy function.

\begin{definition}[Monotone completion]\label{def:monotone-completion}
    For lattices \(M, N, P\) such that \(M \subseteq N\), and a monotone
    function \(\morph{f}{M}{P}\), let the \emph{monotone completion} of \(f\) be
    the function \(\morph{f_\mathsf{m}}{N}{P}\) recursively defined as \[
        f_\mathsf{m}(v) = \begin{cases}
            f(v)
             &
            \text{if}\ v \in M
            \\
            \bot
             &
            \text{if}\ v = \bot^m, \bot \not\in M
            \\
            \bigsqcup \{ f_\mathsf{m}(w) \,|\, w \leq_N v \}
             &
            \text{otherwise}
        \end{cases}
    \]
\end{definition}

\begin{definition}[Monotone Mealy encoding]\label{def:mealy-encoding}
    For a monotone Mealy machine \((S, f, s_0)\) with \(k\) states and a
    monotone encoding \(\gamma_\leq\), a \emph{monotone Mealy encoding} is a
    function
    \(
    \morph{
        \gamma_\leq(f)
    }{
        \valuetuple{k} \times \valuetuple{m}
    }{
        \valuetuple{k} \times \valuetuple{n}
    }
    \) defined as the monotone completion of the function \(
    (\gamma_\leq(s), \listvar{x})
    \mapsto
    (
    \gamma_\leq(\mealyfunctiontransition{f}(s, \listvar{x})),
    \mealyfunctionoutput{f}(s, \listvar{x})
    )
    \).
\end{definition}

To be able to obtain the syntactic circuit for a monotone Mealy function encoded
in this way, it needs to be a morphism in \(\funci\).
It is monotone by definition, but we need to make sure it is also
\(\bot\)-preserving.

\begin{lemma}
    A monotone Mealy encoding is in \(\funci\).
\end{lemma}
\begin{proof}
    A Mealy encoding is monotone as it is a monotone completion.
    There cannot be a state encoded as \(\bot^k\), since at least one bit must
    be \(\top\); this means the monotone completion will send the input
    \(\bot^k\bot^m\) to \(\bot^k\bot^n\): it is
    \(\bot\)-preserving.
\end{proof}

The foundations are now set for establishing the image of a PROP morphism from
Mealy machines to circuit terms.
But before we get too ahead of ourselves, there is one more thing to consider:
\cref{def:encoding} depends on some arbitrary total ordering on the states in a
given monotone Mealy machine.
While this may not seem much of an issue, when
defining a PROP morphism this must be \emph{fixed}, otherwise the mapping of
Mealy machines to circuits might be nondeterministic.

\begin{definition}[Chosen state order]
    Let \((S, f, s_0)\) be a monotone Mealy machine with input space
    \(\valuetuple{m}\), and let \(\leq\) be a total order on \(\values\);
    \(\leq\) can be extended to \(\freemon{(\values^m)}\) using the
    lexicographic order.
    Given a state \(s\), let \(t_{s,\leq} \in \freemon{(\values^m)}\) be
    the minimal element of the subset of words that transition from \(s_0\) to
    \(s\), ordered by \(\leq\).
    Then the \emph{chosen state order} \(\leq_S\) is a total order on \(S\)
    defined as \(s \leq_S s^\prime\) if \(t_{s,\leq} \leq t_{s^\prime,\leq}\).
\end{definition}

The PROP morphism from monotone Mealy machines to circuits can then be
parameterised by some ordering on the set of values \(\values\), ensuring that
there is a canonical term in \(\scircsigma\) for each monotone Mealy machine.

\begin{definition}\label{def:mealy-to-circuit}
    For a functionally complete interpretation \(\interpretation\) and total
    order \(\leq\) on \(\values\), let \(
    \morph{
        \mealytocircuiti
    }{
        \mealyi
    }{
        \scircsigma
    }
    \) be the traced PROP morphism with action defined for a monotone Mealy
    machine \((S,f,s)\) as producing \(
    \iltikzfig{circuits/synthesis/mealy-term-spaced}
    \).
\end{definition}

Before proceeding to the result that this PROP morphism is behaviour-preserving,
we must show a lemma linking the behaviour circuits in the image of
\(\mealytocircuiti\) to initial outputs and stream derivatives.

\begin{proposition}
    \label{prop:mealy-form-image}
    For a combinational circuit \(
    \iltikzfig{strings/category/f-2-2}[box=f,dom1=x,dom2=m,cod1=x,cod2=n,colour=comb]
    \), let \(\mathsf{mf}(g)\) be the map with action \(
    (\listvar{s}) \mapsto
    \circuittostreami[
        \iltikzfig{circuits/productivity/mealy-form}[core=f,state=\listvar{s},dom=m,cod=n,delay=x]
    ]
    \) and let \(
    g
    :=
    \circuittofunci[
        \iltikzfig{strings/category/f-2-2}[box=f,colour=comb]
    ]
    \).
    Then, \(
    \mealyoutput{\mathsf{mf}(f)(\listvar{s})}{\listvar{a}}
    =
    \proj{1}(g(\listvar{s}, \listvar{a}))
    \) and \(
    \mealytransition{\mathsf{mf}(f)(\listvar{s})}{\listvar{a}}
    =
    \mathsf{mf}(f)(\proj{0}(g(\listvar{s}, \listvar{a})))
    \).
\end{proposition}
\begin{proof}
    The machine \(\circuittomealyi[
        \iltikzfig{circuits/productivity/mealy-form}[core=f,state=\listvar{s},dom=m,cod=n,delay=x]
    ]\) is the fixpoint of \(
    \left(\valuetuple{x},
    (\listvar{r}, \listvar{a}) \mapsto \left\langle
    \listvar{r}, g(\listvar{s}, \listvar{a})
    \right\rangle, \listvar{s}\right)
    \), which is \(
    \left(\valuetuple{x},
    \listvar{v} \mapsto \left\langle
    \proj{0}\left(g(\listvar{s},\listvar{a})\right),
    \proj{1}\left(g(\listvar{s}, \listvar{a})\right)
    \right\rangle, \listvar{s}\right)
    \).
    Since the initial output and the stream derivative of \(
    \mealytocircuiti[
        \circuittomealyi[
            \iltikzfig{circuits/productivity/mealy-form}[core=f,state=\listvar{s},dom=m,cod=n,delay=x]
        ]
    ]
    \) are the output and transition of the Mealy machine, the original
    statement holds by \cref{lem:sequential-combinational-semantics}.
\end{proof}

Now we can show the behaviour-preserving result.

\begin{theorem}\label{thm:mealy-to-circuit}
    \(
    \mealytostream = \circuittostreami \circ \mealytocircuiti
    \).
\end{theorem}
\begin{proof}
    Let \((S ,f)\) be monotone Mealy machine and let \(s \in S\) be an arbitrary
    state.
    By \cref{prop:mealy-to-stream}, the initial output of
    \(\mealytostreami[(S, f, s)]\) is
    \(\listvar{a} \mapsto \mealyfunctionoutput{f}\left(s, \listvar{a}\right)\)
    and the stream derivative of \(\mealytostreami[(S, f, s)]\) is \(
    \listvar{a}
    \mapsto
    \mealytostreami[(\mealyfunctiontransition{f}\left(s, \listvar{a}\right))]
    \).

    Now we consider the composite
    \(\circuittostreami[\mealytocircuiti[(S, f, s)]]\).
    By \cref{def:mealy-to-circuit} we have that \(
    \mealytocircuiti[(S, f, s_0)]
    =
    \iltikzfig{circuits/synthesis/mealy-term-spaced}
    \).
    By definition of \(\mealytocircuiti\) and \(\mealytofunc\),
    we have that\[
        \mealytocircuiti[(S, f, s_0)]
        =
        \iltikzfig{circuits/synthesis/mealy-term-spaced}
        =
        \iltikzfig{circuits/synthesis/mealy-term-comb-core}.
    \]
    Let \(
    g^\prime
    =
    \circuittofunci[\iltikzfig{strings/category/f-3-2}[box=g,colour=comb]]
    \); note that for all \(\listvar{r} \in \valuetuple{x}\) and
    \(\listvar{a} \in \valuetuple{m}\),
    \(g^\prime(\listvar{v}, \listvar{r}, \listvar{a})
    =
    \gamma_\leq(f)(\listvar{r},\listvar{a})
    \).

    We can now use \cref{prop:mealy-form-image} to compute the initial output
    and stream derivative of \(\circuittostreami[\mealytocircuiti[(S, f, s)]]\).
    To show that \(\mealytostreami = \circuittostreami \circ \mealytostreami\),
    we need to show that these `agree' with those of
    \(\mealytostreami[(S, f, s)]\).
    For the initial output, this means we just need to show they are equal:
    \begin{align*}
        \initialoutput{\circuittostreami[\mealytocircuiti[(S, f, s)]]}{\listvar{a}}
         & =
        \proj{1}\left(\circuittofunci[g](\listvar{v}, \gamma_\leq(s), \listvar{a})\right)
        \\
         & =
        \proj{1}\left(\circuittofunci[\mealytofunc[\gamma_\leq(f)]](\gamma_\leq(s), \listvar{a})\right)
        \\
         & =
        \proj{1}\left(\gamma_\leq(f)(\gamma_\leq(s), \listvar(a))\right)
        \\
         & =
        \proj{1}\left(
        \gamma_\leq(
            \mealyfunctiontransition{f}(s, \listvar{a})),
        \mealyfunctionoutput{f}(s, \listvar{a})\right)
        \\
         & =
        \mealyfunctionoutput{f}(s, \listvar{a})
    \end{align*}
    For the stream derivative, we need to show that as states vary over
    \(s \in S\), the stream derivative of \(
    \circuittostreami[\mealytocircuiti[(S, f, s)]]
    \) is the \(\gamma_\leq\)-encoding of \(\mealytostreami[(S, f, s)]\).
    \begin{align*}
        \streamderivative{\left(\circuittostreami[\mealytocircuiti[(S, f, s)]]\right)}{\listvar{a}}
         & =
        \proj{0}\left(
        \circuittofunci[g](\listvar{v}, \gamma_\leq(s), \listvar{a})
        \right)
        \\
         & =
        \proj{0}\left(\circuittofunci[\mealytofunc[\gamma_\leq(f)]](\gamma_\leq(s), \listvar{a})\right)
        \\
         & =
        \proj{0}\left(\gamma_\leq(f)(\gamma_\leq(s), \listvar(a))\right)
        \\
         & =
        \proj{0}\left(
        \gamma_\leq(
            \mealyfunctiontransition{f}(s, \listvar{a})),
        \mealyfunctionoutput{f}(s, \listvar{a})\right)
        \\
         & =
        \gamma_\leq(
        \mealyfunctiontransition{f}(s, \listvar{a}))
    \end{align*}
    The initial outputs and stream derivatives agree, so
    \(\mealytostream = \circuittostreami \circ \mealytocircuiti\).
\end{proof}

This brings our foray into Mealy machines to a close: we can translate back and
forth between circuits and \emph{monotone} Mealy machines without fear of
altering their behaviour in terms of their stream functions.

This already is quite nice to have; if we only know the specification of a
circuit in terms of a (monotone) Mealy machine, we can use the PROP morphism
\(\mealytocircuiti\) to generate a circuit in \(\scircsigma\).
But we have loftier ambitions: using what we have defined in this section we
will now show the completeness of the denotational semantics.
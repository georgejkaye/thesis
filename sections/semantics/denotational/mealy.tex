\section{Monotone Mealy machines}

While it would not be too difficult to define a map from circuits in
\(\scircsigma\) to stream functions in \(\streami\), it is not immediately
obvious how to translate back from stream functions in \(\streami\) to circuits
in \(\scircsigma\).
Even though these stream functions have finitely many stream derivatives, how
does one encapsulate this behaviour into a circuit made from finitely many
components while taking into account inputs and state?
Fortunately, we have a secret weapon: the
\emph{Mealy machine}~\cite{mealy1955method}.

Working tirelessly in industry as a way of specifying the behaviour of a
circuit without restricting to particular circuitry, Mealy machines also have
a very useful \emph{coalgebraic} viewpoint which we will wield in order to
build a bridge from circuits into stream functions: there is a unique
homomorphism from a Mealy machine to a causal, finitely specified stream
function.

Our strategy is to assemble a special class of Mealy machines which we dub
\emph{monotone Mealy machines} into another traced PROP.
As well as helping us on our way to our end goal of a sound and complete
denotational semantics, having a PROP of Mealy machines from which we can
translate into sequential circuit morphisms is nice to have in its own right.

\begin{definition}[Mealy machine~\cite{mealy1955method}]\label{def:mealy}
    Let \(A\) and \(B\) be finite sets.
    A (finite) \((A,B)\)-\emph{Mealy machine} is a tuple \((S, f)\) where
    \(S\) is a finite set called the \emph{state space},
    \(\morph{f}{S}{(S \times B)^A}\) is the \emph{Mealy function}.
\end{definition}

An \((M,N\)-Mealy machine is parameterised over a set \(A\) of \emph{inputs} and
a set \(B\) of \emph{outputs}.
Each Mealy machine then has a set \(S\) of \emph{states}; the Mealy function
takes in a currrent state and input \((s, a)\) and produces a pair
\(\langle{s^\prime, b}\rangle\) of a transition and output.

\begin{notation}
    We will use the shorthand \(
    \mealyfunctiontransition{f} \coloneqq (s, a) \mapsto \proj{0}(f(s)(a))
    \) and \(
    \mealyfunctionoutput{f} \coloneqq (s, a) \mapsto \proj{1}(f(s)(a))
    \) for the transition and output component of the Mealy function respectively.
\end{notation}

\begin{example}
    Let the set of Booleans be defined as \(\booleans \coloneqq \{0,1\}\).
    We define a \((\booleans,\booleans)\)-Mealy machine \((S, f)\) as follows:
    \begin{gather*}
        S \coloneqq \{s_0, s_1\}
        \\
        f(s_0, \mathsf{t}) \mapsto \langle{s_1, \mathsf{t}}\rangle
        \quad
        f(s_0, \mathsf{f}) \mapsto \langle{s_0, \mathsf{f}}\rangle
        \\
        f(s_1, \mathsf{t}) \mapsto \langle{s_1, \mathsf{f}}\rangle
        \quad
        f(s_0, \mathsf{f}) \mapsto \langle{s_0, \mathsf{t}}\rangle
    \end{gather*}
    This is a Mealy machine with two states; at state \(s_0\) the output is just
    the input, and at state \(s_1\) the output is the negation.
    At either state, if a \(\mathsf{t}\) is input the state switches.

    It is often more intuitive to draw out a Mealy machine.
    We draw states as circles; if there is a transition from one state to
    another on input \(v\) that produces output \(w\), we draw an arrow between
    them labelled with \(v|w\).
    \begin{center}
        \includestandalone{figures/mealy/example}
    \end{center}
\end{example}

\subsection{The coalgebraic perspective}

The definition of Mealy machine above is timeless and forms the basis for most
of modern electronics.
The natural question for the categorist to ask is
\emph{can we make it more categorical?}
And as is often the case, we can, using the notion of a \emph{coalgebra}.

\begin{definition}[Coalgebra]
    Let \(\mcc\) and \(\mcd\) be categories, and let \(\morph{F}{\mcc}{\mcc}\)
    be an endofunctor.
    A \emph{coalgebra} for \(F\), or \(F\)-coalgebra, is an object
    \(A \in \mcc\) along with a morphism \(\morph{\alpha}{A}{FA} \in \mcc\),
    usually written \((A,\alpha)\).
\end{definition}

A Mealy machine is a pair of a set
and a function, so this is a coalgebra in \(\set\).

\begin{definition}
    For sets \(A\) and \(B\), an \emph{\((A,B)\)-Mealy coalgebra} is a coalgebra
    of the functor \(\morph{Y}{\set}{\set}\), defined as
    \(S \mapsto (S \times B)^A\).
\end{definition}

\begin{example}
    In \cite{bonsangue2008coalgebraic}, the notation \(
    f(s)(a) = \langle{\initialoutput{s}{a},\streamderivative{s}{a}}\rangle
    \) is used to describe the Mealy function, which coincides with the notation
    used for stream functions; this is not a coincidence!

    Given sets \(A\) and \(B\), let \(\Gamma\) be the set of causal stream
    functions \(\stream{A} \to \stream{B}\), and let
    \(\morph{\nu}{\Gamma}{\Gamma \times B}^A\) be the function defined as \(
    (f, a) \mapsto \langle{\initialoutput{s}{a},\streamderivative{s}{a}}\rangle
    \).
    Then \((\Gamma,\nu)\) is a \((A,B)\)-Mealy coalgebra.
\end{example}

The above example is incredibly important, as it lays the groundwork we will
use extensively to establish connections between circuits, stream functions and
Mealy machines.
If we inspect it a little closer, we find that stream functions are even more
special than just being `a' \((A,B)\)-Mealy coalgebra.

\begin{definition}[Mealy homomorphism]\label{def:mealy-homomorphism}
    For sets \(A\) and \(B\), an \emph{Mealy homomorphism} between two
    \((A,B)\)-Mealy coalgebra \((S,f)\) and \((T,g)\) is a function
    \(\morph{h}{S}{T}\) preserving transitions and
    outputs, i.e.\ if \(f(s,a) = (r,b)\), then \(g(h(s),a) = (h(r),b)\).
\end{definition}

The \emph{final} \((M,N)\)-Mealy coalgebra is a \((M,N)\)-Mealy coalgebra to
which every other \((M,N)\)-Mealy coalgebra has a unique homomorphism to.

\begin{remark}
    The coalgebra crowd tend to prefer the use of the word \emph{final} over
    \emph{terminal}; one could quite reasonably call the final coalgebra a
    terminal coalgebra and everything would be alright, but you might get a few
    funny looks.
\end{remark}

\begin{proposition}[\cite{rutten2006algebraic}, Prop. 2.2]
    \label{prop:final-coalgebra}
    For every \((A,B)\)-Mealy coalgebra \((S,f)\), there exists a
    unique \((A,B)\)-Mealy homomorphism \(\morph{{!}}{(S,f)}{(\Gamma,\nu)}\).
\end{proposition}
\begin{proof}
    An \((A,B)\)-Mealy homomorphism \(\morph{g}{(S, f)}{(\Gamma, \nu)}\) is a
    function \(S \to \Gamma\), so for a state \(s_0 \in S\), \(g(s)\) will be a
    stream function \(\stream{A} \to \stream{B}\).
    Let \(\sigma \in \stream{A}\) be an input stream; there is a (unique) series
    of transitions \[
        s_0
        \mealyarrow{\sigma(0)}{b_0}
        s_1
        \mealyarrow{\sigma(1)}{b_1}
        s_2
        \mealyarrow{\sigma(2)}{b_2}
        s_3
        \mealyarrow{\sigma(3)}{b_3}
        \cdots
    \]
    Then \(!(s)\) is defined for input \(\sigma\) and
    index \(i \in \nat\) as \(!(s)(\sigma)(i) \coloneqq b_i\).
\end{proof}

For a Mealy coalgebra \((S, f)\) and a start state \(s_0\),
\(!(s)(\sigma)\) maps to the stream of outputs that \((S, f)\) would produce
by applying \(f\) to each element of \(\sigma\), starting from \(s_0\).

When viewed through this perspective, stream functions are nothing more than the
states in another Mealy machine.
However, this is not just any Mealy machine, it is the \emph{minimal} Mealy
machine with the same behaviour as \((S, f)\).

\subsection{Monotone Mealy machines}

The fact that causal stream functions are the final Mealy coalgebra is the
ingredient that will help us build a bridge between circuits in \(\scircsigma\)
and stream functions in \(\streami\).
The crucial step is to now assemble Mealy machines into another traced PROP
and define PROP morphisms between all three categories in play.

However, not all Mealy machines defined thus far correspond to circuits in
\(\scircsigma\).
As with stream functions, we must refine our notion of Mealy machine in
order to find those that do.
There is an easy check for this: a Mealy machine \((S, f)\) with start state
\(s_0\) specifies the behaviour of a circuit in \(\scircsigma\) if the
stream function \(!(s_0)\) is in \(\streami\).

As established, all stream functions in the image of \(!\) are causal, and since
we only work with \emph{finite} Mealy machines we can also conclude the
following:

\begin{lemma}
    For a Mealy machine \((S, f)\) and start state \(s_0 \in S\), \(!(s_0)\)
    is finitely specified.
\end{lemma}
\begin{proof}
    \(S\) is finite, and \(\mealytostream\) must preserve transitions.
\end{proof}

Monotonicity is a little less straightforward.
One could set the input, output and state sets to all be posets, and use the
usual definition of monotonicity that way.
However, this overcomplicates things: since each Mealy coalgebra has a
corresponding stream function, we can appeal to this rather than having to
manually order the state set.

First an ordering on stream \emph{functions} is required.

\begin{definition}
    Let \(A\) and \(B\) be posets.
    For stream functions \(\morph{f,g}{\stream{A}}{\stream{B}}\), we say that
    \(f \stateorder g\) if, for all \(\sigma \in \stream{A}\),
    \(f(\sigma) \leq_{\stream{B}} g(\sigma)\).
\end{definition}

\begin{definition}[State order]
    Let \(A\) and \(B\) posets.
    For an \((A,B)\)-Mealy machine \((S, f)\) and states \(s,s^\prime \in S\)
    we say that \(s \stateorder s^\prime\) if \(!(s) \stateorder !(s^\prime)\).
\end{definition}

With an ordering on the states of a Mealy machine, monotonicity quickly follows.

\begin{definition}[Monotone Mealy machine]
    Let \(A\) and \(B\) be posets; an \((A,B)\)-Mealy machine is called a
    \emph{monotone} Mealy machine if \(f\) is monotone with respect to the
    appropriate orders.
\end{definition}

This establishes the properties of Mealy machines required to model circuits.
To map to Mealy machines from circuits we need to assemble them into another
PROP, in which the morphisms \(m \to n\) are
\((\valuetuple{m},\valuetuple{n})\)-Mealy machines.
There is one nuance to consider: circuits in \(\scircsigma\) have a `hardcoded'
initial state in the form of the value generators, whereas the Mealy machines
as presented do not have a designated start state per se.
This means that as well as a Mealy machine, each morphism will need to be
equipped with such a start state.

\begin{definition}[Initialised Mealy machine]
    An \emph{initialised} Mealy machine is a tuple \((S, f, s_0)\), where
    \((S, f)\) is a Mealy machine, and \(s_0 \in S\) is an \emph{initial state}.
\end{definition}

All that remains to define is the composition of Mealy machines, which is
standard.

\begin{definition}[Cascade product of Mealy machines~\cite{ginzburg2014algebraic}]
    Given an initialised \((A,B)\)-Mealy machine \((S,f,s_0)\) and an
    initialised \((B,C)\)-Mealy machine \((T,g,t_0)\), their
    \emph{cascade product} is an initialised \((A,C)\)-Mealy machine defined as
    \[
        \left(S \times T, ((s, t), a) \mapsto \left(
        \mealyfunctiontransition{f}(s,a),
        \mealyfunctiontransition{g}(t, \mealyfunctionoutput{f}(s, a))
        \right),
        \mealyfunctionoutput{g}(t, \mealyfunctionoutput{f}(s, a)),
        (s_0, t_0)\right).
    \]
\end{definition}

The cascade product of two Mealy machines effectively executes the first on the
inputs, then executes the second on the outputs of the first; the inputs are
`cascaded' through the two Mealy machines.

\begin{example}
    \todo[inline]{Example!}
\end{example}

Tensor product is far more straightforward.

\begin{definition}[Direct product of Mealy machines]
    Given an initialised \((A,B)\)-Mealy machine \((S,f,s_0)\) and an
    initialised \((C,D)\)-Mealy machine \((T,g,t_0)\), their
    \emph{direct product} is an initialised \((A \times C,B \times D)\)-Mealy
    machine defined as \[
        (S \times T, \left((s, t), (a, c)\right) \mapsto \left\langle
        \left(
        \mealyfunctiontransition{f}\left(s, a\right),
        \mealyfunctiontransition{f}\left(s, a\right)
        \right),
        \left(
        \mealyfunctionoutput{f}\left(s, a\right),
        \mealyfunctionoutput{f}\left(s, a\right)
        \right)\right\rangle,
        (s_0, t_0)
        ).
    \]
\end{definition}

\begin{definition}
    Let \(\mealyi\) be the PROP in which the morphisms
    \(m \to n\) are the initialised monotone
    \((\valuetuple{m}, \valuetuple{n})\)-Mealy machines.
    Composition is by cascade product and tensor on morphisms is by
    direct product.
    The identity and the symmetry are the single-state machines that output the
    input and swap the inputs respectively.
\end{definition}

Once again, we must show that this category has a trace.
This can be computed in much the same way as it was for stream functions.

\begin{definition}
    Let \((S, f)\) be a monotone \(
    (\valuetuple{x+m}, \valuetuple{x+n})
    \)-Mealy machine.
    For a state \(s \in S\) and input \(\listvar{a} \in m\), let
    \(\mu_{s,\listvar{a}}\) be the least fixpoint of \(
    \listvar{r} \mapsto \proj{0}\left(f\left(s, \listvar{ra}\right)\right)
    \).
    The \emph{least fixed point} of \((S, f)\) with start state \(s_0\) is a \(
    (\valuetuple{m}, \valuetuple{n})
    \)-Mealy machine \(
    (S, (s, \listvar{a}) \mapsto f((\mu_{s,\listvar{a}})\listvar{a}))
    \) with start state \(s_0\).
\end{definition}

\begin{proposition}
    The least fixed point is a trace on \(\mealyi\).
\end{proposition}
\begin{proof}
    Let \((S, f)\) be a monotone
    \((\valuetuple{x+m}, \valuetuple{x+n})\)-Mealy machine.
    The Mealy function \(
    \morph{f}{
        S \times \valuetuple{x+m}
    }{
        S \times \valuetuple{x+n}
    }
    \) is monotone with regards to the orders on \(S\) and
    \(\valuetuple{x+m}\) and \(S \times x+n\) is finite, so
    \(f\) has a fixed point.
    The function \(
    f^\prime \coloneqq (s, \listvar{a})
    \mapsto
    \proj{1}\left(f((\mu_{s,\listvar{a}})\listvar{a})\right)
    \) is a composition of monotone functions, so it is itself monotone.
    This means \((S, f^\prime)\) is a monotone \(
    (\valuetuple{m}, \valuetuple{n})
    \)-Mealy machine.
    This construction is a trace for the same reason as the trace of
    \(\streami\) is.
\end{proof}

\begin{example}\label{ex:trace-mealy}
    Consider the monotone \((\valuetuple{3},\valuetuple{3})\)-Mealy machine with
    state set \(\belnapvalues\), initial state \(\bot\), and Mealy function \[
        g \coloneqq (s, (x, y, z))
        \mapsto \left\langle \neg y \land \neg x,
        \left(\neg s \land \neg z, s, \neg s \land \neg z\right)
        \right\rangle
        ).\]
    To take the trace of this machine, we must first compute the least fixed
    point of \(v \mapsto \neg s \land \neg z\), which is clearly just
    \(\neg s \land \neg z\).
    Therefore the Mealy function of the traced
    \((\valuetuple{2}, \valuetuple{2})\) machine is \(
    (s, (y, z)) \mapsto g(s, (\neg s \land \neg z, y, \neg s \land \neg z))
    \).
\end{example}

\input{sections/semantics/denotational/floats/latch-machine}

With monotone Mealy machines in a PROP, we can now represent the unique
homomorphism from a Mealy machine to a set of state functions as a PROP
morphism.

\begin{proposition}\label{prop:mealy-to-stream}
    There is a traced PROP morphism
    \(\morph{\mealytostreami}{\mealyi}{\streami}\) sending a monotone Mealy
    machine \(\morph{\left(S, f, s_0\right)}{m}{n}\) to \(!(s_0)\), where \(!\)
    is the unique homomorphism \((S,f) \to (\Gamma,\nu)\).
\end{proposition}
\begin{proof}
    Since every stream function also has a Mealy coalgebra structure and Mealy
    homomorphisms preserve transitions and outputs,
    composition of Mealy machines also coincides with composition of stream
    functions.
\end{proof}

\subsection{Streams to Mealy machines}

As a causal stream function \(\morph{f}{\stream{A}}{\stream{B}}\) is just a
\((A,B)\)-Mealy machine, when such a function has finitely many stream
derivatives it is easy to retrieve a finite Mealy machine by repeatedly
taking stream derivatives to compute the state set.

\begin{example}
    Let \(\morph{f}{\belnapvalues}{\belnapvalues}\) be a stream function defined
    as \(f(\sigma)(0) = \sigma(0)\) and
    \(f(\sigma)(k+1) = f(\sigma)(k) \land \sigma(k+1)\).
    We will derive a Mealy machine in \(\mealyi\) from this stream function.
    The set of states is \(\{
    f, \streamderivative{f}{\bot}, \streamderivative{f}{\belnapfalse},
    \streamderivative{f}{\top}
    \}\): this completely specifies the Mealy machine because
    \begin{itemize}
        \item \(\streamderivative{f}{\belnaptrue} = f\);
        \item \(\streamderivative{(\streamderivative{f}{\bot})}{\bot}
              =
              \streamderivative{(\streamderivative{f}{\bot})}{\belnaptrue}
              =
              \streamderivative{f}{\bot}
              \);
        \item \(\streamderivative{(\streamderivative{f}{\top})}{\top}
              =
              \streamderivative{(\streamderivative{f}{\top})}{\belnaptrue}
              =
              \streamderivative{f}{\top}
              \); and
        \item \(
              \streamderivative{(\streamderivative{f}{\bot})}{\belnapfalse}
              =
              \streamderivative{(\streamderivative{f}{\bot})}{\top}
              =
              \streamderivative{(\streamderivative{f}{\top})}{\bot}
              =
              \streamderivative{(\streamderivative{f}{\top})}{\belnapfalse}
              =
              \streamderivative{f}{\belnapfalse}
              \).
    \end{itemize}
    The Mealy function is defined for each state as the initial value and
    stream derivative of the original stream function.
    The initial state of the Mealy machine is \(f\).
\end{example}

\todo[inline]{Is the latch simple enough for this?}

In fact, for a function \(f\) this procedure produces a \emph{minimal} Mealy
machine.

\begin{corollary}[Corollary 2.3, \cite{rutten2006algebraic}]\label{cor:minimal-mealy}
    For a causal, finitely specified, stream function \(
    \morph{f}{\stream{M}}{\stream{N}}
    \), let \(S\) be the least set of
    causal stream functions including \(f\) and closed under stream derivatives:
    i.e.\ for all \(h \in S\) and \(a \in M\), \(h_a \in S\).
    Then the initialised Mealy machine \(
    \streamtomealy[f]{\interpretation} = (S, g, f)
    \), where \(
    g(h)(a) = \langle \mealyoutput{h}{a}, \mealytransition{h}{a}\rangle
    \), has the smallest state space of Mealy machines with the property \(
    \mealytostreami[\streamtomealyi[f]] = f
    \).
\end{corollary}
\begin{proof}
    Since \(S\) is generated from the function \(f\) and is the \emph{smallest}
    possible set, there are no unreachable states in \(S\).
    Since the output and transition of states in
    \(\streamtomealyi[f]\) is just initial output and stream derivative, this
    means these two states can only have the same `behaviour' if they are
    derived from the same original stream function.
\end{proof}

We will encode this data into a PROP morphism from \(\streami\) to \(\mealyi\);
in order to this we must quickly verify the produced Mealy machine is monotone.

\begin{lemma}\label{lem:head-tail-monotone}
    The functions \(\sigma \mapsto \streaminit(\sigma)\) and
    \(\sigma \mapsto \streamderv(\sigma)\) are monotone.
\end{lemma}
\begin{proof}
    Let \(\sigma \coloneqq a \streamcons \sigma^\prime\) and
    \(\tau \coloneqq b \streamcons \tau^\prime\) be streams in \(\stream{A}\)
    such that \(\sigma \leq_{\stream{A}} \tau\); subsequently \(a \leq b\) and
    \(\sigma^\prime \leq_{\stream{A}} \tau^\prime\).
    So \(
    \streaminit(\sigma) \coloneqq
    \streaminit(a \streamcons \sigma^\prime) =
    a \leq_{A}
    b =
    \streaminit(b \streamcons \tau^\prime) \coloneqq
    \streaminit(\tau)
    \) and \(
    \streamderv(\sigma) \coloneqq
    \streamderv(a \streamcons \sigma^\prime) =
    \sigma^\prime \leq_{\stream{A}}
    \tau^\prime =
    \streamderv(b \streamcons \tau^\prime) =
    \streamderv(\tau)
    \).
\end{proof}

\begin{lemma}\label{lem:initial-derivative-monotone}
    For posets \(A\) and \(B\) and a monotone causal stream function
    \(\morph{f}{\stream{A}}{\stream{B}}\), the functions
    \(a \mapsto \initialoutput{f}{a}\) and \(a \mapsto \streamderivative{f}{a}\)
    are monotone.
\end{lemma}
\begin{proof}
    Let \(a, b \in A\) such that \(a \leq_A b\); then by monotonicity
    \(f(a \streamcons \sigma) \leq_{\stream{B}} f(b \streamcons \sigma)\) for
    all \(\sigma \in \stream{A}\).
    By \cref{lem:head-tail-monotone}, \(\streaminit \circ f\) and
    \(\streamderv \circ f\) are monotone.
    First we show that the initial output is monotone: \(
    \initialoutput{f}{a} \coloneqq
    \streaminit(f(a \streamcons \sigma)) \leq_{A}
    \streaminit(f(b \streamcons \sigma)) =
    \initialoutput{f}{b}
    \).
    For stream derivative, \(
    \streamderivative{f}{a}(\sigma) \coloneqq
    \streamderv(f(a \streamcons \sigma)) \leq_{\stream{B}}
    \streamderv(f(b \streamcons \sigma)) \coloneqq
    \streamderivative{f}{a}(\sigma)
    \).
\end{proof}

\begin{lemma}\label{lem:stream-to-mealy-is-monotone}
    Given a stream function \(f \in \streami\), \(\streamtomealyi[f]\) is
    a monotone Mealy machine.
\end{lemma}
\begin{proof}
    Each state in the derived Mealy machine is a monotone stream function and
    the Mealy function is the pairing of the initial output and stream
    derivative; by \cref{lem:initial-derivative-monotone} these are monotone so
    the Mealy function must also be monotone.
\end{proof}

\begin{corollary}
    The procedure \(\streamtomealyi\) is a PROP morphism
    \(\streami \to \mealyi\).
\end{corollary}

This means we can map between monotone Mealy machines and causal, finitely
specified and monotone stream functions in either direction.
Mealy machines are perhaps more intuitive to work with, but stream functions
are the `purest' specification of the behaviour in that they have the smallest
possible state set.
Ideally we would be able to work in whichever setting is most beneficial at a
given time, so we need to show that the translations are
\emph{behaviour-preserving}.

\begin{proposition}\label{prop:mealy-to-stream}
    \(\mealytostreami \circ \streamtomealyi = \id[\streami]\).
\end{proposition}
\begin{proof}
    Stream functions are equal if they have the same initial output and
    stream derivative.
    \(\streamtomealyi\) preserves outputs and derivatives by definition, and
    \(\mealytostreami\) preserves transitions and outputs because it is a Mealy
    homomorphism.
\end{proof}

The reverse does not hold as many Mealy machines may map to the same stream
function, but the result of
\(\mealytostreami \circ \streamtomealyi \circ \mealytostreami\) is of course
equal to \(\mealytostreami\).
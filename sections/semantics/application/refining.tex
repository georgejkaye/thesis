\section{Refining circuits}\label{sec:refining}

A key part of circuit design comes in \emph{optimising circuits}: making them
run as fast as possible and reduce the \emph{clock cycle}.

\begin{example}[Retiming]
    The clock cycle of a circuit is determined by the longest paths between
    registers. Altering the paths between registers can be achieved using
    \emph{retiming}~\cite{leiserson1991retiming}: moving registers across gates.
    This is modelled by the streaming rule (\cref{lem:streaming});
    forward retiming (streaming left to right) is always possible
    but for backward retiming (streaming right to left), the value
    in the register must be in the image of the gates.
\end{example}

When reasoning equationally, the behaviour of the circuits on either side of the
equation must have exactly the same behaviour.
However, when reasoning with circuits it is sometimes the case that this is too
strict an assertion; we are looking for circuits that output the same outputs
but over a shorter period of time.
This means we may wish to use transformations that only `morally' preserve the
behaviour of a circuit.

\begin{definition}
    For two finite sequences \(
    \listlistvar{v},\listlistvar{w} \in (\valuetuple{m})^k
    \), we say that \(\listlistvar{w}\) is a \emph{stretching} of
    \(\listlistvar{v}\), written \(\listlistvar{v} \ll \listlistvar{w}\), if
    \(\listlistvar{w}\) contains the characters of \(\listlistvar{v}\) but
    possibly repeated or with additional \(\bot\) characters e.g.\ \(
    \belnaptrue\belnapfalse
    \ll
    \bot\bot\belnaptrue\belnaptrue\bot\belnapfalse
    \).
\end{definition}

\begin{definition}
    Given two sequential circuits \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=m,cod=n]
    \) and \(
    \iltikzfig{strings/category/f}[box=g,colour=seq,dom=m,cod=n]
    \) with \(c\) and \(c^\prime\) delay components respectively, we say that \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=m,cod=n]
    \) is \emph{logically equvialent} to \(
    \iltikzfig{strings/category/f}[box=g,colour=seq,dom=m,cod=n]
    \), written \(
    \iltikzfig{strings/category/f}[box=f,colour=seq,dom=m,cod=n]
    \ll
    \iltikzfig{strings/category/f}[box=g,colour=seq,dom=m,cod=n]
    \), if for all sequences \(\listlistvar{v},\listlistvar{w}\) produced by the
    productive operational semantics for inputs of length
    \(\mathsf{max}(c,c^\prime)\),  \(\listlistvar{v} \ll \listlistvar{w}\)
\end{definition}

Including this notion of equivalence in algebraic reasoning allows us to reason
with \emph{inequalities} as well as equalities.
This means that given a circuit, we can use equations as normal, determine that
one component

\begin{example}
    Take the circuit \(
    \iltikzfig{circuits/examples/refinement/circuit}
    \).
    For an input stream \(\sigma\), this circuit produces output stream
    \(
    \bot \land \sigma(0) \streamcons \sigma(1)
    \streamcons \sigma(2) \streamcons \dots
    \).
    By using equalities and logical eqivalence we can obtain a much simpler
    circuit:
    \[
        \iltikzfig{circuits/examples/refinement/circuit}
        =
        \iltikzfig{circuits/examples/refinement/circuit-1}
        \ll
        \iltikzfig{circuits/examples/refinement/circuit-2}
        =
        \iltikzfig{circuits/examples/refinement/circuit-3}
    \]
\end{example}

While this is a somewhat contrived toy example, it is possible that this
technique could be applied to actual circuit optimisation procedures.

\begin{example}[Pipelining]
    \emph{Pipelining}~\cite{parhi1999vlsi} is a technique in which more
    registers are inserted into a circuit to increase throughput.
    This can be emulated in the compositional framework by applying
    transformations locally to registers.
    Ordinarily, such transformations can obfuscate a circuit's behaviour since
    the state space dramatically changes.
    In the compositional model, the structure of the circuit is left relatively
    untouched so this is less of an issue.
\end{example}

Not all circuit transformations are for the purpose of improving performance.
Sometimes additional components must be bolted onto a circuit for \emph{testing}
purposes.

\begin{example}[Scan chains]
    A common way of testing circuits is by using a
    \emph{scan chain}~\cite{mourad2000principles}, a way of forcing the
    inputs to flipflops to test how specific states affect the outputs of the
    circuit.
    Adding a flipflop to a scan chain requires some extra inputs: the
    \(\mathsf{scan}_\mathsf{en}\) wire toggles if the flipflop operates in
    normal mode or if it takes \(\mathsf{scan}_\mathsf{in}\) as its value.
    \[
        \iltikzfig{circuits/examples/scan-chain/flipflop-before-chain}
        \xRightarrow{\text{scan}}
        \iltikzfig{circuits/examples/scan-chain/scan-chain}
    \]
\end{example}

One could factor in these transformations when designing the circuit, but this
can obfuscate the design of the actual logic.
Additionally, applying these transformations where the remaining part of the
circuit is \emph{not} combinational can be quite complex.
With the compositional approach the two tasks can be kept isolated by using
blackboxes, layered explanations, and graphical reasoning.
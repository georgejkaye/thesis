\section{Terms}

Processes are modelled as \emph{terms}.
Before we can begin, the components that make up processes in a given system
must be specified.

\begin{definition}[Generators]
    A set of \emph{generators} \(\generators\) is a set equipped with two
    functions \(\morph{\dom,\cod}{\generators}{\nat}\).
\end{definition}

Generators are the primitive building blocks of terms: their domains and
codomains specify how many input and output wires they have respectively.
Terms are defined by combining these primitives together.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of generators.
    A \(\generators\)-term is written \(\morph{f}{m}{n}\)
    where \(m,n \in \nat\).
    The set of \(\generators\)-terms, denoted \(\sigmaterms\), is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\dom[\phi]}{\cod[\phi]} \in \sigmaterms
                \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[1]}{1}{1} \in \sigmaterms\)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(\morph{\id[0]}{0}{0} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(
                \morph{\swap{1}{1}}{2}{2} \in \sigmaterms
                \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{m}{n} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{n}{p} \in \sigmaterms\)}
            \BinaryInfC{\(\morph{f \seq g}{m}{p} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{m}{p} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{p}{q} \in \sigmaterms\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{m+p}{n+q} \in \sigmaterms
                \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms are constructed recursively.
There are four base cases: a generator from \(\generators\) with appropriate
inputs and outputs; an \emph{identity} for single wires and empty space, and
a \emph{symmetry} for swapping over two wires.
The two inductive cases are called \emph{composition} and \emph{tensor}
respectively.
Intuitively, these can be thought of generating larger terms by sequencing
subterms in sequence or parallel.

Although here identities and symmetries only operate on single wires, it is
a simple exercise to define them for larger numbers of wires.

\begin{notation}[Composite identities]\label{not:composite-identities}
    Composite identities \(\id[n]\) are defined inductively for \(n \in \nat\)
    as \(
    \id[0] \coloneqq \id[0]\) and \(
    \id[k+1]
    \coloneqq
    \id[k] \tensor \id[1]
    \)
\end{notation}
\begin{notation}[Composite symmetries]\label{not:composite-symmetries}
    Composite symmetries \(\swap{m}{n}\) for \(m, n \in \nat\) are defined
    inductively as \(
    \swap{0}{n}
    \coloneqq
    \id[n]
    \), \(
    \swap{m}{0}
    \coloneqq \id[m]
    \), and \(
    \swap{k+1}{l+1}
    \coloneqq
    \id[k] \tensor \swap{1}{l} \tensor \id[1]
    \seq
    \swap{k}{l} \tensor \swap{1}{1}
    \seq
    \id[l] \tensor \swap{k}{1} \tensor \id[1]
    \).
\end{notation}

\(\Sigma\)-terms will be abbreviated to `terms' when the signature is clear from
context.

\begin{example}
    \todo[inline]{Think of a funky example}
\end{example}

\section{String diagrams}

It is clear that even simple terms described using one-dimensional text
strings quickly become indecipherable.
Fortunately, terms have an intuitive \emph{graphical} syntax known as
\emph{string diagrams} that can shed much light on what is actually going on.
In a string diagram, a generator \(\morph{\phi}{m}{n}\) is drawn as a box with
\(m\) inputs and \(n\) outputs \(
\iltikzfig{strings/category/generator-wires-tile}[dom=m,cod=n]
\), the identity \(\id[1]\) as a wire \(
\iltikzfig{strings/category/identity-tile}
\), the empty identity \(\id[0]\) as empty space \(
\iltikzfig{strings/monoidal/empty-tile}
\), and the symmetry as two wires swapping over \(
\iltikzfig{strings/symmetric/symmetry-tile}
\).
Composite terms are drawn as boxes \(
\iltikzfig{strings/category/f-wires-tile}
\); composition is then depicted as \emph{horizontal juxtaposition} and
tensor as \emph{vertical juxtaposition}.
\[
    \iltikzfig{strings/category/f-wires-tile}[box=f]
    \seq
    \iltikzfig{strings/category/f-wires-tile}[box=g]
    =
    \iltikzfig{strings/category/composition-tiles}[box1=f,box2=g,dom1=m,dom2=n,cod2=p]
\]



\section{Coloured terms}

In \(\Sigma\)-terms, the wires are \emph{monochromatic}; there is no
distinguishing between them.
Sometimes it is advantageous to \emph{annotate} wires with some information: in
the realm of terms this is often known as \emph{colouring} the wires.

\begin{remark}
    Colours are also referred to as \emph{sorts} in the literature, which leads
    to less pretty diagrams.
\end{remark}

When working with coloured terms, we need to fix a set of \emph{colours} before
specifying a set of generators.

\begin{notation}
    We say that a set \(C\) is \emph{countable} if it is finite or countably
    infinite, i.e.\ there exists set \(X \subseteq \nat\) such that there is a
    bijection \(C \cong X\).
\end{notation}

\begin{remark}
    Usually the set of colours is finite, but we will see later in this thesis
    how having a colour for every single natural number might be useful.
\end{remark}

In the monochromatic world the interface of a generator can be specified solely
by two natural numbers \(m\) and \(n\), as there are \(m\) input wires and
\(n\) output wires.
When the wires are coloured, more information is needed: the inputs and outputs
must be specified in terms of their colours and their ordering.

\begin{notation}[Words]
    Given a set \(A\), the set of words of elements of \(X\) is denoted
    \(\freemon{A}\).
    Words are written \(x_0x_1x_2{\cdots}x_{n-1}\); variables representing
    arbitrary words are generally written with an
    overline \(
    \listvar{x}, \listvar{y}, \listvar{z}... \in \freemon{X}
    \).
    Given two words \(\listvar{x}, \listvar{y}\), their concatenation is
    denoted \(\listvar{xy}\).
    The word of length \(n\) containing just element \(x\) is written \(x^n\).
    Given a word \(\listvar{x}\), its \emph{length} is denoted
    \(\wordlen{\listvar{x}}\); for \(i < \wordlen{\listvar{x}}\) the
    \(i\)-\emph{th element of \(\listvar{x}\)} is denoted \(\listvar{x}(i)\).
\end{notation}

\begin{definition}[Coloured generators]
    For a countable set \(C\), a set of \emph{\(C\)-coloured generators}
    \(\Sigma\) is a set equipped with two functions \(\Sigma \to \freemon{C}\).
\end{definition}

\begin{definition}[Coloured terms]
    For a countable set \(C\) and a set of \(C\)-coloured generators, a
    \((C,\Sigma)\)-term is written \(\morph{f}{\listvar{m}}{\listvar{n}}\),
    where \(\listvar{m},\listvar{n} \in \freemon{C}\).
    The set of \((C,\Sigma)\)-terms, denoted \((C,\Sigma)_\mathsf{t}\), is
    generated in the same way as the monochromatic set of terms, but with an
    identity and symmetry for each colour \(c \in C\), and addition replaced by
    word concatenation.
\end{definition}

\begin{remark}
    When the set of colours is a singleton \(C \coloneqq \{\bullet\}\), a
    \(C\)-coloured PROP is isomorphic to a monochromatic prop, as every word is
    of the form \(\bullet\bullet\cdots\bullet\) and as such can be fully
    specified by its length.
\end{remark}
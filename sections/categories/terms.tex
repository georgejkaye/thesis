\section{Terms}

Processes are modelled as \emph{terms}.
Before we can begin, the components that make up processes in a given system
must be specified.

\begin{definition}[Generators]
    A set of \emph{generators} \(\generators\) is a set equipped with two
    functions \(\morph{\dom,\cod}{\generators}{\nat}\).
\end{definition}

Generators are the primitive building blocks of terms: their domains and
codomains specify how many input and output wires they have respectively.
Terms are defined by combining these primitives together.

\begin{definition}[Term]
    \label{def:terms}
    Let \(\generators\) be a set of generators.
    A \(\generators\)-term is written \(\morph{f}{m}{n}\)
    where \(m,n \in \nat\).
    The set of \(\generators\)-terms, denoted \(\sigmaterms\), is
    generated as follows:
    \begin{center}
        \begin{bprooftree}
            \AxiomC{\(\phi \in \generators\)}
            \UnaryInfC{\(
                \morph{\phi}{\dom[\phi]}{\cod[\phi]} \in \sigmaterms
                \)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\phantom{\(\phi\)}}
            \UnaryInfC{\(\morph{\id[1]}{1}{1} \in \sigmaterms\)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(\morph{\id[0]}{0}{0} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{}
            \UnaryInfC{\(
                \morph{\swap{1}{1}}{2}{2} \in \sigmaterms
                \)}
        \end{bprooftree}

        \vspace{1em}

        \begin{bprooftree}
            \AxiomC{\(\morph{f}{m}{n} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{n}{p} \in \sigmaterms\)}
            \BinaryInfC{\(\morph{f \seq g}{m}{p} \in \sigmaterms\)}
        \end{bprooftree}
        \begin{bprooftree}
            \AxiomC{\(\morph{f}{m}{p} \in \sigmaterms\)}
            \AxiomC{\(\morph{g}{p}{q} \in \sigmaterms\)}
            \BinaryInfC{\(
                \morph{f \tensor g}{m+p}{n+q} \in \sigmaterms
                \)}
        \end{bprooftree}
    \end{center}
\end{definition}

\(\Sigma\)-terms are constructed recursively.
There are four base cases: a generator from \(\generators\) with appropriate
inputs and outputs; an \emph{identity} for single wires and empty space, and
a \emph{symmetry} for swapping over two wires.
The two inductive cases are called \emph{composition} and \emph{tensor}
respectively.
Intuitively, these can be thought of generating larger terms by sequencing
subterms in sequence or parallel.

Although here identities and symmetries only operate on single wires, it is
a simple exercise to define them for larger numbers of wires.

\begin{notation}[Composite identities]\label{not:composite-identities}
    Composite identities \(\id[n]\) are defined inductively for \(n \in \nat\)
    as \(
    \id[0] \coloneqq \id[0]\) and \(
    \id[k+1]
    \coloneqq
    \id[k] \tensor \id[1]
    \)
\end{notation}
\begin{notation}[Composite symmetries]\label{not:composite-symmetries}
    Composite symmetries \(\swap{m}{n}\) for \(m, n \in \nat\) are defined
    inductively as \(
    \swap{0}{n}
    \coloneqq
    \id[n]
    \), \(
    \swap{m}{0}
    \coloneqq \id[m]
    \), and \(
    \swap{k+1}{l+1}
    \coloneqq
    \id[k] \tensor \swap{1}{l} \tensor \id[1]
    \seq
    \swap{k}{l} \tensor \swap{1}{1}
    \seq
    \id[l] \tensor \swap{k}{1} \tensor \id[1]
    \).
\end{notation}

\(\Sigma\)-terms will be abbreviated to `terms' when the signature is clear from
context.

\begin{example}
    \todo[inline]{Think of a funky example}
\end{example}

\begin{remark}
    It is clear that even simple terms described using one-dimensional text
    strings quickly become indecipherable.
    In the next section we will detail a \emph{graphical syntax} which should
    make things much clearer.
\end{remark}

\section{Coloured terms}

Sometimes the generators we work with will not just have featureless input and
output wires, but these wires will be \emph{annotated} with some sort of
information, like a type.
In the realm of terms this is often known as \emph{colouring} the wires.

\begin{remark}
    Colours can also be referred to as \emph{sorts} in the literature.
\end{remark}

When working with coloured terms, we need to fix a set of \emph{colours}.

\begin{notation}
    We say that a set \(C\) is \emph{countable} if it is finite or countably
    infinite, i.e.\ there is a bijection \(C \cong \nat\).
\end{notation}

\begin{remark}
    Usually the set of colours is finite, but we will see later in this thesis
    how having a colour for every single natural number might be useful.
\end{remark}

Instead of generators mapping from two natural numbers, generators coloured over
a set \(C\) map between words of \(C\).

\begin{notation}[Words]
    Given a set \(A\), the set of words of elements of \(X\) is denoted
    \(\freemon{A}\).
    Words are written \(x_0x_1x_2{\cdots}x_{n-1}\); variables representing
    arbitrary words are generally written with an
    overline \(
    \listvar{x}, \listvar{y}, \listvar{z}... \in \freemon{X}
    \).
    Given two words \(\listvar{x}, \listvar{y}\), their concatenation is
    denoted \(\listvar{xy}\).
    The word of length \(n\) containing just element \(x\) is written \(x^n\).
    Given a word \(\listvar{x}\), its \emph{length} is denoted
    \(\wordlen{\listvar{x}}\); for \(i < \wordlen{\listvar{x}}\) and its
    \(i\)\emph{th element} is denoted \(\listvar{x}(i)\).
\end{notation}